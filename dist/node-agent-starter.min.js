"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));

// node_modules/forever-monitor/lib/forever-monitor/utils.js
var require_utils = __commonJS({
  "node_modules/forever-monitor/lib/forever-monitor/utils.js"(exports, module2) {
    function randomString(length) {
      let rand, i, ret, bits;
      const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
      const mod = 4;
      ret = "";
      bits = length * mod || 64;
      while (bits > 0) {
        rand = Math.floor(Math.random() * 4294967296);
        for (i = 26; i > 0 && bits > 0; i -= mod, bits -= mod) {
          ret += chars[63 & rand >>> i];
        }
      }
      return ret;
    }
    module2.exports = {
      randomString
    };
  }
});

// node_modules/through/index.js
var require_through = __commonJS({
  "node_modules/through/index.js"(exports, module2) {
    var Stream = require("stream");
    exports = module2.exports = through;
    through.through = through;
    function through(write, end, opts) {
      write = write || function(data) {
        this.queue(data);
      };
      end = end || function() {
        this.queue(null);
      };
      var ended = false, destroyed = false, buffer = [], _ended = false;
      var stream = new Stream();
      stream.readable = stream.writable = true;
      stream.paused = false;
      stream.autoDestroy = !(opts && opts.autoDestroy === false);
      stream.write = function(data) {
        write.call(this, data);
        return !stream.paused;
      };
      function drain() {
        while (buffer.length && !stream.paused) {
          var data = buffer.shift();
          if (data === null)
            return stream.emit("end");
          else
            stream.emit("data", data);
        }
      }
      stream.queue = stream.push = function(data) {
        if (_ended)
          return stream;
        if (data === null)
          _ended = true;
        buffer.push(data);
        drain();
        return stream;
      };
      stream.on("end", function() {
        stream.readable = false;
        if (!stream.writable && stream.autoDestroy)
          process.nextTick(function() {
            stream.destroy();
          });
      });
      function _end() {
        stream.writable = false;
        end.call(stream);
        if (!stream.readable && stream.autoDestroy)
          stream.destroy();
      }
      stream.end = function(data) {
        if (ended)
          return;
        ended = true;
        if (arguments.length)
          stream.write(data);
        _end();
        return stream;
      };
      stream.destroy = function() {
        if (destroyed)
          return;
        destroyed = true;
        ended = true;
        buffer.length = 0;
        stream.writable = stream.readable = false;
        stream.emit("close");
        return stream;
      };
      stream.pause = function() {
        if (stream.paused)
          return;
        stream.paused = true;
        return stream;
      };
      stream.resume = function() {
        if (stream.paused) {
          stream.paused = false;
          stream.emit("resume");
        }
        drain();
        if (!stream.paused)
          stream.emit("drain");
        return stream;
      };
      return stream;
    }
  }
});

// node_modules/from/index.js
var require_from = __commonJS({
  "node_modules/from/index.js"(exports, module2) {
    "use strict";
    var Stream = require("stream");
    module2.exports = function from(source) {
      if (Array.isArray(source)) {
        var source_index = 0, source_len = source.length;
        return from(function(i2) {
          if (source_index < source_len)
            this.emit("data", source[source_index++]);
          else
            this.emit("end");
          return true;
        });
      }
      var s = new Stream(), i = 0;
      s.ended = false;
      s.started = false;
      s.readable = true;
      s.writable = false;
      s.paused = false;
      s.ended = false;
      s.pause = function() {
        s.started = true;
        s.paused = true;
      };
      function next() {
        s.started = true;
        if (s.ended)
          return;
        while (!s.ended && !s.paused && source.call(s, i++, function() {
          if (!s.ended && !s.paused)
            process.nextTick(next);
        }))
          ;
      }
      s.resume = function() {
        s.started = true;
        s.paused = false;
        next();
      };
      s.on("end", function() {
        s.ended = true;
        s.readable = false;
        process.nextTick(s.destroy);
      });
      s.destroy = function() {
        s.ended = true;
        s.emit("close");
      };
      process.nextTick(function() {
        if (!s.started)
          s.resume();
      });
      return s;
    };
  }
});

// node_modules/duplexer/index.js
var require_duplexer = __commonJS({
  "node_modules/duplexer/index.js"(exports, module2) {
    var Stream = require("stream");
    var writeMethods = ["write", "end", "destroy"];
    var readMethods = ["resume", "pause"];
    var readEvents = ["data", "close"];
    var slice = Array.prototype.slice;
    module2.exports = duplex;
    function forEach(arr, fn) {
      if (arr.forEach) {
        return arr.forEach(fn);
      }
      for (var i = 0; i < arr.length; i++) {
        fn(arr[i], i);
      }
    }
    function duplex(writer, reader) {
      var stream = new Stream();
      var ended = false;
      forEach(writeMethods, proxyWriter);
      forEach(readMethods, proxyReader);
      forEach(readEvents, proxyStream);
      reader.on("end", handleEnd);
      writer.on("drain", function() {
        stream.emit("drain");
      });
      writer.on("error", reemit);
      reader.on("error", reemit);
      stream.writable = writer.writable;
      stream.readable = reader.readable;
      return stream;
      function proxyWriter(methodName) {
        stream[methodName] = method;
        function method() {
          return writer[methodName].apply(writer, arguments);
        }
      }
      function proxyReader(methodName) {
        stream[methodName] = method;
        function method() {
          stream.emit(methodName);
          var func = reader[methodName];
          if (func) {
            return func.apply(reader, arguments);
          }
          reader.emit(methodName);
        }
      }
      function proxyStream(methodName) {
        reader.on(methodName, reemit2);
        function reemit2() {
          var args = slice.call(arguments);
          args.unshift(methodName);
          stream.emit.apply(stream, args);
        }
      }
      function handleEnd() {
        if (ended) {
          return;
        }
        ended = true;
        var args = slice.call(arguments);
        args.unshift("end");
        stream.emit.apply(stream, args);
      }
      function reemit(err) {
        stream.emit("error", err);
      }
    }
  }
});

// node_modules/map-stream/index.js
var require_map_stream = __commonJS({
  "node_modules/map-stream/index.js"(exports, module2) {
    var Stream = require("stream").Stream;
    module2.exports = function(mapper, opts) {
      var stream = new Stream(), self2 = this, inputs = 0, outputs = 0, ended = false, paused = false, destroyed = false, lastWritten = 0, inNext = false;
      this.opts = opts || {};
      var errorEventName = this.opts.failures ? "failure" : "error";
      var writeQueue = {};
      stream.writable = true;
      stream.readable = true;
      function queueData(data, number) {
        var nextToWrite = lastWritten + 1;
        if (number === nextToWrite) {
          if (data !== void 0) {
            stream.emit.apply(stream, ["data", data]);
          }
          lastWritten++;
          nextToWrite++;
        } else {
          writeQueue[number] = data;
        }
        if (writeQueue.hasOwnProperty(nextToWrite)) {
          var dataToWrite = writeQueue[nextToWrite];
          delete writeQueue[nextToWrite];
          return queueData(dataToWrite, nextToWrite);
        }
        outputs++;
        if (inputs === outputs) {
          if (paused)
            paused = false, stream.emit("drain");
          if (ended)
            end();
        }
      }
      function next(err, data, number) {
        if (destroyed)
          return;
        inNext = true;
        if (!err || self2.opts.failures) {
          queueData(data, number);
        }
        if (err) {
          stream.emit.apply(stream, [errorEventName, err]);
        }
        inNext = false;
      }
      function wrappedMapper(input, number, callback) {
        return mapper.call(null, input, function(err, data) {
          callback(err, data, number);
        });
      }
      stream.write = function(data) {
        if (ended)
          throw new Error("map stream is not writable");
        inNext = false;
        inputs++;
        try {
          var written = wrappedMapper(data, inputs, next);
          paused = written === false;
          return !paused;
        } catch (err) {
          if (inNext)
            throw err;
          next(err);
          return !paused;
        }
      };
      function end(data) {
        ended = true;
        stream.writable = false;
        if (data !== void 0) {
          return queueData(data, inputs);
        } else if (inputs == outputs) {
          stream.readable = false, stream.emit("end"), stream.destroy();
        }
      }
      stream.end = function(data) {
        if (ended)
          return;
        end();
      };
      stream.destroy = function() {
        ended = destroyed = true;
        stream.writable = stream.readable = paused = false;
        process.nextTick(function() {
          stream.emit("close");
        });
      };
      stream.pause = function() {
        paused = true;
      };
      stream.resume = function() {
        paused = false;
      };
      return stream;
    };
  }
});

// node_modules/pause-stream/index.js
var require_pause_stream = __commonJS({
  "node_modules/pause-stream/index.js"(exports, module2) {
    module2.exports = require_through();
  }
});

// node_modules/split/index.js
var require_split = __commonJS({
  "node_modules/split/index.js"(exports, module2) {
    var through = require_through();
    var Decoder = require("string_decoder").StringDecoder;
    module2.exports = split;
    function split(matcher, mapper, options) {
      var decoder = new Decoder();
      var soFar = "";
      var maxLength = options && options.maxLength;
      if (typeof matcher === "function")
        mapper = matcher, matcher = null;
      if (!matcher)
        matcher = /\r?\n/;
      function emit(stream, piece) {
        if (mapper) {
          try {
            piece = mapper(piece);
          } catch (err) {
            return stream.emit("error", err);
          }
          if (typeof piece !== "undefined")
            stream.queue(piece);
        } else
          stream.queue(piece);
      }
      function next(stream, buffer) {
        var pieces = ((soFar != null ? soFar : "") + buffer).split(matcher);
        soFar = pieces.pop();
        if (maxLength && soFar.length > maxLength)
          stream.emit("error", new Error("maximum buffer reached"));
        for (var i = 0; i < pieces.length; i++) {
          var piece = pieces[i];
          emit(stream, piece);
        }
      }
      return through(function(b) {
        next(this, decoder.write(b));
      }, function() {
        if (decoder.end)
          next(this, decoder.end());
        if (soFar != null)
          emit(this, soFar);
        this.queue(null);
      });
    }
  }
});

// node_modules/stream-combiner/index.js
var require_stream_combiner = __commonJS({
  "node_modules/stream-combiner/index.js"(exports, module2) {
    var duplexer = require_duplexer();
    module2.exports = function() {
      var streams = [].slice.call(arguments), first = streams[0], last = streams[streams.length - 1], thepipe = duplexer(first, last);
      if (streams.length == 1)
        return streams[0];
      else if (!streams.length)
        throw new Error("connect called with empty args");
      function recurse(streams2) {
        if (streams2.length < 2)
          return;
        streams2[0].pipe(streams2[1]);
        recurse(streams2.slice(1));
      }
      recurse(streams);
      function onerror() {
        var args = [].slice.call(arguments);
        args.unshift("error");
        thepipe.emit.apply(thepipe, args);
      }
      for (var i = 1; i < streams.length - 1; i++)
        streams[i].on("error", onerror);
      return thepipe;
    };
  }
});

// node_modules/event-stream/index.js
var require_event_stream = __commonJS({
  "node_modules/event-stream/index.js"(exports) {
    var Stream = require("stream").Stream;
    var es = exports;
    var through = require_through();
    var from = require_from();
    var duplex = require_duplexer();
    var map = require_map_stream();
    var pause = require_pause_stream();
    var split = require_split();
    var pipeline = require_stream_combiner();
    var immediately = global.setImmediate || process.nextTick;
    es.Stream = Stream;
    es.through = through;
    es.from = from;
    es.duplex = duplex;
    es.map = map;
    es.pause = pause;
    es.split = split;
    es.pipeline = es.connect = es.pipe = pipeline;
    es.concat = es.merge = function() {
      var toMerge = [].slice.call(arguments);
      if (toMerge.length === 1 && toMerge[0] instanceof Array) {
        toMerge = toMerge[0];
      }
      var stream = new Stream();
      stream.setMaxListeners(0);
      var endCount = 0;
      stream.writable = stream.readable = true;
      if (toMerge.length) {
        toMerge.forEach(function(e) {
          e.pipe(stream, { end: false });
          var ended = false;
          e.on("end", function() {
            if (ended)
              return;
            ended = true;
            endCount++;
            if (endCount == toMerge.length)
              stream.emit("end");
          });
        });
      } else {
        process.nextTick(function() {
          stream.emit("end");
        });
      }
      stream.write = function(data) {
        this.emit("data", data);
      };
      stream.destroy = function() {
        toMerge.forEach(function(e) {
          if (e.destroy)
            e.destroy();
        });
      };
      return stream;
    };
    es.writeArray = function(done) {
      if (typeof done !== "function")
        throw new Error("function writeArray (done): done must be function");
      var a = new Stream(), array = [], isDone = false;
      a.write = function(l) {
        array.push(l);
      };
      a.end = function() {
        isDone = true;
        done(null, array);
      };
      a.writable = true;
      a.readable = false;
      a.destroy = function() {
        a.writable = a.readable = false;
        if (isDone)
          return;
        done(new Error("destroyed before end"), array);
      };
      return a;
    };
    es.readArray = function(array) {
      var stream = new Stream(), i = 0, paused = false, ended = false;
      stream.readable = true;
      stream.writable = false;
      if (!Array.isArray(array))
        throw new Error("event-stream.read expects an array");
      stream.resume = function() {
        if (ended)
          return;
        paused = false;
        var l = array.length;
        while (i < l && !paused && !ended) {
          stream.emit("data", array[i++]);
        }
        if (i == l && !ended)
          ended = true, stream.readable = false, stream.emit("end");
      };
      process.nextTick(stream.resume);
      stream.pause = function() {
        paused = true;
      };
      stream.destroy = function() {
        ended = true;
        stream.emit("close");
      };
      return stream;
    };
    es.readable = function(func, continueOnError) {
      var stream = new Stream(), i = 0, paused = false, ended = false, reading = false;
      stream.readable = true;
      stream.writable = false;
      if (typeof func !== "function")
        throw new Error("event-stream.readable expects async function");
      stream.on("end", function() {
        ended = true;
      });
      function get(err, data) {
        if (err) {
          stream.emit("error", err);
          if (!continueOnError)
            stream.emit("end");
        } else if (arguments.length > 1)
          stream.emit("data", data);
        immediately(function() {
          if (ended || paused || reading)
            return;
          try {
            reading = true;
            func.call(stream, i++, function() {
              reading = false;
              get.apply(null, arguments);
            });
          } catch (err2) {
            stream.emit("error", err2);
          }
        });
      }
      stream.resume = function() {
        paused = false;
        get();
      };
      process.nextTick(get);
      stream.pause = function() {
        paused = true;
      };
      stream.destroy = function() {
        stream.emit("end");
        stream.emit("close");
        ended = true;
      };
      return stream;
    };
    es.mapSync = function(sync) {
      return es.through(function write(data) {
        var mappedData;
        try {
          mappedData = sync(data);
        } catch (err) {
          return this.emit("error", err);
        }
        if (mappedData !== void 0)
          this.emit("data", mappedData);
      });
    };
    es.log = function(name) {
      return es.through(function(data) {
        var args = [].slice.call(arguments);
        if (name)
          console.error(name, data);
        else
          console.error(data);
        this.emit("data", data);
      });
    };
    es.child = function(child2) {
      return es.duplex(child2.stdin, child2.stdout);
    };
    es.parse = function(options) {
      var emitError = !!(options ? options.error : false);
      return es.through(function(data) {
        var obj;
        try {
          if (data)
            obj = JSON.parse(data.toString());
        } catch (err) {
          if (emitError)
            return this.emit("error", err);
          return console.error(err, "attempting to parse:", data);
        }
        if (obj !== void 0)
          this.emit("data", obj);
      });
    };
    es.stringify = function() {
      var Buffer2 = require("buffer").Buffer;
      return es.mapSync(function(e) {
        return JSON.stringify(Buffer2.isBuffer(e) ? e.toString() : e) + "\n";
      });
    };
    es.replace = function(from2, to) {
      return es.pipeline(es.split(from2), es.join(to));
    };
    es.join = function(str) {
      if (typeof str === "function")
        return es.wait(str);
      var first = true;
      return es.through(function(data) {
        if (!first)
          this.emit("data", str);
        first = false;
        this.emit("data", data);
        return true;
      });
    };
    es.wait = function(callback) {
      var arr = [];
      return es.through(function(data) {
        arr.push(data);
      }, function() {
        var body = Buffer.isBuffer(arr[0]) ? Buffer.concat(arr) : arr.join("");
        this.emit("data", body);
        this.emit("end");
        if (callback)
          callback(null, body);
      });
    };
    es.pipeable = function() {
      throw new Error("[EVENT-STREAM] es.pipeable is deprecated");
    };
  }
});

// node_modules/ps-tree/index.js
var require_ps_tree = __commonJS({
  "node_modules/ps-tree/index.js"(exports, module2) {
    "use strict";
    var spawn = require("child_process").spawn;
    var es = require_event_stream();
    module2.exports = function childrenOfPid(pid, callback) {
      var headers = null;
      if (typeof callback !== "function") {
        throw new Error("childrenOfPid(pid, callback) expects callback");
      }
      if (typeof pid === "number") {
        pid = pid.toString();
      }
      var processLister;
      if (process.platform === "win32") {
        processLister = spawn("wmic.exe", ["PROCESS", "GET", "Name,ProcessId,ParentProcessId,Status"]);
      } else {
        processLister = spawn("ps", ["-A", "-o", "ppid,pid,stat,comm"]);
      }
      es.connect(processLister.stdout, es.split(), es.map(function(line, cb) {
        var columns = line.trim().split(/\s+/);
        if (!headers) {
          headers = columns;
          headers = headers.map(normalizeHeader);
          return cb();
        }
        var row = {};
        var h = headers.slice();
        while (h.length) {
          row[h.shift()] = h.length ? columns.shift() : columns.join(" ");
        }
        return cb(null, row);
      }), es.writeArray(function(err, ps) {
        var parents = {}, children = [];
        parents[pid] = true;
        ps.forEach(function(proc) {
          if (parents[proc.PPID]) {
            parents[proc.PID] = true;
            children.push(proc);
          }
        });
        callback(null, children);
      })).on("error", callback);
    };
    function normalizeHeader(str) {
      if (process.platform !== "win32") {
        return str;
      }
      switch (str) {
        case "Name":
          return "COMMAND";
          break;
        case "ParentProcessId":
          return "PPID";
          break;
        case "ProcessId":
          return "PID";
          break;
        case "Status":
          return "STAT";
          break;
        default:
          throw new Error("Unknown process listing header: " + str);
      }
    }
  }
});

// node_modules/forever-monitor/lib/forever-monitor/common.js
var require_common = __commonJS({
  "node_modules/forever-monitor/lib/forever-monitor/common.js"(exports) {
    var psTree = require_ps_tree();
    exports.checkProcess = function(pid) {
      if (!pid) {
        return false;
      }
      try {
        process.kill(pid, 0);
        return true;
      } catch (err) {
        return false;
      }
    };
    exports.kill = function(pid, killTree, signal, callback) {
      signal = signal || "SIGKILL";
      callback = callback || function() {
      };
      if (killTree && process.platform !== "win32") {
        psTree(pid, function(err, children) {
          [pid].concat(children.map(function(p) {
            return p.PID;
          })).forEach(function(tpid) {
            try {
              process.kill(tpid, signal);
            } catch (ex) {
            }
          });
          callback();
        });
      } else {
        try {
          process.kill(pid, signal);
        } catch (ex) {
        }
        callback();
      }
    };
  }
});

// node_modules/eventemitter2/lib/eventemitter2.js
var require_eventemitter2 = __commonJS({
  "node_modules/eventemitter2/lib/eventemitter2.js"(exports, module2) {
    !function(undefined2) {
      var hasOwnProperty = Object.hasOwnProperty;
      var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
      var defaultMaxListeners = 10;
      var nextTickSupported = typeof process == "object" && typeof process.nextTick == "function";
      var symbolsSupported = typeof Symbol === "function";
      var reflectSupported = typeof Reflect === "object";
      var setImmediateSupported = typeof setImmediate === "function";
      var _setImmediate = setImmediateSupported ? setImmediate : setTimeout;
      var ownKeys = symbolsSupported ? reflectSupported && typeof Reflect.ownKeys === "function" ? Reflect.ownKeys : function(obj) {
        var arr = Object.getOwnPropertyNames(obj);
        arr.push.apply(arr, Object.getOwnPropertySymbols(obj));
        return arr;
      } : Object.keys;
      function init() {
        this._events = {};
        if (this._conf) {
          configure.call(this, this._conf);
        }
      }
      function configure(conf) {
        if (conf) {
          this._conf = conf;
          conf.delimiter && (this.delimiter = conf.delimiter);
          if (conf.maxListeners !== undefined2) {
            this._maxListeners = conf.maxListeners;
          }
          conf.wildcard && (this.wildcard = conf.wildcard);
          conf.newListener && (this._newListener = conf.newListener);
          conf.removeListener && (this._removeListener = conf.removeListener);
          conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);
          conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);
          if (this.wildcard) {
            this.listenerTree = {};
          }
        }
      }
      function logPossibleMemoryLeak(count, eventName) {
        var errorMsg = "(node) warning: possible EventEmitter memory leak detected. " + count + " listeners added. Use emitter.setMaxListeners() to increase limit.";
        if (this.verboseMemoryLeak) {
          errorMsg += " Event name: " + eventName + ".";
        }
        if (typeof process !== "undefined" && process.emitWarning) {
          var e = new Error(errorMsg);
          e.name = "MaxListenersExceededWarning";
          e.emitter = this;
          e.count = count;
          process.emitWarning(e);
        } else {
          console.error(errorMsg);
          if (console.trace) {
            console.trace();
          }
        }
      }
      var toArray = function(a, b, c) {
        var n = arguments.length;
        switch (n) {
          case 0:
            return [];
          case 1:
            return [a];
          case 2:
            return [a, b];
          case 3:
            return [a, b, c];
          default:
            var arr = new Array(n);
            while (n--) {
              arr[n] = arguments[n];
            }
            return arr;
        }
      };
      function toObject(keys, values) {
        var obj = {};
        var key;
        var len = keys.length;
        var valuesCount = values ? values.length : 0;
        for (var i = 0; i < len; i++) {
          key = keys[i];
          obj[key] = i < valuesCount ? values[i] : undefined2;
        }
        return obj;
      }
      function TargetObserver(emitter, target, options) {
        this._emitter = emitter;
        this._target = target;
        this._listeners = {};
        this._listenersCount = 0;
        var on, off;
        if (options.on || options.off) {
          on = options.on;
          off = options.off;
        }
        if (target.addEventListener) {
          on = target.addEventListener;
          off = target.removeEventListener;
        } else if (target.addListener) {
          on = target.addListener;
          off = target.removeListener;
        } else if (target.on) {
          on = target.on;
          off = target.off;
        }
        if (!on && !off) {
          throw Error("target does not implement any known event API");
        }
        if (typeof on !== "function") {
          throw TypeError("on method must be a function");
        }
        if (typeof off !== "function") {
          throw TypeError("off method must be a function");
        }
        this._on = on;
        this._off = off;
        var _observers = emitter._observers;
        if (_observers) {
          _observers.push(this);
        } else {
          emitter._observers = [this];
        }
      }
      Object.assign(TargetObserver.prototype, {
        subscribe: function(event, localEvent, reducer) {
          var observer = this;
          var target = this._target;
          var emitter = this._emitter;
          var listeners = this._listeners;
          var handler = function() {
            var args = toArray.apply(null, arguments);
            var eventObj = {
              data: args,
              name: localEvent,
              original: event
            };
            if (reducer) {
              var result = reducer.call(target, eventObj);
              if (result !== false) {
                emitter.emit.apply(emitter, [eventObj.name].concat(args));
              }
              return;
            }
            emitter.emit.apply(emitter, [localEvent].concat(args));
          };
          if (listeners[event]) {
            throw Error("Event '" + event + "' is already listening");
          }
          this._listenersCount++;
          if (emitter._newListener && emitter._removeListener && !observer._onNewListener) {
            this._onNewListener = function(_event) {
              if (_event === localEvent && listeners[event] === null) {
                listeners[event] = handler;
                observer._on.call(target, event, handler);
              }
            };
            emitter.on("newListener", this._onNewListener);
            this._onRemoveListener = function(_event) {
              if (_event === localEvent && !emitter.hasListeners(_event) && listeners[event]) {
                listeners[event] = null;
                observer._off.call(target, event, handler);
              }
            };
            listeners[event] = null;
            emitter.on("removeListener", this._onRemoveListener);
          } else {
            listeners[event] = handler;
            observer._on.call(target, event, handler);
          }
        },
        unsubscribe: function(event) {
          var observer = this;
          var listeners = this._listeners;
          var emitter = this._emitter;
          var handler;
          var events;
          var off = this._off;
          var target = this._target;
          var i;
          if (event && typeof event !== "string") {
            throw TypeError("event must be a string");
          }
          function clearRefs() {
            if (observer._onNewListener) {
              emitter.off("newListener", observer._onNewListener);
              emitter.off("removeListener", observer._onRemoveListener);
              observer._onNewListener = null;
              observer._onRemoveListener = null;
            }
            var index = findTargetIndex.call(emitter, observer);
            emitter._observers.splice(index, 1);
          }
          if (event) {
            handler = listeners[event];
            if (!handler)
              return;
            off.call(target, event, handler);
            delete listeners[event];
            if (!--this._listenersCount) {
              clearRefs();
            }
          } else {
            events = ownKeys(listeners);
            i = events.length;
            while (i-- > 0) {
              event = events[i];
              off.call(target, event, listeners[event]);
            }
            this._listeners = {};
            this._listenersCount = 0;
            clearRefs();
          }
        }
      });
      function resolveOptions(options, schema, reducers, allowUnknown) {
        var computedOptions = Object.assign({}, schema);
        if (!options)
          return computedOptions;
        if (typeof options !== "object") {
          throw TypeError("options must be an object");
        }
        var keys = Object.keys(options);
        var length = keys.length;
        var option, value;
        var reducer;
        function reject(reason) {
          throw Error('Invalid "' + option + '" option value' + (reason ? ". Reason: " + reason : ""));
        }
        for (var i = 0; i < length; i++) {
          option = keys[i];
          if (!allowUnknown && !hasOwnProperty.call(schema, option)) {
            throw Error('Unknown "' + option + '" option');
          }
          value = options[option];
          if (value !== undefined2) {
            reducer = reducers[option];
            computedOptions[option] = reducer ? reducer(value, reject) : value;
          }
        }
        return computedOptions;
      }
      function constructorReducer(value, reject) {
        if (typeof value !== "function" || !value.hasOwnProperty("prototype")) {
          reject("value must be a constructor");
        }
        return value;
      }
      function makeTypeReducer(types) {
        var message = "value must be type of " + types.join("|");
        var len = types.length;
        var firstType = types[0];
        var secondType = types[1];
        if (len === 1) {
          return function(v, reject) {
            if (typeof v === firstType) {
              return v;
            }
            reject(message);
          };
        }
        if (len === 2) {
          return function(v, reject) {
            var kind = typeof v;
            if (kind === firstType || kind === secondType)
              return v;
            reject(message);
          };
        }
        return function(v, reject) {
          var kind = typeof v;
          var i = len;
          while (i-- > 0) {
            if (kind === types[i])
              return v;
          }
          reject(message);
        };
      }
      var functionReducer = makeTypeReducer(["function"]);
      var objectFunctionReducer = makeTypeReducer(["object", "function"]);
      function makeCancelablePromise(Promise2, executor, options) {
        var isCancelable;
        var callbacks;
        var timer = 0;
        var subscriptionClosed;
        var promise = new Promise2(function(resolve, reject, onCancel) {
          options = resolveOptions(options, {
            timeout: 0,
            overload: false
          }, {
            timeout: function(value, reject2) {
              value *= 1;
              if (typeof value !== "number" || value < 0 || !Number.isFinite(value)) {
                reject2("timeout must be a positive number");
              }
              return value;
            }
          });
          isCancelable = !options.overload && typeof Promise2.prototype.cancel === "function" && typeof onCancel === "function";
          function cleanup() {
            if (callbacks) {
              callbacks = null;
            }
            if (timer) {
              clearTimeout(timer);
              timer = 0;
            }
          }
          var _resolve = function(value) {
            cleanup();
            resolve(value);
          };
          var _reject = function(err) {
            cleanup();
            reject(err);
          };
          if (isCancelable) {
            executor(_resolve, _reject, onCancel);
          } else {
            callbacks = [function(reason) {
              _reject(reason || Error("canceled"));
            }];
            executor(_resolve, _reject, function(cb) {
              if (subscriptionClosed) {
                throw Error("Unable to subscribe on cancel event asynchronously");
              }
              if (typeof cb !== "function") {
                throw TypeError("onCancel callback must be a function");
              }
              callbacks.push(cb);
            });
            subscriptionClosed = true;
          }
          if (options.timeout > 0) {
            timer = setTimeout(function() {
              var reason = Error("timeout");
              reason.code = "ETIMEDOUT";
              timer = 0;
              promise.cancel(reason);
              reject(reason);
            }, options.timeout);
          }
        });
        if (!isCancelable) {
          promise.cancel = function(reason) {
            if (!callbacks) {
              return;
            }
            var length = callbacks.length;
            for (var i = 1; i < length; i++) {
              callbacks[i](reason);
            }
            callbacks[0](reason);
            callbacks = null;
          };
        }
        return promise;
      }
      function findTargetIndex(observer) {
        var observers = this._observers;
        if (!observers) {
          return -1;
        }
        var len = observers.length;
        for (var i = 0; i < len; i++) {
          if (observers[i]._target === observer)
            return i;
        }
        return -1;
      }
      function searchListenerTree(handlers, type, tree, i, typeLength) {
        if (!tree) {
          return null;
        }
        if (i === 0) {
          var kind = typeof type;
          if (kind === "string") {
            var ns, n, l = 0, j = 0, delimiter = this.delimiter, dl = delimiter.length;
            if ((n = type.indexOf(delimiter)) !== -1) {
              ns = new Array(5);
              do {
                ns[l++] = type.slice(j, n);
                j = n + dl;
              } while ((n = type.indexOf(delimiter, j)) !== -1);
              ns[l++] = type.slice(j);
              type = ns;
              typeLength = l;
            } else {
              type = [type];
              typeLength = 1;
            }
          } else if (kind === "object") {
            typeLength = type.length;
          } else {
            type = [type];
            typeLength = 1;
          }
        }
        var listeners = null, branch, xTree, xxTree, isolatedBranch, endReached, currentType = type[i], nextType = type[i + 1], branches, _listeners;
        if (i === typeLength) {
          if (tree._listeners) {
            if (typeof tree._listeners === "function") {
              handlers && handlers.push(tree._listeners);
              listeners = [tree];
            } else {
              handlers && handlers.push.apply(handlers, tree._listeners);
              listeners = [tree];
            }
          }
        } else {
          if (currentType === "*") {
            branches = ownKeys(tree);
            n = branches.length;
            while (n-- > 0) {
              branch = branches[n];
              if (branch !== "_listeners") {
                _listeners = searchListenerTree(handlers, type, tree[branch], i + 1, typeLength);
                if (_listeners) {
                  if (listeners) {
                    listeners.push.apply(listeners, _listeners);
                  } else {
                    listeners = _listeners;
                  }
                }
              }
            }
            return listeners;
          } else if (currentType === "**") {
            endReached = i + 1 === typeLength || i + 2 === typeLength && nextType === "*";
            if (endReached && tree._listeners) {
              listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength);
            }
            branches = ownKeys(tree);
            n = branches.length;
            while (n-- > 0) {
              branch = branches[n];
              if (branch !== "_listeners") {
                if (branch === "*" || branch === "**") {
                  if (tree[branch]._listeners && !endReached) {
                    _listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength);
                    if (_listeners) {
                      if (listeners) {
                        listeners.push.apply(listeners, _listeners);
                      } else {
                        listeners = _listeners;
                      }
                    }
                  }
                  _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);
                } else if (branch === nextType) {
                  _listeners = searchListenerTree(handlers, type, tree[branch], i + 2, typeLength);
                } else {
                  _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);
                }
                if (_listeners) {
                  if (listeners) {
                    listeners.push.apply(listeners, _listeners);
                  } else {
                    listeners = _listeners;
                  }
                }
              }
            }
            return listeners;
          } else if (tree[currentType]) {
            listeners = searchListenerTree(handlers, type, tree[currentType], i + 1, typeLength);
          }
        }
        xTree = tree["*"];
        if (xTree) {
          searchListenerTree(handlers, type, xTree, i + 1, typeLength);
        }
        xxTree = tree["**"];
        if (xxTree) {
          if (i < typeLength) {
            if (xxTree._listeners) {
              searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
            }
            branches = ownKeys(xxTree);
            n = branches.length;
            while (n-- > 0) {
              branch = branches[n];
              if (branch !== "_listeners") {
                if (branch === nextType) {
                  searchListenerTree(handlers, type, xxTree[branch], i + 2, typeLength);
                } else if (branch === currentType) {
                  searchListenerTree(handlers, type, xxTree[branch], i + 1, typeLength);
                } else {
                  isolatedBranch = {};
                  isolatedBranch[branch] = xxTree[branch];
                  searchListenerTree(handlers, type, { "**": isolatedBranch }, i + 1, typeLength);
                }
              }
            }
          } else if (xxTree._listeners) {
            searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
          } else if (xxTree["*"] && xxTree["*"]._listeners) {
            searchListenerTree(handlers, type, xxTree["*"], typeLength, typeLength);
          }
        }
        return listeners;
      }
      function growListenerTree(type, listener, prepend) {
        var len = 0, j = 0, i, delimiter = this.delimiter, dl = delimiter.length, ns;
        if (typeof type === "string") {
          if ((i = type.indexOf(delimiter)) !== -1) {
            ns = new Array(5);
            do {
              ns[len++] = type.slice(j, i);
              j = i + dl;
            } while ((i = type.indexOf(delimiter, j)) !== -1);
            ns[len++] = type.slice(j);
          } else {
            ns = [type];
            len = 1;
          }
        } else {
          ns = type;
          len = type.length;
        }
        if (len > 1) {
          for (i = 0; i + 1 < len; i++) {
            if (ns[i] === "**" && ns[i + 1] === "**") {
              return;
            }
          }
        }
        var tree = this.listenerTree, name;
        for (i = 0; i < len; i++) {
          name = ns[i];
          tree = tree[name] || (tree[name] = {});
          if (i === len - 1) {
            if (!tree._listeners) {
              tree._listeners = listener;
            } else {
              if (typeof tree._listeners === "function") {
                tree._listeners = [tree._listeners];
              }
              if (prepend) {
                tree._listeners.unshift(listener);
              } else {
                tree._listeners.push(listener);
              }
              if (!tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners) {
                tree._listeners.warned = true;
                logPossibleMemoryLeak.call(this, tree._listeners.length, name);
              }
            }
            return true;
          }
        }
        return true;
      }
      function collectTreeEvents(tree, events, root, asArray) {
        var branches = ownKeys(tree);
        var i = branches.length;
        var branch, branchName, path;
        var hasListeners = tree["_listeners"];
        var isArrayPath;
        while (i-- > 0) {
          branchName = branches[i];
          branch = tree[branchName];
          if (branchName === "_listeners") {
            path = root;
          } else {
            path = root ? root.concat(branchName) : [branchName];
          }
          isArrayPath = asArray || typeof branchName === "symbol";
          hasListeners && events.push(isArrayPath ? path : path.join(this.delimiter));
          if (typeof branch === "object") {
            collectTreeEvents.call(this, branch, events, path, isArrayPath);
          }
        }
        return events;
      }
      function recursivelyGarbageCollect(root) {
        var keys = ownKeys(root);
        var i = keys.length;
        var obj, key, flag;
        while (i-- > 0) {
          key = keys[i];
          obj = root[key];
          if (obj) {
            flag = true;
            if (key !== "_listeners" && !recursivelyGarbageCollect(obj)) {
              delete root[key];
            }
          }
        }
        return flag;
      }
      function Listener(emitter, event, listener) {
        this.emitter = emitter;
        this.event = event;
        this.listener = listener;
      }
      Listener.prototype.off = function() {
        this.emitter.off(this.event, this.listener);
        return this;
      };
      function setupListener(event, listener, options) {
        if (options === true) {
          promisify = true;
        } else if (options === false) {
          async = true;
        } else {
          if (!options || typeof options !== "object") {
            throw TypeError("options should be an object or true");
          }
          var async = options.async;
          var promisify = options.promisify;
          var nextTick = options.nextTick;
          var objectify = options.objectify;
        }
        if (async || nextTick || promisify) {
          var _listener = listener;
          var _origin = listener._origin || listener;
          if (nextTick && !nextTickSupported) {
            throw Error("process.nextTick is not supported");
          }
          if (promisify === undefined2) {
            promisify = listener.constructor.name === "AsyncFunction";
          }
          listener = function() {
            var args = arguments;
            var context = this;
            var event2 = this.event;
            return promisify ? nextTick ? Promise.resolve() : new Promise(function(resolve) {
              _setImmediate(resolve);
            }).then(function() {
              context.event = event2;
              return _listener.apply(context, args);
            }) : (nextTick ? process.nextTick : _setImmediate)(function() {
              context.event = event2;
              _listener.apply(context, args);
            });
          };
          listener._async = true;
          listener._origin = _origin;
        }
        return [listener, objectify ? new Listener(this, event, listener) : this];
      }
      function EventEmitter(conf) {
        this._events = {};
        this._newListener = false;
        this._removeListener = false;
        this.verboseMemoryLeak = false;
        configure.call(this, conf);
      }
      EventEmitter.EventEmitter2 = EventEmitter;
      EventEmitter.prototype.listenTo = function(target, events, options) {
        if (typeof target !== "object") {
          throw TypeError("target musts be an object");
        }
        var emitter = this;
        options = resolveOptions(options, {
          on: undefined2,
          off: undefined2,
          reducers: undefined2
        }, {
          on: functionReducer,
          off: functionReducer,
          reducers: objectFunctionReducer
        });
        function listen(events2) {
          if (typeof events2 !== "object") {
            throw TypeError("events must be an object");
          }
          var reducers = options.reducers;
          var index = findTargetIndex.call(emitter, target);
          var observer;
          if (index === -1) {
            observer = new TargetObserver(emitter, target, options);
          } else {
            observer = emitter._observers[index];
          }
          var keys = ownKeys(events2);
          var len = keys.length;
          var event;
          var isSingleReducer = typeof reducers === "function";
          for (var i = 0; i < len; i++) {
            event = keys[i];
            observer.subscribe(event, events2[event] || event, isSingleReducer ? reducers : reducers && reducers[event]);
          }
        }
        isArray(events) ? listen(toObject(events)) : typeof events === "string" ? listen(toObject(events.split(/\s+/))) : listen(events);
        return this;
      };
      EventEmitter.prototype.stopListeningTo = function(target, event) {
        var observers = this._observers;
        if (!observers) {
          return false;
        }
        var i = observers.length;
        var observer;
        var matched = false;
        if (target && typeof target !== "object") {
          throw TypeError("target should be an object");
        }
        while (i-- > 0) {
          observer = observers[i];
          if (!target || observer._target === target) {
            observer.unsubscribe(event);
            matched = true;
          }
        }
        return matched;
      };
      EventEmitter.prototype.delimiter = ".";
      EventEmitter.prototype.setMaxListeners = function(n) {
        if (n !== undefined2) {
          this._maxListeners = n;
          if (!this._conf)
            this._conf = {};
          this._conf.maxListeners = n;
        }
      };
      EventEmitter.prototype.getMaxListeners = function() {
        return this._maxListeners;
      };
      EventEmitter.prototype.event = "";
      EventEmitter.prototype.once = function(event, fn, options) {
        return this._once(event, fn, false, options);
      };
      EventEmitter.prototype.prependOnceListener = function(event, fn, options) {
        return this._once(event, fn, true, options);
      };
      EventEmitter.prototype._once = function(event, fn, prepend, options) {
        return this._many(event, 1, fn, prepend, options);
      };
      EventEmitter.prototype.many = function(event, ttl, fn, options) {
        return this._many(event, ttl, fn, false, options);
      };
      EventEmitter.prototype.prependMany = function(event, ttl, fn, options) {
        return this._many(event, ttl, fn, true, options);
      };
      EventEmitter.prototype._many = function(event, ttl, fn, prepend, options) {
        var self2 = this;
        if (typeof fn !== "function") {
          throw new Error("many only accepts instances of Function");
        }
        function listener() {
          if (--ttl === 0) {
            self2.off(event, listener);
          }
          return fn.apply(this, arguments);
        }
        listener._origin = fn;
        return this._on(event, listener, prepend, options);
      };
      EventEmitter.prototype.emit = function() {
        if (!this._events && !this._all) {
          return false;
        }
        this._events || init.call(this);
        var type = arguments[0], ns, wildcard = this.wildcard;
        var args, l, i, j, containsSymbol;
        if (type === "newListener" && !this._newListener) {
          if (!this._events.newListener) {
            return false;
          }
        }
        if (wildcard) {
          ns = type;
          if (type !== "newListener" && type !== "removeListener") {
            if (typeof type === "object") {
              l = type.length;
              if (symbolsSupported) {
                for (i = 0; i < l; i++) {
                  if (typeof type[i] === "symbol") {
                    containsSymbol = true;
                    break;
                  }
                }
              }
              if (!containsSymbol) {
                type = type.join(this.delimiter);
              }
            }
          }
        }
        var al = arguments.length;
        var handler;
        if (this._all && this._all.length) {
          handler = this._all.slice();
          for (i = 0, l = handler.length; i < l; i++) {
            this.event = type;
            switch (al) {
              case 1:
                handler[i].call(this, type);
                break;
              case 2:
                handler[i].call(this, type, arguments[1]);
                break;
              case 3:
                handler[i].call(this, type, arguments[1], arguments[2]);
                break;
              default:
                handler[i].apply(this, arguments);
            }
          }
        }
        if (wildcard) {
          handler = [];
          searchListenerTree.call(this, handler, ns, this.listenerTree, 0, l);
        } else {
          handler = this._events[type];
          if (typeof handler === "function") {
            this.event = type;
            switch (al) {
              case 1:
                handler.call(this);
                break;
              case 2:
                handler.call(this, arguments[1]);
                break;
              case 3:
                handler.call(this, arguments[1], arguments[2]);
                break;
              default:
                args = new Array(al - 1);
                for (j = 1; j < al; j++)
                  args[j - 1] = arguments[j];
                handler.apply(this, args);
            }
            return true;
          } else if (handler) {
            handler = handler.slice();
          }
        }
        if (handler && handler.length) {
          if (al > 3) {
            args = new Array(al - 1);
            for (j = 1; j < al; j++)
              args[j - 1] = arguments[j];
          }
          for (i = 0, l = handler.length; i < l; i++) {
            this.event = type;
            switch (al) {
              case 1:
                handler[i].call(this);
                break;
              case 2:
                handler[i].call(this, arguments[1]);
                break;
              case 3:
                handler[i].call(this, arguments[1], arguments[2]);
                break;
              default:
                handler[i].apply(this, args);
            }
          }
          return true;
        } else if (!this.ignoreErrors && !this._all && type === "error") {
          if (arguments[1] instanceof Error) {
            throw arguments[1];
          } else {
            throw new Error("Uncaught, unspecified 'error' event.");
          }
        }
        return !!this._all;
      };
      EventEmitter.prototype.emitAsync = function() {
        if (!this._events && !this._all) {
          return false;
        }
        this._events || init.call(this);
        var type = arguments[0], wildcard = this.wildcard, ns, containsSymbol;
        var args, l, i, j;
        if (type === "newListener" && !this._newListener) {
          if (!this._events.newListener) {
            return Promise.resolve([false]);
          }
        }
        if (wildcard) {
          ns = type;
          if (type !== "newListener" && type !== "removeListener") {
            if (typeof type === "object") {
              l = type.length;
              if (symbolsSupported) {
                for (i = 0; i < l; i++) {
                  if (typeof type[i] === "symbol") {
                    containsSymbol = true;
                    break;
                  }
                }
              }
              if (!containsSymbol) {
                type = type.join(this.delimiter);
              }
            }
          }
        }
        var promises = [];
        var al = arguments.length;
        var handler;
        if (this._all) {
          for (i = 0, l = this._all.length; i < l; i++) {
            this.event = type;
            switch (al) {
              case 1:
                promises.push(this._all[i].call(this, type));
                break;
              case 2:
                promises.push(this._all[i].call(this, type, arguments[1]));
                break;
              case 3:
                promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));
                break;
              default:
                promises.push(this._all[i].apply(this, arguments));
            }
          }
        }
        if (wildcard) {
          handler = [];
          searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
        } else {
          handler = this._events[type];
        }
        if (typeof handler === "function") {
          this.event = type;
          switch (al) {
            case 1:
              promises.push(handler.call(this));
              break;
            case 2:
              promises.push(handler.call(this, arguments[1]));
              break;
            case 3:
              promises.push(handler.call(this, arguments[1], arguments[2]));
              break;
            default:
              args = new Array(al - 1);
              for (j = 1; j < al; j++)
                args[j - 1] = arguments[j];
              promises.push(handler.apply(this, args));
          }
        } else if (handler && handler.length) {
          handler = handler.slice();
          if (al > 3) {
            args = new Array(al - 1);
            for (j = 1; j < al; j++)
              args[j - 1] = arguments[j];
          }
          for (i = 0, l = handler.length; i < l; i++) {
            this.event = type;
            switch (al) {
              case 1:
                promises.push(handler[i].call(this));
                break;
              case 2:
                promises.push(handler[i].call(this, arguments[1]));
                break;
              case 3:
                promises.push(handler[i].call(this, arguments[1], arguments[2]));
                break;
              default:
                promises.push(handler[i].apply(this, args));
            }
          }
        } else if (!this.ignoreErrors && !this._all && type === "error") {
          if (arguments[1] instanceof Error) {
            return Promise.reject(arguments[1]);
          } else {
            return Promise.reject("Uncaught, unspecified 'error' event.");
          }
        }
        return Promise.all(promises);
      };
      EventEmitter.prototype.on = function(type, listener, options) {
        return this._on(type, listener, false, options);
      };
      EventEmitter.prototype.prependListener = function(type, listener, options) {
        return this._on(type, listener, true, options);
      };
      EventEmitter.prototype.onAny = function(fn) {
        return this._onAny(fn, false);
      };
      EventEmitter.prototype.prependAny = function(fn) {
        return this._onAny(fn, true);
      };
      EventEmitter.prototype.addListener = EventEmitter.prototype.on;
      EventEmitter.prototype._onAny = function(fn, prepend) {
        if (typeof fn !== "function") {
          throw new Error("onAny only accepts instances of Function");
        }
        if (!this._all) {
          this._all = [];
        }
        if (prepend) {
          this._all.unshift(fn);
        } else {
          this._all.push(fn);
        }
        return this;
      };
      EventEmitter.prototype._on = function(type, listener, prepend, options) {
        if (typeof type === "function") {
          this._onAny(type, listener);
          return this;
        }
        if (typeof listener !== "function") {
          throw new Error("on only accepts instances of Function");
        }
        this._events || init.call(this);
        var returnValue = this, temp;
        if (options !== undefined2) {
          temp = setupListener.call(this, type, listener, options);
          listener = temp[0];
          returnValue = temp[1];
        }
        if (this._newListener) {
          this.emit("newListener", type, listener);
        }
        if (this.wildcard) {
          growListenerTree.call(this, type, listener, prepend);
          return returnValue;
        }
        if (!this._events[type]) {
          this._events[type] = listener;
        } else {
          if (typeof this._events[type] === "function") {
            this._events[type] = [this._events[type]];
          }
          if (prepend) {
            this._events[type].unshift(listener);
          } else {
            this._events[type].push(listener);
          }
          if (!this._events[type].warned && this._maxListeners > 0 && this._events[type].length > this._maxListeners) {
            this._events[type].warned = true;
            logPossibleMemoryLeak.call(this, this._events[type].length, type);
          }
        }
        return returnValue;
      };
      EventEmitter.prototype.off = function(type, listener) {
        if (typeof listener !== "function") {
          throw new Error("removeListener only takes instances of Function");
        }
        var handlers, leafs = [];
        if (this.wildcard) {
          var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
          leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
          if (!leafs)
            return this;
        } else {
          if (!this._events[type])
            return this;
          handlers = this._events[type];
          leafs.push({ _listeners: handlers });
        }
        for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
          var leaf = leafs[iLeaf];
          handlers = leaf._listeners;
          if (isArray(handlers)) {
            var position = -1;
            for (var i = 0, length = handlers.length; i < length; i++) {
              if (handlers[i] === listener || handlers[i].listener && handlers[i].listener === listener || handlers[i]._origin && handlers[i]._origin === listener) {
                position = i;
                break;
              }
            }
            if (position < 0) {
              continue;
            }
            if (this.wildcard) {
              leaf._listeners.splice(position, 1);
            } else {
              this._events[type].splice(position, 1);
            }
            if (handlers.length === 0) {
              if (this.wildcard) {
                delete leaf._listeners;
              } else {
                delete this._events[type];
              }
            }
            if (this._removeListener)
              this.emit("removeListener", type, listener);
            return this;
          } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {
            if (this.wildcard) {
              delete leaf._listeners;
            } else {
              delete this._events[type];
            }
            if (this._removeListener)
              this.emit("removeListener", type, listener);
          }
        }
        this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
        return this;
      };
      EventEmitter.prototype.offAny = function(fn) {
        var i = 0, l = 0, fns;
        if (fn && this._all && this._all.length > 0) {
          fns = this._all;
          for (i = 0, l = fns.length; i < l; i++) {
            if (fn === fns[i]) {
              fns.splice(i, 1);
              if (this._removeListener)
                this.emit("removeListenerAny", fn);
              return this;
            }
          }
        } else {
          fns = this._all;
          if (this._removeListener) {
            for (i = 0, l = fns.length; i < l; i++)
              this.emit("removeListenerAny", fns[i]);
          }
          this._all = [];
        }
        return this;
      };
      EventEmitter.prototype.removeListener = EventEmitter.prototype.off;
      EventEmitter.prototype.removeAllListeners = function(type) {
        if (type === undefined2) {
          !this._events || init.call(this);
          return this;
        }
        if (this.wildcard) {
          var leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0), leaf, i;
          if (!leafs)
            return this;
          for (i = 0; i < leafs.length; i++) {
            leaf = leafs[i];
            leaf._listeners = null;
          }
          this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
        } else if (this._events) {
          this._events[type] = null;
        }
        return this;
      };
      EventEmitter.prototype.listeners = function(type) {
        var _events = this._events;
        var keys, listeners, allListeners;
        var i;
        var listenerTree;
        if (type === undefined2) {
          if (this.wildcard) {
            throw Error("event name required for wildcard emitter");
          }
          if (!_events) {
            return [];
          }
          keys = ownKeys(_events);
          i = keys.length;
          allListeners = [];
          while (i-- > 0) {
            listeners = _events[keys[i]];
            if (typeof listeners === "function") {
              allListeners.push(listeners);
            } else {
              allListeners.push.apply(allListeners, listeners);
            }
          }
          return allListeners;
        } else {
          if (this.wildcard) {
            listenerTree = this.listenerTree;
            if (!listenerTree)
              return [];
            var handlers = [];
            var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
            searchListenerTree.call(this, handlers, ns, listenerTree, 0);
            return handlers;
          }
          if (!_events) {
            return [];
          }
          listeners = _events[type];
          if (!listeners) {
            return [];
          }
          return typeof listeners === "function" ? [listeners] : listeners;
        }
      };
      EventEmitter.prototype.eventNames = function(nsAsArray) {
        var _events = this._events;
        return this.wildcard ? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : _events ? ownKeys(_events) : [];
      };
      EventEmitter.prototype.listenerCount = function(type) {
        return this.listeners(type).length;
      };
      EventEmitter.prototype.hasListeners = function(type) {
        if (this.wildcard) {
          var handlers = [];
          var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
          searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
          return handlers.length > 0;
        }
        var _events = this._events;
        var _all = this._all;
        return !!(_all && _all.length || _events && (type === undefined2 ? ownKeys(_events).length : _events[type]));
      };
      EventEmitter.prototype.listenersAny = function() {
        if (this._all) {
          return this._all;
        } else {
          return [];
        }
      };
      EventEmitter.prototype.waitFor = function(event, options) {
        var self2 = this;
        var type = typeof options;
        if (type === "number") {
          options = { timeout: options };
        } else if (type === "function") {
          options = { filter: options };
        }
        options = resolveOptions(options, {
          timeout: 0,
          filter: undefined2,
          handleError: false,
          Promise,
          overload: false
        }, {
          filter: functionReducer,
          Promise: constructorReducer
        });
        return makeCancelablePromise(options.Promise, function(resolve, reject, onCancel) {
          function listener() {
            var filter = options.filter;
            if (filter && !filter.apply(self2, arguments)) {
              return;
            }
            self2.off(event, listener);
            if (options.handleError) {
              var err = arguments[0];
              err ? reject(err) : resolve(toArray.apply(null, arguments).slice(1));
            } else {
              resolve(toArray.apply(null, arguments));
            }
          }
          onCancel(function() {
            self2.off(event, listener);
          });
          self2._on(event, listener, false);
        }, {
          timeout: options.timeout,
          overload: options.overload
        });
      };
      function once(emitter, name, options) {
        options = resolveOptions(options, {
          Promise,
          timeout: 0,
          overload: false
        }, {
          Promise: constructorReducer
        });
        var _Promise = options.Promise;
        return makeCancelablePromise(_Promise, function(resolve, reject, onCancel) {
          var handler;
          if (typeof emitter.addEventListener === "function") {
            handler = function() {
              resolve(toArray.apply(null, arguments));
            };
            onCancel(function() {
              emitter.removeEventListener(name, handler);
            });
            emitter.addEventListener(name, handler, { once: true });
            return;
          }
          var eventListener = function() {
            errorListener && emitter.removeListener("error", errorListener);
            resolve(toArray.apply(null, arguments));
          };
          var errorListener;
          if (name !== "error") {
            errorListener = function(err) {
              emitter.removeListener(name, eventListener);
              reject(err);
            };
            emitter.once("error", errorListener);
          }
          onCancel(function() {
            errorListener && emitter.removeListener("error", errorListener);
            emitter.removeListener(name, eventListener);
          });
          emitter.once(name, eventListener);
        }, {
          timeout: options.timeout,
          overload: options.overload
        });
      }
      var prototype = EventEmitter.prototype;
      Object.defineProperties(EventEmitter, {
        defaultMaxListeners: {
          get: function() {
            return prototype._maxListeners;
          },
          set: function(n) {
            if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
              throw TypeError("n must be a non-negative number");
            }
            prototype._maxListeners = n;
          },
          enumerable: true
        },
        once: {
          value: once,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperties(prototype, {
        _maxListeners: {
          value: defaultMaxListeners,
          writable: true,
          configurable: true
        },
        _observers: { value: null, writable: true, configurable: true }
      });
      if (typeof define === "function" && define.amd) {
        define(function() {
          return EventEmitter;
        });
      } else if (typeof exports === "object") {
        module2.exports = EventEmitter;
      } else {
        var _global = new Function("", "return this")();
        _global.EventEmitter2 = EventEmitter;
      }
    }();
  }
});

// node_modules/forever-monitor/lib/forever-monitor/plugins/logger.js
var require_logger = __commonJS({
  "node_modules/forever-monitor/lib/forever-monitor/plugins/logger.js"(exports) {
    var fs = require("fs");
    exports.name = "logger";
    exports.attach = function(options) {
      options = options || {};
      const monitor = this;
      if (options.outFile) {
        monitor.stdout = options.stdout || fs.createWriteStream(options.outFile, {
          flags: monitor.append ? "a+" : "w+",
          encoding: "utf8",
          mode: 420
        });
      }
      if (options.errFile) {
        monitor.stderr = options.stderr || fs.createWriteStream(options.errFile, {
          flags: monitor.append ? "a+" : "w+",
          encoding: "utf8",
          mode: 420
        });
      }
      monitor.on("start", startLogs);
      monitor.on("restart", startLogs);
      monitor.on("exit", stopLogs);
      function stopLogs() {
        if (monitor.stdout) {
          monitor.child.stdout.unpipe && monitor.child.stdout.unpipe(monitor.stdout);
          monitor.stdout.destroy();
          monitor.stdout = null;
        }
        if (monitor.stderr) {
          monitor.child.stderr.unpipe && monitor.child.stderr.unpipe(monitor.stderr);
          monitor.stderr.destroy();
          monitor.stderr = null;
        }
      }
      function startLogs(_child, _childData) {
        if (monitor.child) {
          monitor.child.stdout.on("data", function onStdout(data) {
            monitor.emit("stdout", data);
          });
          monitor.child.stderr.on("data", function onStderr(data) {
            monitor.emit("stderr", data);
          });
          if (!monitor.silent) {
            process.stdout.setMaxListeners(0);
            process.stderr.setMaxListeners(0);
            monitor.child.stdout.pipe(process.stdout, { end: false });
            monitor.child.stderr.pipe(process.stderr, { end: false });
          }
          if (monitor.stdout) {
            monitor.child.stdout.pipe(monitor.stdout, { end: false });
          }
          if (monitor.stderr) {
            monitor.child.stderr.pipe(monitor.stderr, { end: false });
          }
        }
      }
    };
  }
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "node_modules/concat-map/index.js"(exports, module2) {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports, module2) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/minimatch/minimatch.js"(exports, module2) {
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path = function() {
      try {
        return require("path");
      } catch (e) {
      }
    }() || {
      sep: "/"
    };
    minimatch.sep = path.sep;
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      b = b || {};
      var t = {};
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      m.Minimatch.defaults = function defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      };
      m.filter = function filter2(pattern, options) {
        return orig.filter(pattern, ext(def, options));
      };
      m.defaults = function defaults(options) {
        return orig.defaults(ext(def, options));
      };
      m.makeRe = function makeRe2(pattern, options) {
        return orig.makeRe(pattern, ext(def, options));
      };
      m.braceExpand = function braceExpand2(pattern, options) {
        return orig.braceExpand(pattern, ext(def, options));
      };
      m.match = function(list, pattern, options) {
        return orig.match(list, pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      assertValidPattern(pattern);
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      assertValidPattern(pattern);
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (!options.allowWindowsEscape && path.sep !== "/") {
        pattern = pattern.split(path.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = function debug() {
          console.error.apply(console, arguments);
        };
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    }
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = function(pattern) {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    Minimatch.prototype.parse = parse;
    var SUBPARSE = {};
    function parse(pattern, isSub) {
      assertValidPattern(pattern);
      var options = this.options;
      if (pattern === "**") {
        if (!options.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/": {
            return false;
          }
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case "[":
        case ".":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = function match(f, partial) {
      if (typeof partial === "undefined")
        partial = this.partial;
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path.sep !== "/") {
        f = f.split(path.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    };
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug("matchOne", { "this": this, file, pattern });
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// node_modules/async-each/index.js
var require_async_each = __commonJS({
  "node_modules/async-each/index.js"(exports, module2) {
    (function(globals) {
      "use strict";
      var each = function(items, next, callback) {
        if (!Array.isArray(items))
          throw new TypeError("each() expects array as first argument");
        if (typeof next !== "function")
          throw new TypeError("each() expects function as second argument");
        if (typeof callback !== "function")
          callback = Function.prototype;
        if (items.length === 0)
          return callback(void 0, items);
        var transformed = new Array(items.length);
        var count = 0;
        var returned = false;
        items.forEach(function(item, index) {
          next(item, function(error, transformedItem) {
            if (returned)
              return;
            if (error) {
              returned = true;
              return callback(error);
            }
            transformed[index] = transformedItem;
            count += 1;
            if (count === items.length)
              return callback(void 0, transformed);
          });
        });
      };
      if (typeof define !== "undefined" && define.amd) {
        define([], function() {
          return each;
        });
      } else if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = each;
      } else {
        globals.asyncEach = each;
      }
    })(exports);
  }
});

// node_modules/ret/lib/types.js
var require_types = __commonJS({
  "node_modules/ret/lib/types.js"(exports, module2) {
    module2.exports = {
      ROOT: 0,
      GROUP: 1,
      POSITION: 2,
      SET: 3,
      RANGE: 4,
      REPETITION: 5,
      REFERENCE: 6,
      CHAR: 7
    };
  }
});

// node_modules/ret/lib/sets.js
var require_sets = __commonJS({
  "node_modules/ret/lib/sets.js"(exports) {
    var types = require_types();
    var INTS = function() {
      return [{ type: types.RANGE, from: 48, to: 57 }];
    };
    var WORDS = function() {
      return [
        { type: types.CHAR, value: 95 },
        { type: types.RANGE, from: 97, to: 122 },
        { type: types.RANGE, from: 65, to: 90 }
      ].concat(INTS());
    };
    var WHITESPACE = function() {
      return [
        { type: types.CHAR, value: 9 },
        { type: types.CHAR, value: 10 },
        { type: types.CHAR, value: 11 },
        { type: types.CHAR, value: 12 },
        { type: types.CHAR, value: 13 },
        { type: types.CHAR, value: 32 },
        { type: types.CHAR, value: 160 },
        { type: types.CHAR, value: 5760 },
        { type: types.CHAR, value: 6158 },
        { type: types.CHAR, value: 8192 },
        { type: types.CHAR, value: 8193 },
        { type: types.CHAR, value: 8194 },
        { type: types.CHAR, value: 8195 },
        { type: types.CHAR, value: 8196 },
        { type: types.CHAR, value: 8197 },
        { type: types.CHAR, value: 8198 },
        { type: types.CHAR, value: 8199 },
        { type: types.CHAR, value: 8200 },
        { type: types.CHAR, value: 8201 },
        { type: types.CHAR, value: 8202 },
        { type: types.CHAR, value: 8232 },
        { type: types.CHAR, value: 8233 },
        { type: types.CHAR, value: 8239 },
        { type: types.CHAR, value: 8287 },
        { type: types.CHAR, value: 12288 },
        { type: types.CHAR, value: 65279 }
      ];
    };
    var NOTANYCHAR = function() {
      return [
        { type: types.CHAR, value: 10 },
        { type: types.CHAR, value: 13 },
        { type: types.CHAR, value: 8232 },
        { type: types.CHAR, value: 8233 }
      ];
    };
    exports.words = function() {
      return { type: types.SET, set: WORDS(), not: false };
    };
    exports.notWords = function() {
      return { type: types.SET, set: WORDS(), not: true };
    };
    exports.ints = function() {
      return { type: types.SET, set: INTS(), not: false };
    };
    exports.notInts = function() {
      return { type: types.SET, set: INTS(), not: true };
    };
    exports.whitespace = function() {
      return { type: types.SET, set: WHITESPACE(), not: false };
    };
    exports.notWhitespace = function() {
      return { type: types.SET, set: WHITESPACE(), not: true };
    };
    exports.anyChar = function() {
      return { type: types.SET, set: NOTANYCHAR(), not: true };
    };
  }
});

// node_modules/ret/lib/util.js
var require_util = __commonJS({
  "node_modules/ret/lib/util.js"(exports) {
    var types = require_types();
    var sets = require_sets();
    var CTRL = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?";
    var SLSH = { "0": 0, "t": 9, "n": 10, "v": 11, "f": 12, "r": 13 };
    exports.strToChars = function(str) {
      var chars_regex = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z\[\\\]\^?])|([0tnvfr]))/g;
      str = str.replace(chars_regex, function(s, b, lbs, a16, b16, c8, dctrl, eslsh) {
        if (lbs) {
          return s;
        }
        var code = b ? 8 : a16 ? parseInt(a16, 16) : b16 ? parseInt(b16, 16) : c8 ? parseInt(c8, 8) : dctrl ? CTRL.indexOf(dctrl) : SLSH[eslsh];
        var c = String.fromCharCode(code);
        if (/[\[\]{}\^$.|?*+()]/.test(c)) {
          c = "\\" + c;
        }
        return c;
      });
      return str;
    };
    exports.tokenizeClass = function(str, regexpStr) {
      var tokens = [];
      var regexp = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(?:\\)?([^\]]))|(\])|(?:\\)?(.)/g;
      var rs, c;
      while ((rs = regexp.exec(str)) != null) {
        if (rs[1]) {
          tokens.push(sets.words());
        } else if (rs[2]) {
          tokens.push(sets.ints());
        } else if (rs[3]) {
          tokens.push(sets.whitespace());
        } else if (rs[4]) {
          tokens.push(sets.notWords());
        } else if (rs[5]) {
          tokens.push(sets.notInts());
        } else if (rs[6]) {
          tokens.push(sets.notWhitespace());
        } else if (rs[7]) {
          tokens.push({
            type: types.RANGE,
            from: (rs[8] || rs[9]).charCodeAt(0),
            to: rs[10].charCodeAt(0)
          });
        } else if (c = rs[12]) {
          tokens.push({
            type: types.CHAR,
            value: c.charCodeAt(0)
          });
        } else {
          return [tokens, regexp.lastIndex];
        }
      }
      exports.error(regexpStr, "Unterminated character class");
    };
    exports.error = function(regexp, msg) {
      throw new SyntaxError("Invalid regular expression: /" + regexp + "/: " + msg);
    };
  }
});

// node_modules/ret/lib/positions.js
var require_positions = __commonJS({
  "node_modules/ret/lib/positions.js"(exports) {
    var types = require_types();
    exports.wordBoundary = function() {
      return { type: types.POSITION, value: "b" };
    };
    exports.nonWordBoundary = function() {
      return { type: types.POSITION, value: "B" };
    };
    exports.begin = function() {
      return { type: types.POSITION, value: "^" };
    };
    exports.end = function() {
      return { type: types.POSITION, value: "$" };
    };
  }
});

// node_modules/ret/lib/index.js
var require_lib = __commonJS({
  "node_modules/ret/lib/index.js"(exports, module2) {
    var util = require_util();
    var types = require_types();
    var sets = require_sets();
    var positions = require_positions();
    module2.exports = function(regexpStr) {
      var i = 0, l, c, start = { type: types.ROOT, stack: [] }, lastGroup = start, last = start.stack, groupStack = [];
      var repeatErr = function(i2) {
        util.error(regexpStr, "Nothing to repeat at column " + (i2 - 1));
      };
      var str = util.strToChars(regexpStr);
      l = str.length;
      while (i < l) {
        c = str[i++];
        switch (c) {
          case "\\":
            c = str[i++];
            switch (c) {
              case "b":
                last.push(positions.wordBoundary());
                break;
              case "B":
                last.push(positions.nonWordBoundary());
                break;
              case "w":
                last.push(sets.words());
                break;
              case "W":
                last.push(sets.notWords());
                break;
              case "d":
                last.push(sets.ints());
                break;
              case "D":
                last.push(sets.notInts());
                break;
              case "s":
                last.push(sets.whitespace());
                break;
              case "S":
                last.push(sets.notWhitespace());
                break;
              default:
                if (/\d/.test(c)) {
                  last.push({ type: types.REFERENCE, value: parseInt(c, 10) });
                } else {
                  last.push({ type: types.CHAR, value: c.charCodeAt(0) });
                }
            }
            break;
          case "^":
            last.push(positions.begin());
            break;
          case "$":
            last.push(positions.end());
            break;
          case "[":
            var not;
            if (str[i] === "^") {
              not = true;
              i++;
            } else {
              not = false;
            }
            var classTokens = util.tokenizeClass(str.slice(i), regexpStr);
            i += classTokens[1];
            last.push({
              type: types.SET,
              set: classTokens[0],
              not
            });
            break;
          case ".":
            last.push(sets.anyChar());
            break;
          case "(":
            var group = {
              type: types.GROUP,
              stack: [],
              remember: true
            };
            c = str[i];
            if (c === "?") {
              c = str[i + 1];
              i += 2;
              if (c === "=") {
                group.followedBy = true;
              } else if (c === "!") {
                group.notFollowedBy = true;
              } else if (c !== ":") {
                util.error(regexpStr, "Invalid group, character '" + c + "' after '?' at column " + (i - 1));
              }
              group.remember = false;
            }
            last.push(group);
            groupStack.push(lastGroup);
            lastGroup = group;
            last = group.stack;
            break;
          case ")":
            if (groupStack.length === 0) {
              util.error(regexpStr, "Unmatched ) at column " + (i - 1));
            }
            lastGroup = groupStack.pop();
            last = lastGroup.options ? lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;
            break;
          case "|":
            if (!lastGroup.options) {
              lastGroup.options = [lastGroup.stack];
              delete lastGroup.stack;
            }
            var stack = [];
            lastGroup.options.push(stack);
            last = stack;
            break;
          case "{":
            var rs = /^(\d+)(,(\d+)?)?\}/.exec(str.slice(i)), min, max;
            if (rs !== null) {
              if (last.length === 0) {
                repeatErr(i);
              }
              min = parseInt(rs[1], 10);
              max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;
              i += rs[0].length;
              last.push({
                type: types.REPETITION,
                min,
                max,
                value: last.pop()
              });
            } else {
              last.push({
                type: types.CHAR,
                value: 123
              });
            }
            break;
          case "?":
            if (last.length === 0) {
              repeatErr(i);
            }
            last.push({
              type: types.REPETITION,
              min: 0,
              max: 1,
              value: last.pop()
            });
            break;
          case "+":
            if (last.length === 0) {
              repeatErr(i);
            }
            last.push({
              type: types.REPETITION,
              min: 1,
              max: Infinity,
              value: last.pop()
            });
            break;
          case "*":
            if (last.length === 0) {
              repeatErr(i);
            }
            last.push({
              type: types.REPETITION,
              min: 0,
              max: Infinity,
              value: last.pop()
            });
            break;
          default:
            last.push({
              type: types.CHAR,
              value: c.charCodeAt(0)
            });
        }
      }
      if (groupStack.length !== 0) {
        util.error(regexpStr, "Unterminated group");
      }
      return start;
    };
    module2.exports.types = types;
  }
});

// node_modules/safe-regex/index.js
var require_safe_regex = __commonJS({
  "node_modules/safe-regex/index.js"(exports, module2) {
    var parse = require_lib();
    var types = parse.types;
    module2.exports = function(re, opts) {
      if (!opts)
        opts = {};
      var replimit = opts.limit === void 0 ? 25 : opts.limit;
      if (isRegExp(re))
        re = re.source;
      else if (typeof re !== "string")
        re = String(re);
      try {
        re = parse(re);
      } catch (err) {
        return false;
      }
      var reps = 0;
      return function walk(node, starHeight) {
        if (node.type === types.REPETITION) {
          starHeight++;
          reps++;
          if (starHeight > 1)
            return false;
          if (reps > replimit)
            return false;
        }
        if (node.options) {
          for (var i = 0, len = node.options.length; i < len; i++) {
            var ok = walk({ stack: node.options[i] }, starHeight);
            if (!ok)
              return false;
          }
        }
        var stack = node.stack || node.value && node.value.stack;
        if (!stack)
          return true;
        for (var i = 0; i < stack.length; i++) {
          var ok = walk(stack[i], starHeight);
          if (!ok)
            return false;
        }
        return true;
      }(re, 0);
    };
    function isRegExp(x) {
      return {}.toString.call(x) === "[object RegExp]";
    }
  }
});

// node_modules/isobject/index.js
var require_isobject = __commonJS({
  "node_modules/isobject/index.js"(exports, module2) {
    "use strict";
    module2.exports = function isObject(val) {
      return val != null && typeof val === "object" && Array.isArray(val) === false;
    };
  }
});

// node_modules/is-descriptor/node_modules/kind-of/index.js
var require_kind_of = __commonJS({
  "node_modules/is-descriptor/node_modules/kind-of/index.js"(exports, module2) {
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      if (val === void 0)
        return "undefined";
      if (val === null)
        return "null";
      var type = typeof val;
      if (type === "boolean")
        return "boolean";
      if (type === "string")
        return "string";
      if (type === "number")
        return "number";
      if (type === "symbol")
        return "symbol";
      if (type === "function") {
        return isGeneratorFn(val) ? "generatorfunction" : "function";
      }
      if (isArray(val))
        return "array";
      if (isBuffer(val))
        return "buffer";
      if (isArguments(val))
        return "arguments";
      if (isDate(val))
        return "date";
      if (isError(val))
        return "error";
      if (isRegexp(val))
        return "regexp";
      switch (ctorName(val)) {
        case "Symbol":
          return "symbol";
        case "Promise":
          return "promise";
        case "WeakMap":
          return "weakmap";
        case "WeakSet":
          return "weakset";
        case "Map":
          return "map";
        case "Set":
          return "set";
        case "Int8Array":
          return "int8array";
        case "Uint8Array":
          return "uint8array";
        case "Uint8ClampedArray":
          return "uint8clampedarray";
        case "Int16Array":
          return "int16array";
        case "Uint16Array":
          return "uint16array";
        case "Int32Array":
          return "int32array";
        case "Uint32Array":
          return "uint32array";
        case "Float32Array":
          return "float32array";
        case "Float64Array":
          return "float64array";
      }
      if (isGeneratorObj(val)) {
        return "generator";
      }
      type = toString.call(val);
      switch (type) {
        case "[object Object]":
          return "object";
        case "[object Map Iterator]":
          return "mapiterator";
        case "[object Set Iterator]":
          return "setiterator";
        case "[object String Iterator]":
          return "stringiterator";
        case "[object Array Iterator]":
          return "arrayiterator";
      }
      return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
    };
    function ctorName(val) {
      return typeof val.constructor === "function" ? val.constructor.name : null;
    }
    function isArray(val) {
      if (Array.isArray)
        return Array.isArray(val);
      return val instanceof Array;
    }
    function isError(val) {
      return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
    }
    function isDate(val) {
      if (val instanceof Date)
        return true;
      return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
    }
    function isRegexp(val) {
      if (val instanceof RegExp)
        return true;
      return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
    }
    function isGeneratorFn(name, val) {
      return ctorName(name) === "GeneratorFunction";
    }
    function isGeneratorObj(val) {
      return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
    }
    function isArguments(val) {
      try {
        if (typeof val.length === "number" && typeof val.callee === "function") {
          return true;
        }
      } catch (err) {
        if (err.message.indexOf("callee") !== -1) {
          return true;
        }
      }
      return false;
    }
    function isBuffer(val) {
      if (val.constructor && typeof val.constructor.isBuffer === "function") {
        return val.constructor.isBuffer(val);
      }
      return false;
    }
  }
});

// node_modules/is-accessor-descriptor/node_modules/kind-of/index.js
var require_kind_of2 = __commonJS({
  "node_modules/is-accessor-descriptor/node_modules/kind-of/index.js"(exports, module2) {
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      if (val === void 0)
        return "undefined";
      if (val === null)
        return "null";
      var type = typeof val;
      if (type === "boolean")
        return "boolean";
      if (type === "string")
        return "string";
      if (type === "number")
        return "number";
      if (type === "symbol")
        return "symbol";
      if (type === "function") {
        return isGeneratorFn(val) ? "generatorfunction" : "function";
      }
      if (isArray(val))
        return "array";
      if (isBuffer(val))
        return "buffer";
      if (isArguments(val))
        return "arguments";
      if (isDate(val))
        return "date";
      if (isError(val))
        return "error";
      if (isRegexp(val))
        return "regexp";
      switch (ctorName(val)) {
        case "Symbol":
          return "symbol";
        case "Promise":
          return "promise";
        case "WeakMap":
          return "weakmap";
        case "WeakSet":
          return "weakset";
        case "Map":
          return "map";
        case "Set":
          return "set";
        case "Int8Array":
          return "int8array";
        case "Uint8Array":
          return "uint8array";
        case "Uint8ClampedArray":
          return "uint8clampedarray";
        case "Int16Array":
          return "int16array";
        case "Uint16Array":
          return "uint16array";
        case "Int32Array":
          return "int32array";
        case "Uint32Array":
          return "uint32array";
        case "Float32Array":
          return "float32array";
        case "Float64Array":
          return "float64array";
      }
      if (isGeneratorObj(val)) {
        return "generator";
      }
      type = toString.call(val);
      switch (type) {
        case "[object Object]":
          return "object";
        case "[object Map Iterator]":
          return "mapiterator";
        case "[object Set Iterator]":
          return "setiterator";
        case "[object String Iterator]":
          return "stringiterator";
        case "[object Array Iterator]":
          return "arrayiterator";
      }
      return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
    };
    function ctorName(val) {
      return typeof val.constructor === "function" ? val.constructor.name : null;
    }
    function isArray(val) {
      if (Array.isArray)
        return Array.isArray(val);
      return val instanceof Array;
    }
    function isError(val) {
      return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
    }
    function isDate(val) {
      if (val instanceof Date)
        return true;
      return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
    }
    function isRegexp(val) {
      if (val instanceof RegExp)
        return true;
      return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
    }
    function isGeneratorFn(name, val) {
      return ctorName(name) === "GeneratorFunction";
    }
    function isGeneratorObj(val) {
      return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
    }
    function isArguments(val) {
      try {
        if (typeof val.length === "number" && typeof val.callee === "function") {
          return true;
        }
      } catch (err) {
        if (err.message.indexOf("callee") !== -1) {
          return true;
        }
      }
      return false;
    }
    function isBuffer(val) {
      if (val.constructor && typeof val.constructor.isBuffer === "function") {
        return val.constructor.isBuffer(val);
      }
      return false;
    }
  }
});

// node_modules/is-accessor-descriptor/index.js
var require_is_accessor_descriptor = __commonJS({
  "node_modules/is-accessor-descriptor/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of2();
    var accessor = {
      get: "function",
      set: "function",
      configurable: "boolean",
      enumerable: "boolean"
    };
    function isAccessorDescriptor(obj, prop) {
      if (typeof prop === "string") {
        var val = Object.getOwnPropertyDescriptor(obj, prop);
        return typeof val !== "undefined";
      }
      if (typeOf(obj) !== "object") {
        return false;
      }
      if (has(obj, "value") || has(obj, "writable")) {
        return false;
      }
      if (!has(obj, "get") || typeof obj.get !== "function") {
        return false;
      }
      if (has(obj, "set") && typeof obj[key] !== "function" && typeof obj[key] !== "undefined") {
        return false;
      }
      for (var key in obj) {
        if (!accessor.hasOwnProperty(key)) {
          continue;
        }
        if (typeOf(obj[key]) === accessor[key]) {
          continue;
        }
        if (typeof obj[key] !== "undefined") {
          return false;
        }
      }
      return true;
    }
    function has(obj, key) {
      return {}.hasOwnProperty.call(obj, key);
    }
    module2.exports = isAccessorDescriptor;
  }
});

// node_modules/is-data-descriptor/node_modules/kind-of/index.js
var require_kind_of3 = __commonJS({
  "node_modules/is-data-descriptor/node_modules/kind-of/index.js"(exports, module2) {
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      if (val === void 0)
        return "undefined";
      if (val === null)
        return "null";
      var type = typeof val;
      if (type === "boolean")
        return "boolean";
      if (type === "string")
        return "string";
      if (type === "number")
        return "number";
      if (type === "symbol")
        return "symbol";
      if (type === "function") {
        return isGeneratorFn(val) ? "generatorfunction" : "function";
      }
      if (isArray(val))
        return "array";
      if (isBuffer(val))
        return "buffer";
      if (isArguments(val))
        return "arguments";
      if (isDate(val))
        return "date";
      if (isError(val))
        return "error";
      if (isRegexp(val))
        return "regexp";
      switch (ctorName(val)) {
        case "Symbol":
          return "symbol";
        case "Promise":
          return "promise";
        case "WeakMap":
          return "weakmap";
        case "WeakSet":
          return "weakset";
        case "Map":
          return "map";
        case "Set":
          return "set";
        case "Int8Array":
          return "int8array";
        case "Uint8Array":
          return "uint8array";
        case "Uint8ClampedArray":
          return "uint8clampedarray";
        case "Int16Array":
          return "int16array";
        case "Uint16Array":
          return "uint16array";
        case "Int32Array":
          return "int32array";
        case "Uint32Array":
          return "uint32array";
        case "Float32Array":
          return "float32array";
        case "Float64Array":
          return "float64array";
      }
      if (isGeneratorObj(val)) {
        return "generator";
      }
      type = toString.call(val);
      switch (type) {
        case "[object Object]":
          return "object";
        case "[object Map Iterator]":
          return "mapiterator";
        case "[object Set Iterator]":
          return "setiterator";
        case "[object String Iterator]":
          return "stringiterator";
        case "[object Array Iterator]":
          return "arrayiterator";
      }
      return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
    };
    function ctorName(val) {
      return typeof val.constructor === "function" ? val.constructor.name : null;
    }
    function isArray(val) {
      if (Array.isArray)
        return Array.isArray(val);
      return val instanceof Array;
    }
    function isError(val) {
      return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
    }
    function isDate(val) {
      if (val instanceof Date)
        return true;
      return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
    }
    function isRegexp(val) {
      if (val instanceof RegExp)
        return true;
      return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
    }
    function isGeneratorFn(name, val) {
      return ctorName(name) === "GeneratorFunction";
    }
    function isGeneratorObj(val) {
      return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
    }
    function isArguments(val) {
      try {
        if (typeof val.length === "number" && typeof val.callee === "function") {
          return true;
        }
      } catch (err) {
        if (err.message.indexOf("callee") !== -1) {
          return true;
        }
      }
      return false;
    }
    function isBuffer(val) {
      if (val.constructor && typeof val.constructor.isBuffer === "function") {
        return val.constructor.isBuffer(val);
      }
      return false;
    }
  }
});

// node_modules/is-data-descriptor/index.js
var require_is_data_descriptor = __commonJS({
  "node_modules/is-data-descriptor/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of3();
    module2.exports = function isDataDescriptor(obj, prop) {
      var data = {
        configurable: "boolean",
        enumerable: "boolean",
        writable: "boolean"
      };
      if (typeOf(obj) !== "object") {
        return false;
      }
      if (typeof prop === "string") {
        var val = Object.getOwnPropertyDescriptor(obj, prop);
        return typeof val !== "undefined";
      }
      if (!("value" in obj) && !("writable" in obj)) {
        return false;
      }
      for (var key in obj) {
        if (key === "value")
          continue;
        if (!data.hasOwnProperty(key)) {
          continue;
        }
        if (typeOf(obj[key]) === data[key]) {
          continue;
        }
        if (typeof obj[key] !== "undefined") {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/is-descriptor/index.js
var require_is_descriptor = __commonJS({
  "node_modules/is-descriptor/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of();
    var isAccessor = require_is_accessor_descriptor();
    var isData = require_is_data_descriptor();
    module2.exports = function isDescriptor(obj, key) {
      if (typeOf(obj) !== "object") {
        return false;
      }
      if ("get" in obj) {
        return isAccessor(obj, key);
      }
      return isData(obj, key);
    };
  }
});

// node_modules/define-property/index.js
var require_define_property = __commonJS({
  "node_modules/define-property/index.js"(exports, module2) {
    "use strict";
    var isobject = require_isobject();
    var isDescriptor = require_is_descriptor();
    var define2 = typeof Reflect !== "undefined" && Reflect.defineProperty ? Reflect.defineProperty : Object.defineProperty;
    module2.exports = function defineProperty(obj, key, val) {
      if (!isobject(obj) && typeof obj !== "function" && !Array.isArray(obj)) {
        throw new TypeError("expected an object, function, or array");
      }
      if (typeof key !== "string") {
        throw new TypeError('expected "key" to be a string');
      }
      if (isDescriptor(val)) {
        define2(obj, key, val);
        return obj;
      }
      define2(obj, key, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val
      });
      return obj;
    };
  }
});

// node_modules/is-plain-object/index.js
var require_is_plain_object = __commonJS({
  "node_modules/is-plain-object/index.js"(exports, module2) {
    "use strict";
    var isObject = require_isobject();
    function isObjectObject(o) {
      return isObject(o) === true && Object.prototype.toString.call(o) === "[object Object]";
    }
    module2.exports = function isPlainObject(o) {
      var ctor, prot;
      if (isObjectObject(o) === false)
        return false;
      ctor = o.constructor;
      if (typeof ctor !== "function")
        return false;
      prot = ctor.prototype;
      if (isObjectObject(prot) === false)
        return false;
      if (prot.hasOwnProperty("isPrototypeOf") === false) {
        return false;
      }
      return true;
    };
  }
});

// node_modules/to-regex/node_modules/is-extendable/index.js
var require_is_extendable = __commonJS({
  "node_modules/to-regex/node_modules/is-extendable/index.js"(exports, module2) {
    "use strict";
    var isPlainObject = require_is_plain_object();
    module2.exports = function isExtendable(val) {
      return isPlainObject(val) || typeof val === "function" || Array.isArray(val);
    };
  }
});

// node_modules/assign-symbols/index.js
var require_assign_symbols = __commonJS({
  "node_modules/assign-symbols/index.js"(exports, module2) {
    "use strict";
    module2.exports = function(receiver, objects) {
      if (receiver === null || typeof receiver === "undefined") {
        throw new TypeError("expected first argument to be an object.");
      }
      if (typeof objects === "undefined" || typeof Symbol === "undefined") {
        return receiver;
      }
      if (typeof Object.getOwnPropertySymbols !== "function") {
        return receiver;
      }
      var isEnumerable = Object.prototype.propertyIsEnumerable;
      var target = Object(receiver);
      var len = arguments.length, i = 0;
      while (++i < len) {
        var provider = Object(arguments[i]);
        var names = Object.getOwnPropertySymbols(provider);
        for (var j = 0; j < names.length; j++) {
          var key = names[j];
          if (isEnumerable.call(provider, key)) {
            target[key] = provider[key];
          }
        }
      }
      return target;
    };
  }
});

// node_modules/to-regex/node_modules/extend-shallow/index.js
var require_extend_shallow = __commonJS({
  "node_modules/to-regex/node_modules/extend-shallow/index.js"(exports, module2) {
    "use strict";
    var isExtendable = require_is_extendable();
    var assignSymbols = require_assign_symbols();
    module2.exports = Object.assign || function(obj) {
      if (obj === null || typeof obj === "undefined") {
        throw new TypeError("Cannot convert undefined or null to object");
      }
      if (!isObject(obj)) {
        obj = {};
      }
      for (var i = 1; i < arguments.length; i++) {
        var val = arguments[i];
        if (isString(val)) {
          val = toObject(val);
        }
        if (isObject(val)) {
          assign(obj, val);
          assignSymbols(obj, val);
        }
      }
      return obj;
    };
    function assign(a, b) {
      for (var key in b) {
        if (hasOwn(b, key)) {
          a[key] = b[key];
        }
      }
    }
    function isString(val) {
      return val && typeof val === "string";
    }
    function toObject(str) {
      var obj = {};
      for (var i in str) {
        obj[i] = str[i];
      }
      return obj;
    }
    function isObject(val) {
      return val && typeof val === "object" || isExtendable(val);
    }
    function hasOwn(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/regex-not/node_modules/is-extendable/index.js
var require_is_extendable2 = __commonJS({
  "node_modules/regex-not/node_modules/is-extendable/index.js"(exports, module2) {
    "use strict";
    var isPlainObject = require_is_plain_object();
    module2.exports = function isExtendable(val) {
      return isPlainObject(val) || typeof val === "function" || Array.isArray(val);
    };
  }
});

// node_modules/regex-not/node_modules/extend-shallow/index.js
var require_extend_shallow2 = __commonJS({
  "node_modules/regex-not/node_modules/extend-shallow/index.js"(exports, module2) {
    "use strict";
    var isExtendable = require_is_extendable2();
    var assignSymbols = require_assign_symbols();
    module2.exports = Object.assign || function(obj) {
      if (obj === null || typeof obj === "undefined") {
        throw new TypeError("Cannot convert undefined or null to object");
      }
      if (!isObject(obj)) {
        obj = {};
      }
      for (var i = 1; i < arguments.length; i++) {
        var val = arguments[i];
        if (isString(val)) {
          val = toObject(val);
        }
        if (isObject(val)) {
          assign(obj, val);
          assignSymbols(obj, val);
        }
      }
      return obj;
    };
    function assign(a, b) {
      for (var key in b) {
        if (hasOwn(b, key)) {
          a[key] = b[key];
        }
      }
    }
    function isString(val) {
      return val && typeof val === "string";
    }
    function toObject(str) {
      var obj = {};
      for (var i in str) {
        obj[i] = str[i];
      }
      return obj;
    }
    function isObject(val) {
      return val && typeof val === "object" || isExtendable(val);
    }
    function hasOwn(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/regex-not/index.js
var require_regex_not = __commonJS({
  "node_modules/regex-not/index.js"(exports, module2) {
    "use strict";
    var extend = require_extend_shallow2();
    var safe = require_safe_regex();
    function toRegex(pattern, options) {
      return new RegExp(toRegex.create(pattern, options));
    }
    toRegex.create = function(pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("expected a string");
      }
      var opts = extend({}, options);
      if (opts.contains === true) {
        opts.strictNegate = false;
      }
      var open = opts.strictOpen !== false ? "^" : "";
      var close = opts.strictClose !== false ? "$" : "";
      var endChar = opts.endChar ? opts.endChar : "+";
      var str = pattern;
      if (opts.strictNegate === false) {
        str = "(?:(?!(?:" + pattern + ")).)" + endChar;
      } else {
        str = "(?:(?!^(?:" + pattern + ")$).)" + endChar;
      }
      var res = open + str + close;
      if (opts.safe === true && safe(res) === false) {
        throw new Error("potentially unsafe regular expression: " + res);
      }
      return res;
    };
    module2.exports = toRegex;
  }
});

// node_modules/to-regex/index.js
var require_to_regex = __commonJS({
  "node_modules/to-regex/index.js"(exports, module2) {
    "use strict";
    var safe = require_safe_regex();
    var define2 = require_define_property();
    var extend = require_extend_shallow();
    var not = require_regex_not();
    var MAX_LENGTH = 1024 * 64;
    var cache = {};
    module2.exports = function(patterns, options) {
      if (!Array.isArray(patterns)) {
        return makeRe(patterns, options);
      }
      return makeRe(patterns.join("|"), options);
    };
    function makeRe(pattern, options) {
      if (pattern instanceof RegExp) {
        return pattern;
      }
      if (typeof pattern !== "string") {
        throw new TypeError("expected a string");
      }
      if (pattern.length > MAX_LENGTH) {
        throw new Error("expected pattern to be less than " + MAX_LENGTH + " characters");
      }
      var key = pattern;
      if (!options || options && options.cache !== false) {
        key = createKey(pattern, options);
        if (cache.hasOwnProperty(key)) {
          return cache[key];
        }
      }
      var opts = extend({}, options);
      if (opts.contains === true) {
        if (opts.negate === true) {
          opts.strictNegate = false;
        } else {
          opts.strict = false;
        }
      }
      if (opts.strict === false) {
        opts.strictOpen = false;
        opts.strictClose = false;
      }
      var open = opts.strictOpen !== false ? "^" : "";
      var close = opts.strictClose !== false ? "$" : "";
      var flags = opts.flags || "";
      var regex;
      if (opts.nocase === true && !/i/.test(flags)) {
        flags += "i";
      }
      try {
        if (opts.negate || typeof opts.strictNegate === "boolean") {
          pattern = not.create(pattern, opts);
        }
        var str = open + "(?:" + pattern + ")" + close;
        regex = new RegExp(str, flags);
        if (opts.safe === true && safe(regex) === false) {
          throw new Error("potentially unsafe regular expression: " + regex.source);
        }
      } catch (err) {
        if (opts.strictErrors === true || opts.safe === true) {
          err.key = key;
          err.pattern = pattern;
          err.originalOptions = options;
          err.createdOptions = opts;
          throw err;
        }
        try {
          regex = new RegExp("^" + pattern.replace(/(\W)/g, "\\$1") + "$");
        } catch (err2) {
          regex = /.^/;
        }
      }
      if (opts.cache !== false) {
        memoize(regex, key, pattern, opts);
      }
      return regex;
    }
    function memoize(regex, key, pattern, options) {
      define2(regex, "cached", true);
      define2(regex, "pattern", pattern);
      define2(regex, "options", options);
      define2(regex, "key", key);
      cache[key] = regex;
    }
    function createKey(pattern, options) {
      if (!options)
        return pattern;
      var key = pattern;
      for (var prop in options) {
        if (options.hasOwnProperty(prop)) {
          key += ";" + prop + "=" + String(options[prop]);
        }
      }
      return key;
    }
    module2.exports.makeRe = makeRe;
  }
});

// node_modules/array-unique/index.js
var require_array_unique = __commonJS({
  "node_modules/array-unique/index.js"(exports, module2) {
    "use strict";
    module2.exports = function unique(arr) {
      if (!Array.isArray(arr)) {
        throw new TypeError("array-unique expects an array.");
      }
      var len = arr.length;
      var i = -1;
      while (i++ < len) {
        var j = i + 1;
        for (; j < arr.length; ++j) {
          if (arr[i] === arr[j]) {
            arr.splice(j--, 1);
          }
        }
      }
      return arr;
    };
    module2.exports.immutable = function uniqueImmutable(arr) {
      if (!Array.isArray(arr)) {
        throw new TypeError("array-unique expects an array.");
      }
      var arrLen = arr.length;
      var newArr = new Array(arrLen);
      for (var i = 0; i < arrLen; i++) {
        newArr[i] = arr[i];
      }
      return module2.exports(newArr);
    };
  }
});

// node_modules/is-extendable/index.js
var require_is_extendable3 = __commonJS({
  "node_modules/is-extendable/index.js"(exports, module2) {
    "use strict";
    module2.exports = function isExtendable(val) {
      return typeof val !== "undefined" && val !== null && (typeof val === "object" || typeof val === "function");
    };
  }
});

// node_modules/extend-shallow/index.js
var require_extend_shallow3 = __commonJS({
  "node_modules/extend-shallow/index.js"(exports, module2) {
    "use strict";
    var isObject = require_is_extendable3();
    module2.exports = function extend(o) {
      if (!isObject(o)) {
        o = {};
      }
      var len = arguments.length;
      for (var i = 1; i < len; i++) {
        var obj = arguments[i];
        if (isObject(obj)) {
          assign(o, obj);
        }
      }
      return o;
    };
    function assign(a, b) {
      for (var key in b) {
        if (hasOwn(b, key)) {
          a[key] = b[key];
        }
      }
    }
    function hasOwn(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/split-string/node_modules/is-extendable/index.js
var require_is_extendable4 = __commonJS({
  "node_modules/split-string/node_modules/is-extendable/index.js"(exports, module2) {
    "use strict";
    var isPlainObject = require_is_plain_object();
    module2.exports = function isExtendable(val) {
      return isPlainObject(val) || typeof val === "function" || Array.isArray(val);
    };
  }
});

// node_modules/split-string/node_modules/extend-shallow/index.js
var require_extend_shallow4 = __commonJS({
  "node_modules/split-string/node_modules/extend-shallow/index.js"(exports, module2) {
    "use strict";
    var isExtendable = require_is_extendable4();
    var assignSymbols = require_assign_symbols();
    module2.exports = Object.assign || function(obj) {
      if (obj === null || typeof obj === "undefined") {
        throw new TypeError("Cannot convert undefined or null to object");
      }
      if (!isObject(obj)) {
        obj = {};
      }
      for (var i = 1; i < arguments.length; i++) {
        var val = arguments[i];
        if (isString(val)) {
          val = toObject(val);
        }
        if (isObject(val)) {
          assign(obj, val);
          assignSymbols(obj, val);
        }
      }
      return obj;
    };
    function assign(a, b) {
      for (var key in b) {
        if (hasOwn(b, key)) {
          a[key] = b[key];
        }
      }
    }
    function isString(val) {
      return val && typeof val === "string";
    }
    function toObject(str) {
      var obj = {};
      for (var i in str) {
        obj[i] = str[i];
      }
      return obj;
    }
    function isObject(val) {
      return val && typeof val === "object" || isExtendable(val);
    }
    function hasOwn(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/split-string/index.js
var require_split_string = __commonJS({
  "node_modules/split-string/index.js"(exports, module2) {
    "use strict";
    var extend = require_extend_shallow4();
    module2.exports = function(str, options, fn) {
      if (typeof str !== "string") {
        throw new TypeError("expected a string");
      }
      if (typeof options === "function") {
        fn = options;
        options = null;
      }
      if (typeof options === "string") {
        options = { sep: options };
      }
      var opts = extend({ sep: "." }, options);
      var quotes = opts.quotes || ['"', "'", "`"];
      var brackets;
      if (opts.brackets === true) {
        brackets = {
          "<": ">",
          "(": ")",
          "[": "]",
          "{": "}"
        };
      } else if (opts.brackets) {
        brackets = opts.brackets;
      }
      var tokens = [];
      var stack = [];
      var arr = [""];
      var sep = opts.sep;
      var len = str.length;
      var idx = -1;
      var closeIdx;
      function expected() {
        if (brackets && stack.length) {
          return brackets[stack[stack.length - 1]];
        }
      }
      while (++idx < len) {
        var ch = str[idx];
        var next = str[idx + 1];
        var tok = { val: ch, idx, arr, str };
        tokens.push(tok);
        if (ch === "\\") {
          tok.val = keepEscaping(opts, str, idx) === true ? ch + next : next;
          tok.escaped = true;
          if (typeof fn === "function") {
            fn(tok);
          }
          arr[arr.length - 1] += tok.val;
          idx++;
          continue;
        }
        if (brackets && brackets[ch]) {
          stack.push(ch);
          var e = expected();
          var i = idx + 1;
          if (str.indexOf(e, i + 1) !== -1) {
            while (stack.length && i < len) {
              var s = str[++i];
              if (s === "\\") {
                s++;
                continue;
              }
              if (quotes.indexOf(s) !== -1) {
                i = getClosingQuote(str, s, i + 1);
                continue;
              }
              e = expected();
              if (stack.length && str.indexOf(e, i + 1) === -1) {
                break;
              }
              if (brackets[s]) {
                stack.push(s);
                continue;
              }
              if (e === s) {
                stack.pop();
              }
            }
          }
          closeIdx = i;
          if (closeIdx === -1) {
            arr[arr.length - 1] += ch;
            continue;
          }
          ch = str.slice(idx, closeIdx + 1);
          tok.val = ch;
          tok.idx = idx = closeIdx;
        }
        if (quotes.indexOf(ch) !== -1) {
          closeIdx = getClosingQuote(str, ch, idx + 1);
          if (closeIdx === -1) {
            arr[arr.length - 1] += ch;
            continue;
          }
          if (keepQuotes(ch, opts) === true) {
            ch = str.slice(idx, closeIdx + 1);
          } else {
            ch = str.slice(idx + 1, closeIdx);
          }
          tok.val = ch;
          tok.idx = idx = closeIdx;
        }
        if (typeof fn === "function") {
          fn(tok, tokens);
          ch = tok.val;
          idx = tok.idx;
        }
        if (tok.val === sep && tok.split !== false) {
          arr.push("");
          continue;
        }
        arr[arr.length - 1] += tok.val;
      }
      return arr;
    };
    function getClosingQuote(str, ch, i, brackets) {
      var idx = str.indexOf(ch, i);
      if (str.charAt(idx - 1) === "\\") {
        return getClosingQuote(str, ch, idx + 1);
      }
      return idx;
    }
    function keepQuotes(ch, opts) {
      if (opts.keepDoubleQuotes === true && ch === '"')
        return true;
      if (opts.keepSingleQuotes === true && ch === "'")
        return true;
      return opts.keepQuotes;
    }
    function keepEscaping(opts, str, idx) {
      if (typeof opts.keepEscaping === "function") {
        return opts.keepEscaping(str, idx);
      }
      return opts.keepEscaping === true || str[idx + 1] === "\\";
    }
  }
});

// node_modules/arr-flatten/index.js
var require_arr_flatten = __commonJS({
  "node_modules/arr-flatten/index.js"(exports, module2) {
    "use strict";
    module2.exports = function(arr) {
      return flat(arr, []);
    };
    function flat(arr, res) {
      var i = 0, cur;
      var len = arr.length;
      for (; i < len; i++) {
        cur = arr[i];
        Array.isArray(cur) ? flat(cur, res) : res.push(cur);
      }
      return res;
    }
  }
});

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "node_modules/is-buffer/index.js"(exports, module2) {
    module2.exports = function(obj) {
      return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
    };
    function isBuffer(obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    }
    function isSlowBuffer(obj) {
      return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
    }
  }
});

// node_modules/kind-of/index.js
var require_kind_of4 = __commonJS({
  "node_modules/kind-of/index.js"(exports, module2) {
    var isBuffer = require_is_buffer();
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      if (typeof val === "undefined") {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }
      if (val === true || val === false || val instanceof Boolean) {
        return "boolean";
      }
      if (typeof val === "string" || val instanceof String) {
        return "string";
      }
      if (typeof val === "number" || val instanceof Number) {
        return "number";
      }
      if (typeof val === "function" || val instanceof Function) {
        return "function";
      }
      if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
        return "array";
      }
      if (val instanceof RegExp) {
        return "regexp";
      }
      if (val instanceof Date) {
        return "date";
      }
      var type = toString.call(val);
      if (type === "[object RegExp]") {
        return "regexp";
      }
      if (type === "[object Date]") {
        return "date";
      }
      if (type === "[object Arguments]") {
        return "arguments";
      }
      if (type === "[object Error]") {
        return "error";
      }
      if (isBuffer(val)) {
        return "buffer";
      }
      if (type === "[object Set]") {
        return "set";
      }
      if (type === "[object WeakSet]") {
        return "weakset";
      }
      if (type === "[object Map]") {
        return "map";
      }
      if (type === "[object WeakMap]") {
        return "weakmap";
      }
      if (type === "[object Symbol]") {
        return "symbol";
      }
      if (type === "[object Int8Array]") {
        return "int8array";
      }
      if (type === "[object Uint8Array]") {
        return "uint8array";
      }
      if (type === "[object Uint8ClampedArray]") {
        return "uint8clampedarray";
      }
      if (type === "[object Int16Array]") {
        return "int16array";
      }
      if (type === "[object Uint16Array]") {
        return "uint16array";
      }
      if (type === "[object Int32Array]") {
        return "int32array";
      }
      if (type === "[object Uint32Array]") {
        return "uint32array";
      }
      if (type === "[object Float32Array]") {
        return "float32array";
      }
      if (type === "[object Float64Array]") {
        return "float64array";
      }
      return "object";
    };
  }
});

// node_modules/is-number/index.js
var require_is_number = __commonJS({
  "node_modules/is-number/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of4();
    module2.exports = function isNumber(num) {
      var type = typeOf(num);
      if (type === "string") {
        if (!num.trim())
          return false;
      } else if (type !== "number") {
        return false;
      }
      return num - num + 1 >= 0;
    };
  }
});

// node_modules/repeat-string/index.js
var require_repeat_string = __commonJS({
  "node_modules/repeat-string/index.js"(exports, module2) {
    "use strict";
    var res = "";
    var cache;
    module2.exports = repeat;
    function repeat(str, num) {
      if (typeof str !== "string") {
        throw new TypeError("expected a string");
      }
      if (num === 1)
        return str;
      if (num === 2)
        return str + str;
      var max = str.length * num;
      if (cache !== str || typeof cache === "undefined") {
        cache = str;
        res = "";
      } else if (res.length >= max) {
        return res.substr(0, max);
      }
      while (max > res.length && num > 1) {
        if (num & 1) {
          res += str;
        }
        num >>= 1;
        str += str;
      }
      res += str;
      res = res.substr(0, max);
      return res;
    }
  }
});

// node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "node_modules/to-regex-range/index.js"(exports, module2) {
    "use strict";
    var repeat = require_repeat_string();
    var isNumber = require_is_number();
    var cache = {};
    function toRegexRange(min, max, options) {
      if (isNumber(min) === false) {
        throw new RangeError("toRegexRange: first argument is invalid.");
      }
      if (typeof max === "undefined" || min === max) {
        return String(min);
      }
      if (isNumber(max) === false) {
        throw new RangeError("toRegexRange: second argument is invalid.");
      }
      options = options || {};
      var relax = String(options.relaxZeros);
      var shorthand = String(options.shorthand);
      var capture = String(options.capture);
      var key = min + ":" + max + "=" + relax + shorthand + capture;
      if (cache.hasOwnProperty(key)) {
        return cache[key].result;
      }
      var a = Math.min(min, max);
      var b = Math.max(min, max);
      if (Math.abs(a - b) === 1) {
        var result = min + "|" + max;
        if (options.capture) {
          return "(" + result + ")";
        }
        return result;
      }
      var isPadded = padding(min) || padding(max);
      var positives = [];
      var negatives = [];
      var tok = { min, max, a, b };
      if (isPadded) {
        tok.isPadded = isPadded;
        tok.maxLen = String(tok.max).length;
      }
      if (a < 0) {
        var newMin = b < 0 ? Math.abs(b) : 1;
        var newMax = Math.abs(a);
        negatives = splitToPatterns(newMin, newMax, tok, options);
        a = tok.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, tok, options);
      }
      tok.negatives = negatives;
      tok.positives = positives;
      tok.result = siftPatterns(negatives, positives, options);
      if (options.capture && positives.length + negatives.length > 1) {
        tok.result = "(" + tok.result + ")";
      }
      cache[key] = tok;
      return tok.result;
    }
    function siftPatterns(neg, pos, options) {
      var onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      var onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      var intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      var subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min, max) {
      min = Number(min);
      max = Number(max);
      var nines = 1;
      var stops = [max];
      var stop = +countNines(min, nines);
      while (min <= stop && stop <= max) {
        stops = push(stops, stop);
        nines += 1;
        stop = +countNines(min, nines);
      }
      var zeros = 1;
      stop = countZeros(max + 1, zeros) - 1;
      while (min < stop && stop <= max) {
        stops = push(stops, stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
      }
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return { pattern: String(start), digits: [] };
      }
      var zipped = zip(String(start), String(stop));
      var len = zipped.length, i = -1;
      var pattern = "";
      var digits = 0;
      while (++i < len) {
        var numbers = zipped[i];
        var startDigit = numbers[0];
        var stopDigit = numbers[1];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit);
        } else {
          digits += 1;
        }
      }
      if (digits) {
        pattern += options.shorthand ? "\\d" : "[0-9]";
      }
      return { pattern, digits: [digits] };
    }
    function splitToPatterns(min, max, tok, options) {
      var ranges = splitToRanges(min, max);
      var len = ranges.length;
      var idx = -1;
      var tokens = [];
      var start = min;
      var prev;
      while (++idx < len) {
        var range = ranges[idx];
        var obj = rangeToPattern(start, range, options);
        var zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.digits.length > 1) {
            prev.digits.pop();
          }
          prev.digits.push(obj.digits[0]);
          prev.string = prev.pattern + toQuantifier(prev.digits);
          start = range + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(range, tok);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.digits);
        tokens.push(obj);
        start = range + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      var res = [];
      for (var i = 0; i < arr.length; i++) {
        var tok = arr[i];
        var ele = tok.string;
        if (options.relaxZeros !== false) {
          if (prefix === "-" && ele.charAt(0) === "0") {
            if (ele.charAt(1) === "{") {
              ele = "0*" + ele.replace(/^0\{\d+\}/, "");
            } else {
              ele = "0*" + ele.slice(1);
            }
          }
        }
        if (!intersection && !contains(comparison, "string", ele)) {
          res.push(prefix + ele);
        }
        if (intersection && contains(comparison, "string", ele)) {
          res.push(prefix + ele);
        }
      }
      return res;
    }
    function zip(a, b) {
      var arr = [];
      for (var ch in a)
        arr.push([a[ch], b[ch]]);
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function push(arr, ele) {
      if (arr.indexOf(ele) === -1)
        arr.push(ele);
      return arr;
    }
    function contains(arr, key, val) {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i][key] === val) {
          return true;
        }
      }
      return false;
    }
    function countNines(min, len) {
      return String(min).slice(0, -len) + repeat("9", len);
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      var start = digits[0];
      var stop = digits[1] ? "," + digits[1] : "";
      if (!stop && (!start || start === 1)) {
        return "";
      }
      return "{" + start + stop + "}";
    }
    function toCharacterClass(a, b) {
      return "[" + a + (b - a === 1 ? "" : "-") + b + "]";
    }
    function padding(str) {
      return /^-?(0+)\d/.exec(str);
    }
    function padZeros(val, tok) {
      if (tok.isPadded) {
        var diff = Math.abs(tok.maxLen - String(val).length);
        switch (diff) {
          case 0:
            return "";
          case 1:
            return "0";
          default: {
            return "0{" + diff + "}";
          }
        }
      }
      return val;
    }
    module2.exports = toRegexRange;
  }
});

// node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "node_modules/fill-range/index.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var isNumber = require_is_number();
    var extend = require_extend_shallow3();
    var repeat = require_repeat_string();
    var toRegex = require_to_regex_range();
    function fillRange(start, stop, step, options) {
      if (typeof start === "undefined") {
        return [];
      }
      if (typeof stop === "undefined" || start === stop) {
        var isString = typeof start === "string";
        if (isNumber(start) && !toNumber(start)) {
          return [isString ? "0" : 0];
        }
        return [start];
      }
      if (typeof step !== "number" && typeof step !== "string") {
        options = step;
        step = void 0;
      }
      if (typeof options === "function") {
        options = { transform: options };
      }
      var opts = extend({ step }, options);
      if (opts.step && !isValidNumber(opts.step)) {
        if (opts.strictRanges === true) {
          throw new TypeError("expected options.step to be a number");
        }
        return [];
      }
      opts.isNumber = isValidNumber(start) && isValidNumber(stop);
      if (!opts.isNumber && !isValid(start, stop)) {
        if (opts.strictRanges === true) {
          throw new RangeError("invalid range arguments: " + util.inspect([start, stop]));
        }
        return [];
      }
      opts.isPadded = isPadded(start) || isPadded(stop);
      opts.toString = opts.stringify || typeof opts.step === "string" || typeof start === "string" || typeof stop === "string" || !opts.isNumber;
      if (opts.isPadded) {
        opts.maxLength = Math.max(String(start).length, String(stop).length);
      }
      if (typeof opts.optimize === "boolean")
        opts.toRegex = opts.optimize;
      if (typeof opts.makeRe === "boolean")
        opts.toRegex = opts.makeRe;
      return expand(start, stop, opts);
    }
    function expand(start, stop, options) {
      var a = options.isNumber ? toNumber(start) : start.charCodeAt(0);
      var b = options.isNumber ? toNumber(stop) : stop.charCodeAt(0);
      var step = Math.abs(toNumber(options.step)) || 1;
      if (options.toRegex && step === 1) {
        return toRange(a, b, start, stop, options);
      }
      var zero = { greater: [], lesser: [] };
      var asc = a < b;
      var arr = new Array(Math.round((asc ? b - a : a - b) / step));
      var idx = 0;
      while (asc ? a <= b : a >= b) {
        var val = options.isNumber ? a : String.fromCharCode(a);
        if (options.toRegex && (val >= 0 || !options.isNumber)) {
          zero.greater.push(val);
        } else {
          zero.lesser.push(Math.abs(val));
        }
        if (options.isPadded) {
          val = zeros(val, options);
        }
        if (options.toString) {
          val = String(val);
        }
        if (typeof options.transform === "function") {
          arr[idx++] = options.transform(val, a, b, step, idx, arr, options);
        } else {
          arr[idx++] = val;
        }
        if (asc) {
          a += step;
        } else {
          a -= step;
        }
      }
      if (options.toRegex === true) {
        return toSequence(arr, zero, options);
      }
      return arr;
    }
    function toRange(a, b, start, stop, options) {
      if (options.isPadded) {
        return toRegex(start, stop, options);
      }
      if (options.isNumber) {
        return toRegex(Math.min(a, b), Math.max(a, b), options);
      }
      var start = String.fromCharCode(Math.min(a, b));
      var stop = String.fromCharCode(Math.max(a, b));
      return "[" + start + "-" + stop + "]";
    }
    function toSequence(arr, zeros2, options) {
      var greater = "", lesser = "";
      if (zeros2.greater.length) {
        greater = zeros2.greater.join("|");
      }
      if (zeros2.lesser.length) {
        lesser = "-(" + zeros2.lesser.join("|") + ")";
      }
      var res = greater && lesser ? greater + "|" + lesser : greater || lesser;
      if (options.capture) {
        return "(" + res + ")";
      }
      return res;
    }
    function zeros(val, options) {
      if (options.isPadded) {
        var str = String(val);
        var len = str.length;
        var dash = "";
        if (str.charAt(0) === "-") {
          dash = "-";
          str = str.slice(1);
        }
        var diff = options.maxLength - len;
        var pad = repeat("0", diff);
        val = dash + pad + str;
      }
      if (options.stringify) {
        return String(val);
      }
      return val;
    }
    function toNumber(val) {
      return Number(val) || 0;
    }
    function isPadded(str) {
      return /^-?0\d/.test(str);
    }
    function isValid(min, max) {
      return (isValidNumber(min) || isValidLetter(min)) && (isValidNumber(max) || isValidLetter(max));
    }
    function isValidLetter(ch) {
      return typeof ch === "string" && ch.length === 1 && /^\w+$/.test(ch);
    }
    function isValidNumber(n) {
      return isNumber(n) && !/\./.test(n);
    }
    module2.exports = fillRange;
  }
});

// node_modules/repeat-element/index.js
var require_repeat_element = __commonJS({
  "node_modules/repeat-element/index.js"(exports, module2) {
    "use strict";
    module2.exports = function repeat(ele, num) {
      if (Array.prototype.fill) {
        return new Array(num).fill(ele);
      }
      var arr = new Array(num);
      for (var i = 0; i < num; i++) {
        arr[i] = ele;
      }
      return arr;
    };
  }
});

// node_modules/braces/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/braces/lib/utils.js"(exports, module2) {
    "use strict";
    var splitString = require_split_string();
    var utils = module2.exports;
    utils.extend = require_extend_shallow3();
    utils.flatten = require_arr_flatten();
    utils.isObject = require_isobject();
    utils.fillRange = require_fill_range();
    utils.repeat = require_repeat_element();
    utils.unique = require_array_unique();
    utils.define = function(obj, key, val) {
      Object.defineProperty(obj, key, {
        writable: true,
        configurable: true,
        enumerable: false,
        value: val
      });
    };
    utils.isEmptySets = function(str) {
      return /^(?:\{,\})+$/.test(str);
    };
    utils.isQuotedString = function(str) {
      var open = str.charAt(0);
      if (open === "'" || open === '"' || open === "`") {
        return str.slice(-1) === open;
      }
      return false;
    };
    utils.createKey = function(pattern, options) {
      var id = pattern;
      if (typeof options === "undefined") {
        return id;
      }
      var keys = Object.keys(options);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        id += ";" + key + "=" + String(options[key]);
      }
      return id;
    };
    utils.createOptions = function(options) {
      var opts = utils.extend.apply(null, arguments);
      if (typeof opts.expand === "boolean") {
        opts.optimize = !opts.expand;
      }
      if (typeof opts.optimize === "boolean") {
        opts.expand = !opts.optimize;
      }
      if (opts.optimize === true) {
        opts.makeRe = true;
      }
      return opts;
    };
    utils.join = function(a, b, options) {
      options = options || {};
      a = utils.arrayify(a);
      b = utils.arrayify(b);
      if (!a.length)
        return b;
      if (!b.length)
        return a;
      var len = a.length;
      var idx = -1;
      var arr = [];
      while (++idx < len) {
        var val = a[idx];
        if (Array.isArray(val)) {
          for (var i = 0; i < val.length; i++) {
            val[i] = utils.join(val[i], b, options);
          }
          arr.push(val);
          continue;
        }
        for (var j = 0; j < b.length; j++) {
          var bval = b[j];
          if (Array.isArray(bval)) {
            arr.push(utils.join(val, bval, options));
          } else {
            arr.push(val + bval);
          }
        }
      }
      return arr;
    };
    utils.split = function(str, options) {
      var opts = utils.extend({ sep: "," }, options);
      if (typeof opts.keepQuotes !== "boolean") {
        opts.keepQuotes = true;
      }
      if (opts.unescape === false) {
        opts.keepEscaping = true;
      }
      return splitString(str, opts, utils.escapeBrackets(opts));
    };
    utils.expand = function(str, options) {
      var opts = utils.extend({ rangeLimit: 1e4 }, options);
      var segs = utils.split(str, opts);
      var tok = { segs };
      if (utils.isQuotedString(str)) {
        return tok;
      }
      if (opts.rangeLimit === true) {
        opts.rangeLimit = 1e4;
      }
      if (segs.length > 1) {
        if (opts.optimize === false) {
          tok.val = segs[0];
          return tok;
        }
        tok.segs = utils.stringifyArray(tok.segs);
      } else if (segs.length === 1) {
        var arr = str.split("..");
        if (arr.length === 1) {
          tok.val = tok.segs[tok.segs.length - 1] || tok.val || str;
          tok.segs = [];
          return tok;
        }
        if (arr.length === 2 && arr[0] === arr[1]) {
          tok.escaped = true;
          tok.val = arr[0];
          tok.segs = [];
          return tok;
        }
        if (arr.length > 1) {
          if (opts.optimize !== false) {
            opts.optimize = true;
            delete opts.expand;
          }
          if (opts.optimize !== true) {
            var min = Math.min(arr[0], arr[1]);
            var max = Math.max(arr[0], arr[1]);
            var step = arr[2] || 1;
            if (opts.rangeLimit !== false && (max - min) / step >= opts.rangeLimit) {
              throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
            }
          }
          arr.push(opts);
          tok.segs = utils.fillRange.apply(null, arr);
          if (!tok.segs.length) {
            tok.escaped = true;
            tok.val = str;
            return tok;
          }
          if (opts.optimize === true) {
            tok.segs = utils.stringifyArray(tok.segs);
          }
          if (tok.segs === "") {
            tok.val = str;
          } else {
            tok.val = tok.segs[0];
          }
          return tok;
        }
      } else {
        tok.val = str;
      }
      return tok;
    };
    utils.escapeBrackets = function(options) {
      return function(tok) {
        if (tok.escaped && tok.val === "b") {
          tok.val = "\\b";
          return;
        }
        if (tok.val !== "(" && tok.val !== "[")
          return;
        var opts = utils.extend({}, options);
        var brackets = [];
        var parens = [];
        var stack = [];
        var val = tok.val;
        var str = tok.str;
        var i = tok.idx - 1;
        while (++i < str.length) {
          var ch = str[i];
          if (ch === "\\") {
            val += (opts.keepEscaping === false ? "" : ch) + str[++i];
            continue;
          }
          if (ch === "(") {
            parens.push(ch);
            stack.push(ch);
          }
          if (ch === "[") {
            brackets.push(ch);
            stack.push(ch);
          }
          if (ch === ")") {
            parens.pop();
            stack.pop();
            if (!stack.length) {
              val += ch;
              break;
            }
          }
          if (ch === "]") {
            brackets.pop();
            stack.pop();
            if (!stack.length) {
              val += ch;
              break;
            }
          }
          val += ch;
        }
        tok.split = false;
        tok.val = val.slice(1);
        tok.idx = i;
      };
    };
    utils.isQuantifier = function(str) {
      return /^(?:[0-9]?,[0-9]|[0-9],)$/.test(str);
    };
    utils.stringifyArray = function(arr) {
      return [utils.arrayify(arr).join("|")];
    };
    utils.arrayify = function(arr) {
      if (typeof arr === "undefined") {
        return [];
      }
      if (typeof arr === "string") {
        return [arr];
      }
      return arr;
    };
    utils.isString = function(str) {
      return str != null && typeof str === "string";
    };
    utils.last = function(arr, n) {
      return arr[arr.length - (n || 1)];
    };
    utils.escapeRegex = function(str) {
      return str.replace(/\\?([!^*?()[\]{}+?/])/g, "\\$1");
    };
  }
});

// node_modules/braces/lib/compilers.js
var require_compilers = __commonJS({
  "node_modules/braces/lib/compilers.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    module2.exports = function(braces, options) {
      braces.compiler.set("bos", function() {
        if (this.output)
          return;
        this.ast.queue = isEscaped(this.ast) ? [this.ast.val] : [];
        this.ast.count = 1;
      }).set("bracket", function(node) {
        var close = node.close;
        var open = !node.escaped ? "[" : "\\[";
        var negated = node.negated;
        var inner = node.inner;
        inner = inner.replace(/\\(?=[\\\w]|$)/g, "\\\\");
        if (inner === "]-") {
          inner = "\\]\\-";
        }
        if (negated && inner.indexOf(".") === -1) {
          inner += ".";
        }
        if (negated && inner.indexOf("/") === -1) {
          inner += "/";
        }
        var val = open + negated + inner + close;
        var queue = node.parent.queue;
        var last = utils.arrayify(queue.pop());
        queue.push(utils.join(last, val));
        queue.push.apply(queue, []);
      }).set("brace", function(node) {
        node.queue = isEscaped(node) ? [node.val] : [];
        node.count = 1;
        return this.mapVisit(node.nodes);
      }).set("brace.open", function(node) {
        node.parent.open = node.val;
      }).set("text", function(node) {
        var queue = node.parent.queue;
        var escaped = node.escaped;
        var segs = [node.val];
        if (node.optimize === false) {
          options = utils.extend({}, options, { optimize: false });
        }
        if (node.multiplier > 1) {
          node.parent.count *= node.multiplier;
        }
        if (options.quantifiers === true && utils.isQuantifier(node.val)) {
          escaped = true;
        } else if (node.val.length > 1) {
          if (isType(node.parent, "brace") && !isEscaped(node)) {
            var expanded = utils.expand(node.val, options);
            segs = expanded.segs;
            if (expanded.isOptimized) {
              node.parent.isOptimized = true;
            }
            if (!segs.length) {
              var val = expanded.val || node.val;
              if (options.unescape !== false) {
                val = val.replace(/\\([,.])/g, "$1");
                val = val.replace(/["'`]/g, "");
              }
              segs = [val];
              escaped = true;
            }
          }
        } else if (node.val === ",") {
          if (options.expand) {
            node.parent.queue.push([""]);
            segs = [""];
          } else {
            segs = ["|"];
          }
        } else {
          escaped = true;
        }
        if (escaped && isType(node.parent, "brace")) {
          if (node.parent.nodes.length <= 4 && node.parent.count === 1) {
            node.parent.escaped = true;
          } else if (node.parent.length <= 3) {
            node.parent.escaped = true;
          }
        }
        if (!hasQueue(node.parent)) {
          node.parent.queue = segs;
          return;
        }
        var last = utils.arrayify(queue.pop());
        if (node.parent.count > 1 && options.expand) {
          last = multiply(last, node.parent.count);
          node.parent.count = 1;
        }
        queue.push(utils.join(utils.flatten(last), segs.shift()));
        queue.push.apply(queue, segs);
      }).set("brace.close", function(node) {
        var queue = node.parent.queue;
        var prev = node.parent.parent;
        var last = prev.queue.pop();
        var open = node.parent.open;
        var close = node.val;
        if (open && close && isOptimized(node, options)) {
          open = "(";
          close = ")";
        }
        var ele = utils.last(queue);
        if (node.parent.count > 1 && options.expand) {
          ele = multiply(queue.pop(), node.parent.count);
          node.parent.count = 1;
          queue.push(ele);
        }
        if (close && typeof ele === "string" && ele.length === 1) {
          open = "";
          close = "";
        }
        if ((isLiteralBrace(node, options) || noInner(node)) && !node.parent.hasEmpty) {
          queue.push(utils.join(open, queue.pop() || ""));
          queue = utils.flatten(utils.join(queue, close));
        }
        if (typeof last === "undefined") {
          prev.queue = [queue];
        } else {
          prev.queue.push(utils.flatten(utils.join(last, queue)));
        }
      }).set("eos", function(node) {
        if (this.input)
          return;
        if (options.optimize !== false) {
          this.output = utils.last(utils.flatten(this.ast.queue));
        } else if (Array.isArray(utils.last(this.ast.queue))) {
          this.output = utils.flatten(this.ast.queue.pop());
        } else {
          this.output = utils.flatten(this.ast.queue);
        }
        if (node.parent.count > 1 && options.expand) {
          this.output = multiply(this.output, node.parent.count);
        }
        this.output = utils.arrayify(this.output);
        this.ast.queue = [];
      });
    };
    function multiply(queue, n, options) {
      return utils.flatten(utils.repeat(utils.arrayify(queue), n));
    }
    function isEscaped(node) {
      return node.escaped === true;
    }
    function isOptimized(node, options) {
      if (node.parent.isOptimized)
        return true;
      return isType(node.parent, "brace") && !isEscaped(node.parent) && options.expand !== true;
    }
    function isLiteralBrace(node, options) {
      return isEscaped(node.parent) || options.optimize !== false;
    }
    function noInner(node, type) {
      if (node.parent.queue.length === 1) {
        return true;
      }
      var nodes = node.parent.nodes;
      return nodes.length === 3 && isType(nodes[0], "brace.open") && !isType(nodes[1], "text") && isType(nodes[2], "brace.close");
    }
    function isType(node, type) {
      return typeof node !== "undefined" && node.type === type;
    }
    function hasQueue(node) {
      return Array.isArray(node.queue) && node.queue.length;
    }
  }
});

// node_modules/snapdragon-node/node_modules/define-property/index.js
var require_define_property2 = __commonJS({
  "node_modules/snapdragon-node/node_modules/define-property/index.js"(exports, module2) {
    "use strict";
    var isDescriptor = require_is_descriptor();
    module2.exports = function defineProperty(obj, prop, val) {
      if (typeof obj !== "object" && typeof obj !== "function") {
        throw new TypeError("expected an object or function.");
      }
      if (typeof prop !== "string") {
        throw new TypeError("expected `prop` to be a string.");
      }
      if (isDescriptor(val) && ("set" in val || "get" in val)) {
        return Object.defineProperty(obj, prop, val);
      }
      return Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val
      });
    };
  }
});

// node_modules/snapdragon-util/index.js
var require_snapdragon_util = __commonJS({
  "node_modules/snapdragon-util/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of4();
    var utils = module2.exports;
    utils.isNode = function(node) {
      return typeOf(node) === "object" && node.isNode === true;
    };
    utils.noop = function(node) {
      append(this, "", node);
    };
    utils.identity = function(node) {
      append(this, node.val, node);
    };
    utils.append = function(val) {
      return function(node) {
        append(this, val, node);
      };
    };
    utils.toNoop = function(node, nodes) {
      if (nodes) {
        node.nodes = nodes;
      } else {
        delete node.nodes;
        node.type = "text";
        node.val = "";
      }
    };
    utils.visit = function(node, fn) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      assert(isFunction(fn), "expected a visitor function");
      fn(node);
      return node.nodes ? utils.mapVisit(node, fn) : node;
    };
    utils.mapVisit = function(node, fn) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      assert(isArray(node.nodes), "expected node.nodes to be an array");
      assert(isFunction(fn), "expected a visitor function");
      for (var i = 0; i < node.nodes.length; i++) {
        utils.visit(node.nodes[i], fn);
      }
      return node;
    };
    utils.addOpen = function(node, Node, val, filter) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      assert(isFunction(Node), "expected Node to be a constructor function");
      if (typeof val === "function") {
        filter = val;
        val = "";
      }
      if (typeof filter === "function" && !filter(node))
        return;
      var open = new Node({ type: node.type + ".open", val });
      var unshift = node.unshift || node.unshiftNode;
      if (typeof unshift === "function") {
        unshift.call(node, open);
      } else {
        utils.unshiftNode(node, open);
      }
      return open;
    };
    utils.addClose = function(node, Node, val, filter) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      assert(isFunction(Node), "expected Node to be a constructor function");
      if (typeof val === "function") {
        filter = val;
        val = "";
      }
      if (typeof filter === "function" && !filter(node))
        return;
      var close = new Node({ type: node.type + ".close", val });
      var push = node.push || node.pushNode;
      if (typeof push === "function") {
        push.call(node, close);
      } else {
        utils.pushNode(node, close);
      }
      return close;
    };
    utils.wrapNodes = function(node, Node, filter) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      assert(isFunction(Node), "expected Node to be a constructor function");
      utils.addOpen(node, Node, filter);
      utils.addClose(node, Node, filter);
      return node;
    };
    utils.pushNode = function(parent, node) {
      assert(utils.isNode(parent), "expected parent node to be an instance of Node");
      assert(utils.isNode(node), "expected node to be an instance of Node");
      node.define("parent", parent);
      parent.nodes = parent.nodes || [];
      parent.nodes.push(node);
      return node;
    };
    utils.unshiftNode = function(parent, node) {
      assert(utils.isNode(parent), "expected parent node to be an instance of Node");
      assert(utils.isNode(node), "expected node to be an instance of Node");
      node.define("parent", parent);
      parent.nodes = parent.nodes || [];
      parent.nodes.unshift(node);
    };
    utils.popNode = function(node) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      if (typeof node.pop === "function") {
        return node.pop();
      }
      return node.nodes && node.nodes.pop();
    };
    utils.shiftNode = function(node) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      if (typeof node.shift === "function") {
        return node.shift();
      }
      return node.nodes && node.nodes.shift();
    };
    utils.removeNode = function(parent, node) {
      assert(utils.isNode(parent), "expected parent.node to be an instance of Node");
      assert(utils.isNode(node), "expected node to be an instance of Node");
      if (!parent.nodes) {
        return null;
      }
      if (typeof parent.remove === "function") {
        return parent.remove(node);
      }
      var idx = parent.nodes.indexOf(node);
      if (idx !== -1) {
        return parent.nodes.splice(idx, 1);
      }
    };
    utils.isType = function(node, type) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      switch (typeOf(type)) {
        case "array":
          var types = type.slice();
          for (var i = 0; i < types.length; i++) {
            if (utils.isType(node, types[i])) {
              return true;
            }
          }
          return false;
        case "string":
          return node.type === type;
        case "regexp":
          return type.test(node.type);
        default: {
          throw new TypeError('expected "type" to be an array, string or regexp');
        }
      }
    };
    utils.hasType = function(node, type) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      if (!Array.isArray(node.nodes))
        return false;
      for (var i = 0; i < node.nodes.length; i++) {
        if (utils.isType(node.nodes[i], type)) {
          return true;
        }
      }
      return false;
    };
    utils.firstOfType = function(nodes, type) {
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (utils.isType(node, type)) {
          return node;
        }
      }
    };
    utils.findNode = function(nodes, type) {
      if (!Array.isArray(nodes)) {
        return null;
      }
      if (typeof type === "number") {
        return nodes[type];
      }
      return utils.firstOfType(nodes, type);
    };
    utils.isOpen = function(node) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      return node.type.slice(-5) === ".open";
    };
    utils.isClose = function(node) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      return node.type.slice(-6) === ".close";
    };
    utils.hasOpen = function(node) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      var first = node.first || node.nodes ? node.nodes[0] : null;
      if (utils.isNode(first)) {
        return first.type === node.type + ".open";
      }
      return false;
    };
    utils.hasClose = function(node) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      var last = node.last || node.nodes ? node.nodes[node.nodes.length - 1] : null;
      if (utils.isNode(last)) {
        return last.type === node.type + ".close";
      }
      return false;
    };
    utils.hasOpenAndClose = function(node) {
      return utils.hasOpen(node) && utils.hasClose(node);
    };
    utils.addType = function(state, node) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      assert(isObject(state), "expected state to be an object");
      var type = node.parent ? node.parent.type : node.type.replace(/\.open$/, "");
      if (!state.hasOwnProperty("inside")) {
        state.inside = {};
      }
      if (!state.inside.hasOwnProperty(type)) {
        state.inside[type] = [];
      }
      var arr = state.inside[type];
      arr.push(node);
      return arr;
    };
    utils.removeType = function(state, node) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      assert(isObject(state), "expected state to be an object");
      var type = node.parent ? node.parent.type : node.type.replace(/\.close$/, "");
      if (state.inside.hasOwnProperty(type)) {
        return state.inside[type].pop();
      }
    };
    utils.isEmpty = function(node, fn) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      if (!Array.isArray(node.nodes)) {
        if (node.type !== "text") {
          return true;
        }
        if (typeof fn === "function") {
          return fn(node, node.parent);
        }
        return !utils.trim(node.val);
      }
      for (var i = 0; i < node.nodes.length; i++) {
        var child2 = node.nodes[i];
        if (utils.isOpen(child2) || utils.isClose(child2)) {
          continue;
        }
        if (!utils.isEmpty(child2, fn)) {
          return false;
        }
      }
      return true;
    };
    utils.isInsideType = function(state, type) {
      assert(isObject(state), "expected state to be an object");
      assert(isString(type), "expected type to be a string");
      if (!state.hasOwnProperty("inside")) {
        return false;
      }
      if (!state.inside.hasOwnProperty(type)) {
        return false;
      }
      return state.inside[type].length > 0;
    };
    utils.isInside = function(state, node, type) {
      assert(utils.isNode(node), "expected node to be an instance of Node");
      assert(isObject(state), "expected state to be an object");
      if (Array.isArray(type)) {
        for (var i = 0; i < type.length; i++) {
          if (utils.isInside(state, node, type[i])) {
            return true;
          }
        }
        return false;
      }
      var parent = node.parent;
      if (typeof type === "string") {
        return parent && parent.type === type || utils.isInsideType(state, type);
      }
      if (typeOf(type) === "regexp") {
        if (parent && parent.type && type.test(parent.type)) {
          return true;
        }
        var keys = Object.keys(state.inside);
        var len = keys.length;
        var idx = -1;
        while (++idx < len) {
          var key = keys[idx];
          var val = state.inside[key];
          if (Array.isArray(val) && val.length !== 0 && type.test(key)) {
            return true;
          }
        }
      }
      return false;
    };
    utils.last = function(arr, n) {
      return arr[arr.length - (n || 1)];
    };
    utils.arrayify = function(val) {
      if (typeof val === "string" && val !== "") {
        return [val];
      }
      if (!Array.isArray(val)) {
        return [];
      }
      return val;
    };
    utils.stringify = function(val) {
      return utils.arrayify(val).join(",");
    };
    utils.trim = function(str) {
      return typeof str === "string" ? str.trim() : "";
    };
    function isObject(val) {
      return typeOf(val) === "object";
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isFunction(val) {
      return typeof val === "function";
    }
    function isArray(val) {
      return Array.isArray(val);
    }
    function append(compiler, val, node) {
      if (typeof compiler.append !== "function") {
        return compiler.emit(val, node);
      }
      return compiler.append(val, node);
    }
    function assert(val, message) {
      if (!val)
        throw new Error(message);
    }
  }
});

// node_modules/snapdragon-node/index.js
var require_snapdragon_node = __commonJS({
  "node_modules/snapdragon-node/index.js"(exports, module2) {
    "use strict";
    var isObject = require_isobject();
    var define2 = require_define_property2();
    var utils = require_snapdragon_util();
    var ownNames;
    function Node(val, type, parent) {
      if (typeof type !== "string") {
        parent = type;
        type = null;
      }
      define2(this, "parent", parent);
      define2(this, "isNode", true);
      define2(this, "expect", null);
      if (typeof type !== "string" && isObject(val)) {
        lazyKeys();
        var keys = Object.keys(val);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (ownNames.indexOf(key) === -1) {
            this[key] = val[key];
          }
        }
      } else {
        this.type = type;
        this.val = val;
      }
    }
    Node.isNode = function(node) {
      return utils.isNode(node);
    };
    Node.prototype.define = function(name, val) {
      define2(this, name, val);
      return this;
    };
    Node.prototype.isEmpty = function(fn) {
      return utils.isEmpty(this, fn);
    };
    Node.prototype.push = function(node) {
      assert(Node.isNode(node), "expected node to be an instance of Node");
      define2(node, "parent", this);
      this.nodes = this.nodes || [];
      return this.nodes.push(node);
    };
    Node.prototype.unshift = function(node) {
      assert(Node.isNode(node), "expected node to be an instance of Node");
      define2(node, "parent", this);
      this.nodes = this.nodes || [];
      return this.nodes.unshift(node);
    };
    Node.prototype.pop = function() {
      return this.nodes && this.nodes.pop();
    };
    Node.prototype.shift = function() {
      return this.nodes && this.nodes.shift();
    };
    Node.prototype.remove = function(node) {
      assert(Node.isNode(node), "expected node to be an instance of Node");
      this.nodes = this.nodes || [];
      var idx = node.index;
      if (idx !== -1) {
        node.index = -1;
        return this.nodes.splice(idx, 1);
      }
      return null;
    };
    Node.prototype.find = function(type) {
      return utils.findNode(this.nodes, type);
    };
    Node.prototype.isType = function(type) {
      return utils.isType(this, type);
    };
    Node.prototype.hasType = function(type) {
      return utils.hasType(this, type);
    };
    Object.defineProperty(Node.prototype, "siblings", {
      set: function() {
        throw new Error("node.siblings is a getter and cannot be defined");
      },
      get: function() {
        return this.parent ? this.parent.nodes : null;
      }
    });
    Object.defineProperty(Node.prototype, "index", {
      set: function(index) {
        define2(this, "idx", index);
      },
      get: function() {
        if (!Array.isArray(this.siblings)) {
          return -1;
        }
        var tok = this.idx !== -1 ? this.siblings[this.idx] : null;
        if (tok !== this) {
          this.idx = this.siblings.indexOf(this);
        }
        return this.idx;
      }
    });
    Object.defineProperty(Node.prototype, "prev", {
      set: function() {
        throw new Error("node.prev is a getter and cannot be defined");
      },
      get: function() {
        if (Array.isArray(this.siblings)) {
          return this.siblings[this.index - 1] || this.parent.prev;
        }
        return null;
      }
    });
    Object.defineProperty(Node.prototype, "next", {
      set: function() {
        throw new Error("node.next is a getter and cannot be defined");
      },
      get: function() {
        if (Array.isArray(this.siblings)) {
          return this.siblings[this.index + 1] || this.parent.next;
        }
        return null;
      }
    });
    Object.defineProperty(Node.prototype, "first", {
      get: function() {
        return this.nodes ? this.nodes[0] : null;
      }
    });
    Object.defineProperty(Node.prototype, "last", {
      get: function() {
        return this.nodes ? utils.last(this.nodes) : null;
      }
    });
    Object.defineProperty(Node.prototype, "scope", {
      get: function() {
        if (this.isScope !== true) {
          return this.parent ? this.parent.scope : this;
        }
        return this;
      }
    });
    function lazyKeys() {
      if (!ownNames) {
        ownNames = Object.getOwnPropertyNames(Node.prototype);
      }
    }
    function assert(val, message) {
      if (!val)
        throw new Error(message);
    }
    exports = module2.exports = Node;
  }
});

// node_modules/braces/lib/parsers.js
var require_parsers = __commonJS({
  "node_modules/braces/lib/parsers.js"(exports, module2) {
    "use strict";
    var Node = require_snapdragon_node();
    var utils = require_utils2();
    module2.exports = function(braces, options) {
      braces.parser.set("bos", function() {
        if (!this.parsed) {
          this.ast = this.nodes[0] = new Node(this.ast);
        }
      }).set("escape", function() {
        var pos = this.position();
        var m = this.match(/^(?:\\(.)|\$\{)/);
        if (!m)
          return;
        var prev = this.prev();
        var last = utils.last(prev.nodes);
        var node = pos(new Node({
          type: "text",
          multiplier: 1,
          val: m[0]
        }));
        if (node.val === "\\\\") {
          return node;
        }
        if (node.val === "${") {
          var str = this.input;
          var idx = -1;
          var ch;
          while (ch = str[++idx]) {
            this.consume(1);
            node.val += ch;
            if (ch === "\\") {
              node.val += str[++idx];
              continue;
            }
            if (ch === "}") {
              break;
            }
          }
        }
        if (this.options.unescape !== false) {
          node.val = node.val.replace(/\\([{}])/g, "$1");
        }
        if (last.val === '"' && this.input.charAt(0) === '"') {
          last.val = node.val;
          this.consume(1);
          return;
        }
        return concatNodes.call(this, pos, node, prev, options);
      }).set("bracket", function() {
        var isInside = this.isInside("brace");
        var pos = this.position();
        var m = this.match(/^(?:\[([!^]?)([^\]]{2,}|\]-)(\]|[^*+?]+)|\[)/);
        if (!m)
          return;
        var prev = this.prev();
        var val = m[0];
        var negated = m[1] ? "^" : "";
        var inner = m[2] || "";
        var close = m[3] || "";
        if (isInside && prev.type === "brace") {
          prev.text = prev.text || "";
          prev.text += val;
        }
        var esc = this.input.slice(0, 2);
        if (inner === "" && esc === "\\]") {
          inner += esc;
          this.consume(2);
          var str = this.input;
          var idx = -1;
          var ch;
          while (ch = str[++idx]) {
            this.consume(1);
            if (ch === "]") {
              close = ch;
              break;
            }
            inner += ch;
          }
        }
        return pos(new Node({
          type: "bracket",
          val,
          escaped: close !== "]",
          negated,
          inner,
          close
        }));
      }).set("multiplier", function() {
        var isInside = this.isInside("brace");
        var pos = this.position();
        var m = this.match(/^\{((?:,|\{,+\})+)\}/);
        if (!m)
          return;
        this.multiplier = true;
        var prev = this.prev();
        var val = m[0];
        if (isInside && prev.type === "brace") {
          prev.text = prev.text || "";
          prev.text += val;
        }
        var node = pos(new Node({
          type: "text",
          multiplier: 1,
          match: m,
          val
        }));
        return concatNodes.call(this, pos, node, prev, options);
      }).set("brace.open", function() {
        var pos = this.position();
        var m = this.match(/^\{(?!(?:[^\\}]?|,+)\})/);
        if (!m)
          return;
        var prev = this.prev();
        var last = utils.last(prev.nodes);
        if (last && last.val && isExtglobChar(last.val.slice(-1))) {
          last.optimize = false;
        }
        var open = pos(new Node({
          type: "brace.open",
          val: m[0]
        }));
        var node = pos(new Node({
          type: "brace",
          nodes: []
        }));
        node.push(open);
        prev.push(node);
        this.push("brace", node);
      }).set("brace.close", function() {
        var pos = this.position();
        var m = this.match(/^\}/);
        if (!m || !m[0])
          return;
        var brace = this.pop("brace");
        var node = pos(new Node({
          type: "brace.close",
          val: m[0]
        }));
        if (!this.isType(brace, "brace")) {
          if (this.options.strict) {
            throw new Error('missing opening "{"');
          }
          node.type = "text";
          node.multiplier = 0;
          node.escaped = true;
          return node;
        }
        var prev = this.prev();
        var last = utils.last(prev.nodes);
        if (last.text) {
          var lastNode = utils.last(last.nodes);
          if (lastNode.val === ")" && /[!@*?+]\(/.test(last.text)) {
            var open = last.nodes[0];
            var text = last.nodes[1];
            if (open.type === "brace.open" && text && text.type === "text") {
              text.optimize = false;
            }
          }
        }
        if (brace.nodes.length > 2) {
          var first = brace.nodes[1];
          if (first.type === "text" && first.val === ",") {
            brace.nodes.splice(1, 1);
            brace.nodes.push(first);
          }
        }
        brace.push(node);
      }).set("boundary", function() {
        var pos = this.position();
        var m = this.match(/^[$^](?!\{)/);
        if (!m)
          return;
        return pos(new Node({
          type: "text",
          val: m[0]
        }));
      }).set("nobrace", function() {
        var isInside = this.isInside("brace");
        var pos = this.position();
        var m = this.match(/^\{[^,]?\}/);
        if (!m)
          return;
        var prev = this.prev();
        var val = m[0];
        if (isInside && prev.type === "brace") {
          prev.text = prev.text || "";
          prev.text += val;
        }
        return pos(new Node({
          type: "text",
          multiplier: 0,
          val
        }));
      }).set("text", function() {
        var isInside = this.isInside("brace");
        var pos = this.position();
        var m = this.match(/^((?!\\)[^${}[\]])+/);
        if (!m)
          return;
        var prev = this.prev();
        var val = m[0];
        if (isInside && prev.type === "brace") {
          prev.text = prev.text || "";
          prev.text += val;
        }
        var node = pos(new Node({
          type: "text",
          multiplier: 1,
          val
        }));
        return concatNodes.call(this, pos, node, prev, options);
      });
    };
    function isExtglobChar(ch) {
      return ch === "!" || ch === "@" || ch === "*" || ch === "?" || ch === "+";
    }
    function concatNodes(pos, node, parent, options) {
      node.orig = node.val;
      var prev = this.prev();
      var last = utils.last(prev.nodes);
      var isEscaped = false;
      if (node.val.length > 1) {
        var a = node.val.charAt(0);
        var b = node.val.slice(-1);
        isEscaped = a === '"' && b === '"' || a === "'" && b === "'" || a === "`" && b === "`";
      }
      if (isEscaped && options.unescape !== false) {
        node.val = node.val.slice(1, node.val.length - 1);
        node.escaped = true;
      }
      if (node.match) {
        var match = node.match[1];
        if (!match || match.indexOf("}") === -1) {
          match = node.match[0];
        }
        var val = match.replace(/\{/g, ",").replace(/\}/g, "");
        node.multiplier *= val.length;
        node.val = "";
      }
      var simpleText = last.type === "text" && last.multiplier === 1 && node.multiplier === 1 && node.val;
      if (simpleText) {
        last.val += node.val;
        return;
      }
      prev.push(node);
    }
  }
});

// node_modules/base/node_modules/define-property/index.js
var require_define_property3 = __commonJS({
  "node_modules/base/node_modules/define-property/index.js"(exports, module2) {
    "use strict";
    var isDescriptor = require_is_descriptor();
    module2.exports = function defineProperty(obj, prop, val) {
      if (typeof obj !== "object" && typeof obj !== "function") {
        throw new TypeError("expected an object or function.");
      }
      if (typeof prop !== "string") {
        throw new TypeError("expected `prop` to be a string.");
      }
      if (isDescriptor(val) && ("set" in val || "get" in val)) {
        return Object.defineProperty(obj, prop, val);
      }
      return Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val
      });
    };
  }
});

// node_modules/component-emitter/index.js
var require_component_emitter = __commonJS({
  "node_modules/component-emitter/index.js"(exports, module2) {
    if (typeof module2 !== "undefined") {
      module2.exports = Emitter;
    }
    function Emitter(obj) {
      if (obj)
        return mixin(obj);
    }
    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }
      return obj;
    }
    Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
      return this;
    };
    Emitter.prototype.once = function(event, fn) {
      function on() {
        this.off(event, on);
        fn.apply(this, arguments);
      }
      on.fn = fn;
      this.on(event, on);
      return this;
    };
    Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      if (arguments.length == 0) {
        this._callbacks = {};
        return this;
      }
      var callbacks = this._callbacks["$" + event];
      if (!callbacks)
        return this;
      if (arguments.length == 1) {
        delete this._callbacks["$" + event];
        return this;
      }
      var cb;
      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }
      if (callbacks.length === 0) {
        delete this._callbacks["$" + event];
      }
      return this;
    };
    Emitter.prototype.emit = function(event) {
      this._callbacks = this._callbacks || {};
      var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }
      return this;
    };
    Emitter.prototype.listeners = function(event) {
      this._callbacks = this._callbacks || {};
      return this._callbacks["$" + event] || [];
    };
    Emitter.prototype.hasListeners = function(event) {
      return !!this.listeners(event).length;
    };
  }
});

// node_modules/object-visit/index.js
var require_object_visit = __commonJS({
  "node_modules/object-visit/index.js"(exports, module2) {
    "use strict";
    var isObject = require_isobject();
    module2.exports = function visit(thisArg, method, target, val) {
      if (!isObject(thisArg) && typeof thisArg !== "function") {
        throw new Error("object-visit expects `thisArg` to be an object.");
      }
      if (typeof method !== "string") {
        throw new Error("object-visit expects `method` name to be a string");
      }
      if (typeof thisArg[method] !== "function") {
        return thisArg;
      }
      var args = [].slice.call(arguments, 3);
      target = target || {};
      for (var key in target) {
        var arr = [key, target[key]].concat(args);
        thisArg[method].apply(thisArg, arr);
      }
      return thisArg;
    };
  }
});

// node_modules/map-visit/index.js
var require_map_visit = __commonJS({
  "node_modules/map-visit/index.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var visit = require_object_visit();
    module2.exports = function mapVisit(collection, method, val) {
      if (isObject(val)) {
        return visit.apply(null, arguments);
      }
      if (!Array.isArray(val)) {
        throw new TypeError("expected an array: " + util.inspect(val));
      }
      var args = [].slice.call(arguments, 3);
      for (var i = 0; i < val.length; i++) {
        var ele = val[i];
        if (isObject(ele)) {
          visit.apply(null, [collection, method, ele].concat(args));
        } else {
          collection[method].apply(collection, [ele].concat(args));
        }
      }
    };
    function isObject(val) {
      return val && (typeof val === "function" || !Array.isArray(val) && typeof val === "object");
    }
  }
});

// node_modules/collection-visit/index.js
var require_collection_visit = __commonJS({
  "node_modules/collection-visit/index.js"(exports, module2) {
    "use strict";
    var visit = require_object_visit();
    var mapVisit = require_map_visit();
    module2.exports = function(collection, method, val) {
      var result;
      if (typeof val === "string" && method in collection) {
        var args = [].slice.call(arguments, 2);
        result = collection[method].apply(collection, args);
      } else if (Array.isArray(val)) {
        result = mapVisit.apply(null, arguments);
      } else {
        result = visit.apply(null, arguments);
      }
      if (typeof result !== "undefined") {
        return result;
      }
      return collection;
    };
  }
});

// node_modules/to-object-path/index.js
var require_to_object_path = __commonJS({
  "node_modules/to-object-path/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of4();
    module2.exports = function toPath(args) {
      if (typeOf(args) !== "arguments") {
        args = arguments;
      }
      return filter(args).join(".");
    };
    function filter(arr) {
      var len = arr.length;
      var idx = -1;
      var res = [];
      while (++idx < len) {
        var ele = arr[idx];
        if (typeOf(ele) === "arguments" || Array.isArray(ele)) {
          res.push.apply(res, filter(ele));
        } else if (typeof ele === "string") {
          res.push(ele);
        }
      }
      return res;
    }
  }
});

// node_modules/arr-union/index.js
var require_arr_union = __commonJS({
  "node_modules/arr-union/index.js"(exports, module2) {
    "use strict";
    module2.exports = function union(init) {
      if (!Array.isArray(init)) {
        throw new TypeError("arr-union expects the first argument to be an array.");
      }
      var len = arguments.length;
      var i = 0;
      while (++i < len) {
        var arg = arguments[i];
        if (!arg)
          continue;
        if (!Array.isArray(arg)) {
          arg = [arg];
        }
        for (var j = 0; j < arg.length; j++) {
          var ele = arg[j];
          if (init.indexOf(ele) >= 0) {
            continue;
          }
          init.push(ele);
        }
      }
      return init;
    };
  }
});

// node_modules/get-value/index.js
var require_get_value = __commonJS({
  "node_modules/get-value/index.js"(exports, module2) {
    module2.exports = function(obj, prop, a, b, c) {
      if (!isObject(obj) || !prop) {
        return obj;
      }
      prop = toString(prop);
      if (a)
        prop += "." + toString(a);
      if (b)
        prop += "." + toString(b);
      if (c)
        prop += "." + toString(c);
      if (prop in obj) {
        return obj[prop];
      }
      var segs = prop.split(".");
      var len = segs.length;
      var i = -1;
      while (obj && ++i < len) {
        var key = segs[i];
        while (key[key.length - 1] === "\\") {
          key = key.slice(0, -1) + "." + segs[++i];
        }
        obj = obj[key];
      }
      return obj;
    };
    function isObject(val) {
      return val !== null && (typeof val === "object" || typeof val === "function");
    }
    function toString(val) {
      if (!val)
        return "";
      if (Array.isArray(val)) {
        return val.join(".");
      }
      return val;
    }
  }
});

// node_modules/set-value/index.js
var require_set_value = __commonJS({
  "node_modules/set-value/index.js"(exports, module2) {
    "use strict";
    var split = require_split_string();
    var extend = require_extend_shallow3();
    var isPlainObject = require_is_plain_object();
    var isObject = require_is_extendable3();
    module2.exports = function(obj, prop, val) {
      if (!isObject(obj)) {
        return obj;
      }
      if (Array.isArray(prop)) {
        prop = [].concat.apply([], prop).join(".");
      }
      if (typeof prop !== "string") {
        return obj;
      }
      var keys = split(prop, { sep: ".", brackets: true }).filter(isValidKey);
      var len = keys.length;
      var idx = -1;
      var current = obj;
      while (++idx < len) {
        var key = keys[idx];
        if (idx !== len - 1) {
          if (!isObject(current[key])) {
            current[key] = {};
          }
          current = current[key];
          continue;
        }
        if (isPlainObject(current[key]) && isPlainObject(val)) {
          current[key] = extend({}, current[key], val);
        } else {
          current[key] = val;
        }
      }
      return obj;
    };
    function isValidKey(key) {
      return key !== "__proto__" && key !== "constructor" && key !== "prototype";
    }
  }
});

// node_modules/union-value/index.js
var require_union_value = __commonJS({
  "node_modules/union-value/index.js"(exports, module2) {
    "use strict";
    var isObject = require_is_extendable3();
    var union = require_arr_union();
    var get = require_get_value();
    var set = require_set_value();
    module2.exports = function unionValue(obj, prop, value) {
      if (!isObject(obj)) {
        throw new TypeError("union-value expects the first argument to be an object.");
      }
      if (typeof prop !== "string") {
        throw new TypeError("union-value expects `prop` to be a string.");
      }
      var arr = arrayify(get(obj, prop));
      set(obj, prop, union(arr, arrayify(value)));
      return obj;
    };
    function arrayify(val) {
      if (val === null || typeof val === "undefined") {
        return [];
      }
      if (Array.isArray(val)) {
        return val;
      }
      return [val];
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/unset-value/node_modules/has-value/node_modules/isobject/index.js
var require_isobject2 = __commonJS({
  "node_modules/unset-value/node_modules/has-value/node_modules/isobject/index.js"(exports, module2) {
    "use strict";
    var isArray = require_isarray();
    module2.exports = function isObject(val) {
      return val != null && typeof val === "object" && isArray(val) === false;
    };
  }
});

// node_modules/unset-value/node_modules/has-values/index.js
var require_has_values = __commonJS({
  "node_modules/unset-value/node_modules/has-values/index.js"(exports, module2) {
    "use strict";
    module2.exports = function hasValue(o, noZero) {
      if (o === null || o === void 0) {
        return false;
      }
      if (typeof o === "boolean") {
        return true;
      }
      if (typeof o === "number") {
        if (o === 0 && noZero === true) {
          return false;
        }
        return true;
      }
      if (o.length !== void 0) {
        return o.length !== 0;
      }
      for (var key in o) {
        if (o.hasOwnProperty(key)) {
          return true;
        }
      }
      return false;
    };
  }
});

// node_modules/unset-value/node_modules/has-value/index.js
var require_has_value = __commonJS({
  "node_modules/unset-value/node_modules/has-value/index.js"(exports, module2) {
    "use strict";
    var isObject = require_isobject2();
    var hasValues = require_has_values();
    var get = require_get_value();
    module2.exports = function(obj, prop, noZero) {
      if (isObject(obj)) {
        return hasValues(get(obj, prop), noZero);
      }
      return hasValues(obj, prop);
    };
  }
});

// node_modules/unset-value/index.js
var require_unset_value = __commonJS({
  "node_modules/unset-value/index.js"(exports, module2) {
    "use strict";
    var isObject = require_isobject();
    var has = require_has_value();
    module2.exports = function unset(obj, prop) {
      if (!isObject(obj)) {
        throw new TypeError("expected an object.");
      }
      if (obj.hasOwnProperty(prop)) {
        delete obj[prop];
        return true;
      }
      if (has(obj, prop)) {
        var segs = prop.split(".");
        var last = segs.pop();
        while (segs.length && segs[segs.length - 1].slice(-1) === "\\") {
          last = segs.pop().slice(0, -1) + "." + last;
        }
        while (segs.length)
          obj = obj[prop = segs.shift()];
        return delete obj[last];
      }
      return true;
    };
  }
});

// node_modules/has-values/node_modules/kind-of/index.js
var require_kind_of5 = __commonJS({
  "node_modules/has-values/node_modules/kind-of/index.js"(exports, module2) {
    var isBuffer = require_is_buffer();
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      if (typeof val === "undefined") {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }
      if (val === true || val === false || val instanceof Boolean) {
        return "boolean";
      }
      if (typeof val === "string" || val instanceof String) {
        return "string";
      }
      if (typeof val === "number" || val instanceof Number) {
        return "number";
      }
      if (typeof val === "function" || val instanceof Function) {
        return "function";
      }
      if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
        return "array";
      }
      if (val instanceof RegExp) {
        return "regexp";
      }
      if (val instanceof Date) {
        return "date";
      }
      var type = toString.call(val);
      if (type === "[object RegExp]") {
        return "regexp";
      }
      if (type === "[object Date]") {
        return "date";
      }
      if (type === "[object Arguments]") {
        return "arguments";
      }
      if (type === "[object Error]") {
        return "error";
      }
      if (type === "[object Promise]") {
        return "promise";
      }
      if (isBuffer(val)) {
        return "buffer";
      }
      if (type === "[object Set]") {
        return "set";
      }
      if (type === "[object WeakSet]") {
        return "weakset";
      }
      if (type === "[object Map]") {
        return "map";
      }
      if (type === "[object WeakMap]") {
        return "weakmap";
      }
      if (type === "[object Symbol]") {
        return "symbol";
      }
      if (type === "[object Int8Array]") {
        return "int8array";
      }
      if (type === "[object Uint8Array]") {
        return "uint8array";
      }
      if (type === "[object Uint8ClampedArray]") {
        return "uint8clampedarray";
      }
      if (type === "[object Int16Array]") {
        return "int16array";
      }
      if (type === "[object Uint16Array]") {
        return "uint16array";
      }
      if (type === "[object Int32Array]") {
        return "int32array";
      }
      if (type === "[object Uint32Array]") {
        return "uint32array";
      }
      if (type === "[object Float32Array]") {
        return "float32array";
      }
      if (type === "[object Float64Array]") {
        return "float64array";
      }
      return "object";
    };
  }
});

// node_modules/has-values/index.js
var require_has_values2 = __commonJS({
  "node_modules/has-values/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of5();
    var isNumber = require_is_number();
    module2.exports = function hasValue(val) {
      if (isNumber(val)) {
        return true;
      }
      switch (typeOf(val)) {
        case "null":
        case "boolean":
        case "function":
          return true;
        case "string":
        case "arguments":
          return val.length !== 0;
        case "error":
          return val.message !== "";
        case "array":
          var len = val.length;
          if (len === 0) {
            return false;
          }
          for (var i = 0; i < len; i++) {
            if (hasValue(val[i])) {
              return true;
            }
          }
          return false;
        case "file":
        case "map":
        case "set":
          return val.size !== 0;
        case "object":
          var keys = Object.keys(val);
          if (keys.length === 0) {
            return false;
          }
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (hasValue(val[key])) {
              return true;
            }
          }
          return false;
        default: {
          return false;
        }
      }
    };
  }
});

// node_modules/has-value/index.js
var require_has_value2 = __commonJS({
  "node_modules/has-value/index.js"(exports, module2) {
    "use strict";
    var isObject = require_isobject();
    var hasValues = require_has_values2();
    var get = require_get_value();
    module2.exports = function(val, prop) {
      return hasValues(isObject(val) && prop ? get(val, prop) : val);
    };
  }
});

// node_modules/cache-base/index.js
var require_cache_base = __commonJS({
  "node_modules/cache-base/index.js"(exports, module2) {
    "use strict";
    var isObject = require_isobject();
    var Emitter = require_component_emitter();
    var visit = require_collection_visit();
    var toPath = require_to_object_path();
    var union = require_union_value();
    var del = require_unset_value();
    var get = require_get_value();
    var has = require_has_value2();
    var set = require_set_value();
    function namespace(prop) {
      function Cache(cache) {
        if (prop) {
          this[prop] = {};
        }
        if (cache) {
          this.set(cache);
        }
      }
      Emitter(Cache.prototype);
      Cache.prototype.set = function(key, val) {
        if (Array.isArray(key) && arguments.length === 2) {
          key = toPath(key);
        }
        if (isObject(key) || Array.isArray(key)) {
          this.visit("set", key);
        } else {
          set(prop ? this[prop] : this, key, val);
          this.emit("set", key, val);
        }
        return this;
      };
      Cache.prototype.union = function(key, val) {
        if (Array.isArray(key) && arguments.length === 2) {
          key = toPath(key);
        }
        var ctx = prop ? this[prop] : this;
        union(ctx, key, arrayify(val));
        this.emit("union", val);
        return this;
      };
      Cache.prototype.get = function(key) {
        key = toPath(arguments);
        var ctx = prop ? this[prop] : this;
        var val = get(ctx, key);
        this.emit("get", key, val);
        return val;
      };
      Cache.prototype.has = function(key) {
        key = toPath(arguments);
        var ctx = prop ? this[prop] : this;
        var val = get(ctx, key);
        var has2 = typeof val !== "undefined";
        this.emit("has", key, has2);
        return has2;
      };
      Cache.prototype.del = function(key) {
        if (Array.isArray(key)) {
          this.visit("del", key);
        } else {
          del(prop ? this[prop] : this, key);
          this.emit("del", key);
        }
        return this;
      };
      Cache.prototype.clear = function() {
        if (prop) {
          this[prop] = {};
        }
      };
      Cache.prototype.visit = function(method, val) {
        visit(this, method, val);
        return this;
      };
      return Cache;
    }
    function arrayify(val) {
      return val ? Array.isArray(val) ? val : [val] : [];
    }
    module2.exports = namespace();
    module2.exports.namespace = namespace;
  }
});

// node_modules/mixin-deep/node_modules/is-extendable/index.js
var require_is_extendable5 = __commonJS({
  "node_modules/mixin-deep/node_modules/is-extendable/index.js"(exports, module2) {
    "use strict";
    var isPlainObject = require_is_plain_object();
    module2.exports = function isExtendable(val) {
      return isPlainObject(val) || typeof val === "function" || Array.isArray(val);
    };
  }
});

// node_modules/for-in/index.js
var require_for_in = __commonJS({
  "node_modules/for-in/index.js"(exports, module2) {
    "use strict";
    module2.exports = function forIn(obj, fn, thisArg) {
      for (var key in obj) {
        if (fn.call(thisArg, obj[key], key, obj) === false) {
          break;
        }
      }
    };
  }
});

// node_modules/mixin-deep/index.js
var require_mixin_deep = __commonJS({
  "node_modules/mixin-deep/index.js"(exports, module2) {
    "use strict";
    var isExtendable = require_is_extendable5();
    var forIn = require_for_in();
    function mixinDeep(target, objects) {
      var len = arguments.length, i = 0;
      while (++i < len) {
        var obj = arguments[i];
        if (isObject(obj)) {
          forIn(obj, copy, target);
        }
      }
      return target;
    }
    function copy(val, key) {
      if (!isValidKey(key)) {
        return;
      }
      var obj = this[key];
      if (isObject(val) && isObject(obj)) {
        mixinDeep(obj, val);
      } else {
        this[key] = val;
      }
    }
    function isObject(val) {
      return isExtendable(val) && !Array.isArray(val);
    }
    function isValidKey(key) {
      return key !== "__proto__" && key !== "constructor" && key !== "prototype";
    }
    module2.exports = mixinDeep;
  }
});

// node_modules/pascalcase/index.js
var require_pascalcase = __commonJS({
  "node_modules/pascalcase/index.js"(exports, module2) {
    function pascalcase(str) {
      if (typeof str !== "string") {
        throw new TypeError("expected a string.");
      }
      str = str.replace(/([A-Z])/g, " $1");
      if (str.length === 1) {
        return str.toUpperCase();
      }
      str = str.replace(/^[\W_]+|[\W_]+$/g, "").toLowerCase();
      str = str.charAt(0).toUpperCase() + str.slice(1);
      return str.replace(/[\W_]+(\w|$)/g, function(_, ch) {
        return ch.toUpperCase();
      });
    }
    module2.exports = pascalcase;
  }
});

// node_modules/class-utils/node_modules/is-descriptor/node_modules/kind-of/index.js
var require_kind_of6 = __commonJS({
  "node_modules/class-utils/node_modules/is-descriptor/node_modules/kind-of/index.js"(exports, module2) {
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      var type = typeof val;
      if (type === "undefined") {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }
      if (val === true || val === false || val instanceof Boolean) {
        return "boolean";
      }
      if (type === "string" || val instanceof String) {
        return "string";
      }
      if (type === "number" || val instanceof Number) {
        return "number";
      }
      if (type === "function" || val instanceof Function) {
        if (typeof val.constructor.name !== "undefined" && val.constructor.name.slice(0, 9) === "Generator") {
          return "generatorfunction";
        }
        return "function";
      }
      if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
        return "array";
      }
      if (val instanceof RegExp) {
        return "regexp";
      }
      if (val instanceof Date) {
        return "date";
      }
      type = toString.call(val);
      if (type === "[object RegExp]") {
        return "regexp";
      }
      if (type === "[object Date]") {
        return "date";
      }
      if (type === "[object Arguments]") {
        return "arguments";
      }
      if (type === "[object Error]") {
        return "error";
      }
      if (type === "[object Promise]") {
        return "promise";
      }
      if (isBuffer(val)) {
        return "buffer";
      }
      if (type === "[object Set]") {
        return "set";
      }
      if (type === "[object WeakSet]") {
        return "weakset";
      }
      if (type === "[object Map]") {
        return "map";
      }
      if (type === "[object WeakMap]") {
        return "weakmap";
      }
      if (type === "[object Symbol]") {
        return "symbol";
      }
      if (type === "[object Map Iterator]") {
        return "mapiterator";
      }
      if (type === "[object Set Iterator]") {
        return "setiterator";
      }
      if (type === "[object String Iterator]") {
        return "stringiterator";
      }
      if (type === "[object Array Iterator]") {
        return "arrayiterator";
      }
      if (type === "[object Int8Array]") {
        return "int8array";
      }
      if (type === "[object Uint8Array]") {
        return "uint8array";
      }
      if (type === "[object Uint8ClampedArray]") {
        return "uint8clampedarray";
      }
      if (type === "[object Int16Array]") {
        return "int16array";
      }
      if (type === "[object Uint16Array]") {
        return "uint16array";
      }
      if (type === "[object Int32Array]") {
        return "int32array";
      }
      if (type === "[object Uint32Array]") {
        return "uint32array";
      }
      if (type === "[object Float32Array]") {
        return "float32array";
      }
      if (type === "[object Float64Array]") {
        return "float64array";
      }
      return "object";
    };
    function isBuffer(val) {
      return val.constructor && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
  }
});

// node_modules/class-utils/node_modules/is-accessor-descriptor/index.js
var require_is_accessor_descriptor2 = __commonJS({
  "node_modules/class-utils/node_modules/is-accessor-descriptor/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of4();
    var accessor = {
      get: "function",
      set: "function",
      configurable: "boolean",
      enumerable: "boolean"
    };
    function isAccessorDescriptor(obj, prop) {
      if (typeof prop === "string") {
        var val = Object.getOwnPropertyDescriptor(obj, prop);
        return typeof val !== "undefined";
      }
      if (typeOf(obj) !== "object") {
        return false;
      }
      if (has(obj, "value") || has(obj, "writable")) {
        return false;
      }
      if (!has(obj, "get") || typeof obj.get !== "function") {
        return false;
      }
      if (has(obj, "set") && typeof obj[key] !== "function" && typeof obj[key] !== "undefined") {
        return false;
      }
      for (var key in obj) {
        if (!accessor.hasOwnProperty(key)) {
          continue;
        }
        if (typeOf(obj[key]) === accessor[key]) {
          continue;
        }
        if (typeof obj[key] !== "undefined") {
          return false;
        }
      }
      return true;
    }
    function has(obj, key) {
      return {}.hasOwnProperty.call(obj, key);
    }
    module2.exports = isAccessorDescriptor;
  }
});

// node_modules/class-utils/node_modules/is-data-descriptor/index.js
var require_is_data_descriptor2 = __commonJS({
  "node_modules/class-utils/node_modules/is-data-descriptor/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of4();
    var data = {
      configurable: "boolean",
      enumerable: "boolean",
      writable: "boolean"
    };
    function isDataDescriptor(obj, prop) {
      if (typeOf(obj) !== "object") {
        return false;
      }
      if (typeof prop === "string") {
        var val = Object.getOwnPropertyDescriptor(obj, prop);
        return typeof val !== "undefined";
      }
      if (!("value" in obj) && !("writable" in obj)) {
        return false;
      }
      for (var key in obj) {
        if (key === "value")
          continue;
        if (!data.hasOwnProperty(key)) {
          continue;
        }
        if (typeOf(obj[key]) === data[key]) {
          continue;
        }
        if (typeof obj[key] !== "undefined") {
          return false;
        }
      }
      return true;
    }
    module2.exports = isDataDescriptor;
  }
});

// node_modules/class-utils/node_modules/is-descriptor/index.js
var require_is_descriptor2 = __commonJS({
  "node_modules/class-utils/node_modules/is-descriptor/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of6();
    var isAccessor = require_is_accessor_descriptor2();
    var isData = require_is_data_descriptor2();
    module2.exports = function isDescriptor(obj, key) {
      if (typeOf(obj) !== "object") {
        return false;
      }
      if ("get" in obj) {
        return isAccessor(obj, key);
      }
      return isData(obj, key);
    };
  }
});

// node_modules/class-utils/node_modules/define-property/index.js
var require_define_property4 = __commonJS({
  "node_modules/class-utils/node_modules/define-property/index.js"(exports, module2) {
    "use strict";
    var isDescriptor = require_is_descriptor2();
    module2.exports = function defineProperty(obj, prop, val) {
      if (typeof obj !== "object" && typeof obj !== "function") {
        throw new TypeError("expected an object or function.");
      }
      if (typeof prop !== "string") {
        throw new TypeError("expected `prop` to be a string.");
      }
      if (isDescriptor(val) && ("set" in val || "get" in val)) {
        return Object.defineProperty(obj, prop, val);
      }
      return Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val
      });
    };
  }
});

// node_modules/copy-descriptor/index.js
var require_copy_descriptor = __commonJS({
  "node_modules/copy-descriptor/index.js"(exports, module2) {
    "use strict";
    module2.exports = function copyDescriptor(receiver, provider, from, to) {
      if (!isObject(provider) && typeof provider !== "function") {
        to = from;
        from = provider;
        provider = receiver;
      }
      if (!isObject(receiver) && typeof receiver !== "function") {
        throw new TypeError("expected the first argument to be an object");
      }
      if (!isObject(provider) && typeof provider !== "function") {
        throw new TypeError("expected provider to be an object");
      }
      if (typeof to !== "string") {
        to = from;
      }
      if (typeof from !== "string") {
        throw new TypeError("expected key to be a string");
      }
      if (!(from in provider)) {
        throw new Error('property "' + from + '" does not exist');
      }
      var val = Object.getOwnPropertyDescriptor(provider, from);
      if (val)
        Object.defineProperty(receiver, to, val);
    };
    function isObject(val) {
      return {}.toString.call(val) === "[object Object]";
    }
  }
});

// node_modules/object-copy/node_modules/is-descriptor/node_modules/kind-of/index.js
var require_kind_of7 = __commonJS({
  "node_modules/object-copy/node_modules/is-descriptor/node_modules/kind-of/index.js"(exports, module2) {
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      var type = typeof val;
      if (type === "undefined") {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }
      if (val === true || val === false || val instanceof Boolean) {
        return "boolean";
      }
      if (type === "string" || val instanceof String) {
        return "string";
      }
      if (type === "number" || val instanceof Number) {
        return "number";
      }
      if (type === "function" || val instanceof Function) {
        if (typeof val.constructor.name !== "undefined" && val.constructor.name.slice(0, 9) === "Generator") {
          return "generatorfunction";
        }
        return "function";
      }
      if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
        return "array";
      }
      if (val instanceof RegExp) {
        return "regexp";
      }
      if (val instanceof Date) {
        return "date";
      }
      type = toString.call(val);
      if (type === "[object RegExp]") {
        return "regexp";
      }
      if (type === "[object Date]") {
        return "date";
      }
      if (type === "[object Arguments]") {
        return "arguments";
      }
      if (type === "[object Error]") {
        return "error";
      }
      if (type === "[object Promise]") {
        return "promise";
      }
      if (isBuffer(val)) {
        return "buffer";
      }
      if (type === "[object Set]") {
        return "set";
      }
      if (type === "[object WeakSet]") {
        return "weakset";
      }
      if (type === "[object Map]") {
        return "map";
      }
      if (type === "[object WeakMap]") {
        return "weakmap";
      }
      if (type === "[object Symbol]") {
        return "symbol";
      }
      if (type === "[object Map Iterator]") {
        return "mapiterator";
      }
      if (type === "[object Set Iterator]") {
        return "setiterator";
      }
      if (type === "[object String Iterator]") {
        return "stringiterator";
      }
      if (type === "[object Array Iterator]") {
        return "arrayiterator";
      }
      if (type === "[object Int8Array]") {
        return "int8array";
      }
      if (type === "[object Uint8Array]") {
        return "uint8array";
      }
      if (type === "[object Uint8ClampedArray]") {
        return "uint8clampedarray";
      }
      if (type === "[object Int16Array]") {
        return "int16array";
      }
      if (type === "[object Uint16Array]") {
        return "uint16array";
      }
      if (type === "[object Int32Array]") {
        return "int32array";
      }
      if (type === "[object Uint32Array]") {
        return "uint32array";
      }
      if (type === "[object Float32Array]") {
        return "float32array";
      }
      if (type === "[object Float64Array]") {
        return "float64array";
      }
      return "object";
    };
    function isBuffer(val) {
      return val.constructor && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
  }
});

// node_modules/object-copy/node_modules/is-accessor-descriptor/index.js
var require_is_accessor_descriptor3 = __commonJS({
  "node_modules/object-copy/node_modules/is-accessor-descriptor/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of4();
    var accessor = {
      get: "function",
      set: "function",
      configurable: "boolean",
      enumerable: "boolean"
    };
    function isAccessorDescriptor(obj, prop) {
      if (typeof prop === "string") {
        var val = Object.getOwnPropertyDescriptor(obj, prop);
        return typeof val !== "undefined";
      }
      if (typeOf(obj) !== "object") {
        return false;
      }
      if (has(obj, "value") || has(obj, "writable")) {
        return false;
      }
      if (!has(obj, "get") || typeof obj.get !== "function") {
        return false;
      }
      if (has(obj, "set") && typeof obj[key] !== "function" && typeof obj[key] !== "undefined") {
        return false;
      }
      for (var key in obj) {
        if (!accessor.hasOwnProperty(key)) {
          continue;
        }
        if (typeOf(obj[key]) === accessor[key]) {
          continue;
        }
        if (typeof obj[key] !== "undefined") {
          return false;
        }
      }
      return true;
    }
    function has(obj, key) {
      return {}.hasOwnProperty.call(obj, key);
    }
    module2.exports = isAccessorDescriptor;
  }
});

// node_modules/object-copy/node_modules/is-data-descriptor/index.js
var require_is_data_descriptor3 = __commonJS({
  "node_modules/object-copy/node_modules/is-data-descriptor/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of4();
    var data = {
      configurable: "boolean",
      enumerable: "boolean",
      writable: "boolean"
    };
    function isDataDescriptor(obj, prop) {
      if (typeOf(obj) !== "object") {
        return false;
      }
      if (typeof prop === "string") {
        var val = Object.getOwnPropertyDescriptor(obj, prop);
        return typeof val !== "undefined";
      }
      if (!("value" in obj) && !("writable" in obj)) {
        return false;
      }
      for (var key in obj) {
        if (key === "value")
          continue;
        if (!data.hasOwnProperty(key)) {
          continue;
        }
        if (typeOf(obj[key]) === data[key]) {
          continue;
        }
        if (typeof obj[key] !== "undefined") {
          return false;
        }
      }
      return true;
    }
    module2.exports = isDataDescriptor;
  }
});

// node_modules/object-copy/node_modules/is-descriptor/index.js
var require_is_descriptor3 = __commonJS({
  "node_modules/object-copy/node_modules/is-descriptor/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of7();
    var isAccessor = require_is_accessor_descriptor3();
    var isData = require_is_data_descriptor3();
    module2.exports = function isDescriptor(obj, key) {
      if (typeOf(obj) !== "object") {
        return false;
      }
      if ("get" in obj) {
        return isAccessor(obj, key);
      }
      return isData(obj, key);
    };
  }
});

// node_modules/object-copy/node_modules/define-property/index.js
var require_define_property5 = __commonJS({
  "node_modules/object-copy/node_modules/define-property/index.js"(exports, module2) {
    "use strict";
    var isDescriptor = require_is_descriptor3();
    module2.exports = function defineProperty(obj, prop, val) {
      if (typeof obj !== "object" && typeof obj !== "function") {
        throw new TypeError("expected an object or function.");
      }
      if (typeof prop !== "string") {
        throw new TypeError("expected `prop` to be a string.");
      }
      if (isDescriptor(val) && ("set" in val || "get" in val)) {
        return Object.defineProperty(obj, prop, val);
      }
      return Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val
      });
    };
  }
});

// node_modules/object-copy/index.js
var require_object_copy = __commonJS({
  "node_modules/object-copy/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of4();
    var copyDescriptor = require_copy_descriptor();
    var define2 = require_define_property5();
    function copy(receiver, provider, omit) {
      if (!isObject(receiver)) {
        throw new TypeError("expected receiving object to be an object.");
      }
      if (!isObject(provider)) {
        throw new TypeError("expected providing object to be an object.");
      }
      var props = nativeKeys(provider);
      var keys = Object.keys(provider);
      var len = props.length;
      omit = arrayify(omit);
      while (len--) {
        var key = props[len];
        if (has(keys, key)) {
          define2(receiver, key, provider[key]);
        } else if (!(key in receiver) && !has(omit, key)) {
          copyDescriptor(receiver, provider, key);
        }
      }
    }
    function isObject(val) {
      return typeOf(val) === "object" || typeof val === "function";
    }
    function has(obj, val) {
      val = arrayify(val);
      var len = val.length;
      if (isObject(obj)) {
        for (var key in obj) {
          if (val.indexOf(key) > -1) {
            return true;
          }
        }
        var keys = nativeKeys(obj);
        return has(keys, val);
      }
      if (Array.isArray(obj)) {
        var arr = obj;
        while (len--) {
          if (arr.indexOf(val[len]) > -1) {
            return true;
          }
        }
        return false;
      }
      throw new TypeError("expected an array or object.");
    }
    function arrayify(val) {
      return val ? Array.isArray(val) ? val : [val] : [];
    }
    function hasConstructor(val) {
      return isObject(val) && typeof val.constructor !== "undefined";
    }
    function nativeKeys(val) {
      if (!hasConstructor(val))
        return [];
      return Object.getOwnPropertyNames(val);
    }
    module2.exports = copy;
    module2.exports.has = has;
  }
});

// node_modules/static-extend/node_modules/is-descriptor/node_modules/kind-of/index.js
var require_kind_of8 = __commonJS({
  "node_modules/static-extend/node_modules/is-descriptor/node_modules/kind-of/index.js"(exports, module2) {
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      var type = typeof val;
      if (type === "undefined") {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }
      if (val === true || val === false || val instanceof Boolean) {
        return "boolean";
      }
      if (type === "string" || val instanceof String) {
        return "string";
      }
      if (type === "number" || val instanceof Number) {
        return "number";
      }
      if (type === "function" || val instanceof Function) {
        if (typeof val.constructor.name !== "undefined" && val.constructor.name.slice(0, 9) === "Generator") {
          return "generatorfunction";
        }
        return "function";
      }
      if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
        return "array";
      }
      if (val instanceof RegExp) {
        return "regexp";
      }
      if (val instanceof Date) {
        return "date";
      }
      type = toString.call(val);
      if (type === "[object RegExp]") {
        return "regexp";
      }
      if (type === "[object Date]") {
        return "date";
      }
      if (type === "[object Arguments]") {
        return "arguments";
      }
      if (type === "[object Error]") {
        return "error";
      }
      if (type === "[object Promise]") {
        return "promise";
      }
      if (isBuffer(val)) {
        return "buffer";
      }
      if (type === "[object Set]") {
        return "set";
      }
      if (type === "[object WeakSet]") {
        return "weakset";
      }
      if (type === "[object Map]") {
        return "map";
      }
      if (type === "[object WeakMap]") {
        return "weakmap";
      }
      if (type === "[object Symbol]") {
        return "symbol";
      }
      if (type === "[object Map Iterator]") {
        return "mapiterator";
      }
      if (type === "[object Set Iterator]") {
        return "setiterator";
      }
      if (type === "[object String Iterator]") {
        return "stringiterator";
      }
      if (type === "[object Array Iterator]") {
        return "arrayiterator";
      }
      if (type === "[object Int8Array]") {
        return "int8array";
      }
      if (type === "[object Uint8Array]") {
        return "uint8array";
      }
      if (type === "[object Uint8ClampedArray]") {
        return "uint8clampedarray";
      }
      if (type === "[object Int16Array]") {
        return "int16array";
      }
      if (type === "[object Uint16Array]") {
        return "uint16array";
      }
      if (type === "[object Int32Array]") {
        return "int32array";
      }
      if (type === "[object Uint32Array]") {
        return "uint32array";
      }
      if (type === "[object Float32Array]") {
        return "float32array";
      }
      if (type === "[object Float64Array]") {
        return "float64array";
      }
      return "object";
    };
    function isBuffer(val) {
      return val.constructor && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
  }
});

// node_modules/static-extend/node_modules/is-accessor-descriptor/index.js
var require_is_accessor_descriptor4 = __commonJS({
  "node_modules/static-extend/node_modules/is-accessor-descriptor/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of4();
    var accessor = {
      get: "function",
      set: "function",
      configurable: "boolean",
      enumerable: "boolean"
    };
    function isAccessorDescriptor(obj, prop) {
      if (typeof prop === "string") {
        var val = Object.getOwnPropertyDescriptor(obj, prop);
        return typeof val !== "undefined";
      }
      if (typeOf(obj) !== "object") {
        return false;
      }
      if (has(obj, "value") || has(obj, "writable")) {
        return false;
      }
      if (!has(obj, "get") || typeof obj.get !== "function") {
        return false;
      }
      if (has(obj, "set") && typeof obj[key] !== "function" && typeof obj[key] !== "undefined") {
        return false;
      }
      for (var key in obj) {
        if (!accessor.hasOwnProperty(key)) {
          continue;
        }
        if (typeOf(obj[key]) === accessor[key]) {
          continue;
        }
        if (typeof obj[key] !== "undefined") {
          return false;
        }
      }
      return true;
    }
    function has(obj, key) {
      return {}.hasOwnProperty.call(obj, key);
    }
    module2.exports = isAccessorDescriptor;
  }
});

// node_modules/static-extend/node_modules/is-data-descriptor/index.js
var require_is_data_descriptor4 = __commonJS({
  "node_modules/static-extend/node_modules/is-data-descriptor/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of4();
    var data = {
      configurable: "boolean",
      enumerable: "boolean",
      writable: "boolean"
    };
    function isDataDescriptor(obj, prop) {
      if (typeOf(obj) !== "object") {
        return false;
      }
      if (typeof prop === "string") {
        var val = Object.getOwnPropertyDescriptor(obj, prop);
        return typeof val !== "undefined";
      }
      if (!("value" in obj) && !("writable" in obj)) {
        return false;
      }
      for (var key in obj) {
        if (key === "value")
          continue;
        if (!data.hasOwnProperty(key)) {
          continue;
        }
        if (typeOf(obj[key]) === data[key]) {
          continue;
        }
        if (typeof obj[key] !== "undefined") {
          return false;
        }
      }
      return true;
    }
    module2.exports = isDataDescriptor;
  }
});

// node_modules/static-extend/node_modules/is-descriptor/index.js
var require_is_descriptor4 = __commonJS({
  "node_modules/static-extend/node_modules/is-descriptor/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of8();
    var isAccessor = require_is_accessor_descriptor4();
    var isData = require_is_data_descriptor4();
    module2.exports = function isDescriptor(obj, key) {
      if (typeOf(obj) !== "object") {
        return false;
      }
      if ("get" in obj) {
        return isAccessor(obj, key);
      }
      return isData(obj, key);
    };
  }
});

// node_modules/static-extend/node_modules/define-property/index.js
var require_define_property6 = __commonJS({
  "node_modules/static-extend/node_modules/define-property/index.js"(exports, module2) {
    "use strict";
    var isDescriptor = require_is_descriptor4();
    module2.exports = function defineProperty(obj, prop, val) {
      if (typeof obj !== "object" && typeof obj !== "function") {
        throw new TypeError("expected an object or function.");
      }
      if (typeof prop !== "string") {
        throw new TypeError("expected `prop` to be a string.");
      }
      if (isDescriptor(val) && ("set" in val || "get" in val)) {
        return Object.defineProperty(obj, prop, val);
      }
      return Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val
      });
    };
  }
});

// node_modules/static-extend/index.js
var require_static_extend = __commonJS({
  "node_modules/static-extend/index.js"(exports, module2) {
    "use strict";
    var copy = require_object_copy();
    var define2 = require_define_property6();
    var util = require("util");
    function extend(Parent, extendFn) {
      if (typeof Parent !== "function") {
        throw new TypeError("expected Parent to be a function.");
      }
      return function(Ctor, proto) {
        if (typeof Ctor !== "function") {
          throw new TypeError("expected Ctor to be a function.");
        }
        util.inherits(Ctor, Parent);
        copy(Ctor, Parent);
        if (typeof proto === "object") {
          var obj = Object.create(proto);
          for (var k in obj) {
            Ctor.prototype[k] = obj[k];
          }
        }
        define2(Ctor.prototype, "_parent_", {
          configurable: true,
          set: function() {
          },
          get: function() {
            return Parent.prototype;
          }
        });
        if (typeof extendFn === "function") {
          extendFn(Ctor, Parent);
        }
        Ctor.extend = extend(Ctor, extendFn);
      };
    }
    module2.exports = extend;
  }
});

// node_modules/class-utils/index.js
var require_class_utils = __commonJS({
  "node_modules/class-utils/index.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var union = require_arr_union();
    var define2 = require_define_property4();
    var staticExtend = require_static_extend();
    var isObj = require_isobject();
    var cu = module2.exports;
    cu.isObject = function isObject(val) {
      return isObj(val) || typeof val === "function";
    };
    cu.has = function has(obj, val) {
      val = cu.arrayify(val);
      var len = val.length;
      if (cu.isObject(obj)) {
        for (var key in obj) {
          if (val.indexOf(key) > -1) {
            return true;
          }
        }
        var keys = cu.nativeKeys(obj);
        return cu.has(keys, val);
      }
      if (Array.isArray(obj)) {
        var arr = obj;
        while (len--) {
          if (arr.indexOf(val[len]) > -1) {
            return true;
          }
        }
        return false;
      }
      throw new TypeError("expected an array or object.");
    };
    cu.hasAll = function hasAll(val, values) {
      values = cu.arrayify(values);
      var len = values.length;
      while (len--) {
        if (!cu.has(val, values[len])) {
          return false;
        }
      }
      return true;
    };
    cu.arrayify = function arrayify(val) {
      return val ? Array.isArray(val) ? val : [val] : [];
    };
    cu.noop = function noop() {
      return;
    };
    cu.identity = function identity(val) {
      return val;
    };
    cu.hasConstructor = function hasConstructor(val) {
      return cu.isObject(val) && typeof val.constructor !== "undefined";
    };
    cu.nativeKeys = function nativeKeys(val) {
      if (!cu.hasConstructor(val))
        return [];
      var keys = Object.getOwnPropertyNames(val);
      if ("caller" in val)
        keys.push("caller");
      return keys;
    };
    cu.getDescriptor = function getDescriptor(obj, key) {
      if (!cu.isObject(obj)) {
        throw new TypeError("expected an object.");
      }
      if (typeof key !== "string") {
        throw new TypeError("expected key to be a string.");
      }
      return Object.getOwnPropertyDescriptor(obj, key);
    };
    cu.copyDescriptor = function copyDescriptor(receiver, provider, name) {
      if (!cu.isObject(receiver)) {
        throw new TypeError("expected receiving object to be an object.");
      }
      if (!cu.isObject(provider)) {
        throw new TypeError("expected providing object to be an object.");
      }
      if (typeof name !== "string") {
        throw new TypeError("expected name to be a string.");
      }
      var val = cu.getDescriptor(provider, name);
      if (val)
        Object.defineProperty(receiver, name, val);
    };
    cu.copy = function copy(receiver, provider, omit) {
      if (!cu.isObject(receiver)) {
        throw new TypeError("expected receiving object to be an object.");
      }
      if (!cu.isObject(provider)) {
        throw new TypeError("expected providing object to be an object.");
      }
      var props = Object.getOwnPropertyNames(provider);
      var keys = Object.keys(provider);
      var len = props.length, key;
      omit = cu.arrayify(omit);
      while (len--) {
        key = props[len];
        if (cu.has(keys, key)) {
          define2(receiver, key, provider[key]);
        } else if (!(key in receiver) && !cu.has(omit, key)) {
          cu.copyDescriptor(receiver, provider, key);
        }
      }
    };
    cu.inherit = function inherit(receiver, provider, omit) {
      if (!cu.isObject(receiver)) {
        throw new TypeError("expected receiving object to be an object.");
      }
      if (!cu.isObject(provider)) {
        throw new TypeError("expected providing object to be an object.");
      }
      var keys = [];
      for (var key in provider) {
        keys.push(key);
        receiver[key] = provider[key];
      }
      keys = keys.concat(cu.arrayify(omit));
      var a = provider.prototype || provider;
      var b = receiver.prototype || receiver;
      cu.copy(b, a, keys);
    };
    cu.extend = function() {
      return staticExtend.apply(null, arguments);
    };
    cu.bubble = function(Parent, events) {
      events = events || [];
      Parent.bubble = function(Child, arr) {
        if (Array.isArray(arr)) {
          events = union([], events, arr);
        }
        var len = events.length;
        var idx = -1;
        while (++idx < len) {
          var name = events[idx];
          Parent.on(name, Child.emit.bind(Child, name));
        }
        cu.bubble(Child, events);
      };
    };
  }
});

// node_modules/base/index.js
var require_base = __commonJS({
  "node_modules/base/index.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var define2 = require_define_property3();
    var CacheBase = require_cache_base();
    var Emitter = require_component_emitter();
    var isObject = require_isobject();
    var merge = require_mixin_deep();
    var pascal = require_pascalcase();
    var cu = require_class_utils();
    function namespace(name) {
      var Cache = name ? CacheBase.namespace(name) : CacheBase;
      var fns = [];
      function Base(config, options) {
        if (!(this instanceof Base)) {
          return new Base(config, options);
        }
        Cache.call(this, config);
        this.is("base");
        this.initBase(config, options);
      }
      util.inherits(Base, Cache);
      Emitter(Base);
      Base.prototype.initBase = function(config, options) {
        this.options = merge({}, this.options, options);
        this.cache = this.cache || {};
        this.define("registered", {});
        if (name)
          this[name] = {};
        this.define("_callbacks", this._callbacks);
        if (isObject(config)) {
          this.visit("set", config);
        }
        Base.run(this, "use", fns);
      };
      Base.prototype.is = function(name2) {
        if (typeof name2 !== "string") {
          throw new TypeError("expected name to be a string");
        }
        this.define("is" + pascal(name2), true);
        this.define("_name", name2);
        this.define("_appname", name2);
        return this;
      };
      Base.prototype.isRegistered = function(name2, register) {
        if (this.registered.hasOwnProperty(name2)) {
          return true;
        }
        if (register !== false) {
          this.registered[name2] = true;
          this.emit("plugin", name2);
        }
        return false;
      };
      Base.prototype.use = function(fn) {
        fn.call(this, this);
        return this;
      };
      Base.prototype.define = function(key, val) {
        if (isObject(key)) {
          return this.visit("define", key);
        }
        define2(this, key, val);
        return this;
      };
      Base.prototype.mixin = function(key, val) {
        Base.prototype[key] = val;
        return this;
      };
      Base.prototype.mixins = Base.prototype.mixins || [];
      Object.defineProperty(Base.prototype, "base", {
        configurable: true,
        get: function() {
          return this.parent ? this.parent.base : this;
        }
      });
      define2(Base, "use", function(fn) {
        fns.push(fn);
        return Base;
      });
      define2(Base, "run", function(obj, prop, arr) {
        var len = arr.length, i = 0;
        while (len--) {
          obj[prop](arr[i++]);
        }
        return Base;
      });
      define2(Base, "extend", cu.extend(Base, function(Ctor, Parent) {
        Ctor.prototype.mixins = Ctor.prototype.mixins || [];
        define2(Ctor, "mixin", function(fn) {
          var mixin = fn(Ctor.prototype, Ctor);
          if (typeof mixin === "function") {
            Ctor.prototype.mixins.push(mixin);
          }
          return Ctor;
        });
        define2(Ctor, "mixins", function(Child) {
          Base.run(Child, "mixin", Ctor.prototype.mixins);
          return Ctor;
        });
        Ctor.prototype.mixin = function(key, value) {
          Ctor.prototype[key] = value;
          return this;
        };
        return Base;
      }));
      define2(Base, "mixin", function(fn) {
        var mixin = fn(Base.prototype, Base);
        if (typeof mixin === "function") {
          Base.prototype.mixins.push(mixin);
        }
        return Base;
      });
      define2(Base, "mixins", function(Child) {
        Base.run(Child, "mixin", Base.prototype.mixins);
        return Base;
      });
      define2(Base, "inherit", cu.inherit);
      define2(Base, "bubble", cu.bubble);
      return Base;
    }
    module2.exports = namespace();
    module2.exports.namespace = namespace;
  }
});

// node_modules/snapdragon/node_modules/is-descriptor/node_modules/kind-of/index.js
var require_kind_of9 = __commonJS({
  "node_modules/snapdragon/node_modules/is-descriptor/node_modules/kind-of/index.js"(exports, module2) {
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      var type = typeof val;
      if (type === "undefined") {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }
      if (val === true || val === false || val instanceof Boolean) {
        return "boolean";
      }
      if (type === "string" || val instanceof String) {
        return "string";
      }
      if (type === "number" || val instanceof Number) {
        return "number";
      }
      if (type === "function" || val instanceof Function) {
        if (typeof val.constructor.name !== "undefined" && val.constructor.name.slice(0, 9) === "Generator") {
          return "generatorfunction";
        }
        return "function";
      }
      if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
        return "array";
      }
      if (val instanceof RegExp) {
        return "regexp";
      }
      if (val instanceof Date) {
        return "date";
      }
      type = toString.call(val);
      if (type === "[object RegExp]") {
        return "regexp";
      }
      if (type === "[object Date]") {
        return "date";
      }
      if (type === "[object Arguments]") {
        return "arguments";
      }
      if (type === "[object Error]") {
        return "error";
      }
      if (type === "[object Promise]") {
        return "promise";
      }
      if (isBuffer(val)) {
        return "buffer";
      }
      if (type === "[object Set]") {
        return "set";
      }
      if (type === "[object WeakSet]") {
        return "weakset";
      }
      if (type === "[object Map]") {
        return "map";
      }
      if (type === "[object WeakMap]") {
        return "weakmap";
      }
      if (type === "[object Symbol]") {
        return "symbol";
      }
      if (type === "[object Map Iterator]") {
        return "mapiterator";
      }
      if (type === "[object Set Iterator]") {
        return "setiterator";
      }
      if (type === "[object String Iterator]") {
        return "stringiterator";
      }
      if (type === "[object Array Iterator]") {
        return "arrayiterator";
      }
      if (type === "[object Int8Array]") {
        return "int8array";
      }
      if (type === "[object Uint8Array]") {
        return "uint8array";
      }
      if (type === "[object Uint8ClampedArray]") {
        return "uint8clampedarray";
      }
      if (type === "[object Int16Array]") {
        return "int16array";
      }
      if (type === "[object Uint16Array]") {
        return "uint16array";
      }
      if (type === "[object Int32Array]") {
        return "int32array";
      }
      if (type === "[object Uint32Array]") {
        return "uint32array";
      }
      if (type === "[object Float32Array]") {
        return "float32array";
      }
      if (type === "[object Float64Array]") {
        return "float64array";
      }
      return "object";
    };
    function isBuffer(val) {
      return val.constructor && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
  }
});

// node_modules/snapdragon/node_modules/is-accessor-descriptor/index.js
var require_is_accessor_descriptor5 = __commonJS({
  "node_modules/snapdragon/node_modules/is-accessor-descriptor/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of4();
    var accessor = {
      get: "function",
      set: "function",
      configurable: "boolean",
      enumerable: "boolean"
    };
    function isAccessorDescriptor(obj, prop) {
      if (typeof prop === "string") {
        var val = Object.getOwnPropertyDescriptor(obj, prop);
        return typeof val !== "undefined";
      }
      if (typeOf(obj) !== "object") {
        return false;
      }
      if (has(obj, "value") || has(obj, "writable")) {
        return false;
      }
      if (!has(obj, "get") || typeof obj.get !== "function") {
        return false;
      }
      if (has(obj, "set") && typeof obj[key] !== "function" && typeof obj[key] !== "undefined") {
        return false;
      }
      for (var key in obj) {
        if (!accessor.hasOwnProperty(key)) {
          continue;
        }
        if (typeOf(obj[key]) === accessor[key]) {
          continue;
        }
        if (typeof obj[key] !== "undefined") {
          return false;
        }
      }
      return true;
    }
    function has(obj, key) {
      return {}.hasOwnProperty.call(obj, key);
    }
    module2.exports = isAccessorDescriptor;
  }
});

// node_modules/snapdragon/node_modules/is-data-descriptor/index.js
var require_is_data_descriptor5 = __commonJS({
  "node_modules/snapdragon/node_modules/is-data-descriptor/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of4();
    var data = {
      configurable: "boolean",
      enumerable: "boolean",
      writable: "boolean"
    };
    function isDataDescriptor(obj, prop) {
      if (typeOf(obj) !== "object") {
        return false;
      }
      if (typeof prop === "string") {
        var val = Object.getOwnPropertyDescriptor(obj, prop);
        return typeof val !== "undefined";
      }
      if (!("value" in obj) && !("writable" in obj)) {
        return false;
      }
      for (var key in obj) {
        if (key === "value")
          continue;
        if (!data.hasOwnProperty(key)) {
          continue;
        }
        if (typeOf(obj[key]) === data[key]) {
          continue;
        }
        if (typeof obj[key] !== "undefined") {
          return false;
        }
      }
      return true;
    }
    module2.exports = isDataDescriptor;
  }
});

// node_modules/snapdragon/node_modules/is-descriptor/index.js
var require_is_descriptor5 = __commonJS({
  "node_modules/snapdragon/node_modules/is-descriptor/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of9();
    var isAccessor = require_is_accessor_descriptor5();
    var isData = require_is_data_descriptor5();
    module2.exports = function isDescriptor(obj, key) {
      if (typeOf(obj) !== "object") {
        return false;
      }
      if ("get" in obj) {
        return isAccessor(obj, key);
      }
      return isData(obj, key);
    };
  }
});

// node_modules/snapdragon/node_modules/define-property/index.js
var require_define_property7 = __commonJS({
  "node_modules/snapdragon/node_modules/define-property/index.js"(exports, module2) {
    "use strict";
    var isDescriptor = require_is_descriptor5();
    module2.exports = function defineProperty(obj, prop, val) {
      if (typeof obj !== "object" && typeof obj !== "function") {
        throw new TypeError("expected an object or function.");
      }
      if (typeof prop !== "string") {
        throw new TypeError("expected `prop` to be a string.");
      }
      if (isDescriptor(val) && ("set" in val || "get" in val)) {
        return Object.defineProperty(obj, prop, val);
      }
      return Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val
      });
    };
  }
});

// node_modules/use/index.js
var require_use = __commonJS({
  "node_modules/use/index.js"(exports, module2) {
    "use strict";
    module2.exports = function base(app, options) {
      if (!isObject(app) && typeof app !== "function") {
        throw new TypeError("expected an object or function");
      }
      var opts = isObject(options) ? options : {};
      var prop = typeof opts.prop === "string" ? opts.prop : "fns";
      if (!Array.isArray(app[prop])) {
        define2(app, prop, []);
      }
      define2(app, "use", use);
      define2(app, "run", function(val) {
        if (!isObject(val))
          return;
        if (!val.use || !val.run) {
          define2(val, prop, val[prop] || []);
          define2(val, "use", use);
        }
        if (!val[prop] || val[prop].indexOf(base) === -1) {
          val.use(base);
        }
        var self2 = this || app;
        var fns = self2[prop];
        var len = fns.length;
        var idx = -1;
        while (++idx < len) {
          val.use(fns[idx]);
        }
        return val;
      });
      function use(type, fn, options2) {
        var offset = 1;
        if (typeof type === "string" || Array.isArray(type)) {
          fn = wrap(type, fn);
          offset++;
        } else {
          options2 = fn;
          fn = type;
        }
        if (typeof fn !== "function") {
          throw new TypeError("expected a function");
        }
        var self2 = this || app;
        var fns = self2[prop];
        var args = [].slice.call(arguments, offset);
        args.unshift(self2);
        if (typeof opts.hook === "function") {
          opts.hook.apply(self2, args);
        }
        var val = fn.apply(self2, args);
        if (typeof val === "function" && fns.indexOf(val) === -1) {
          fns.push(val);
        }
        return self2;
      }
      function wrap(type, fn) {
        return function plugin() {
          return this.type === type ? fn.apply(this, arguments) : plugin;
        };
      }
      return app;
    };
    function isObject(val) {
      return val && typeof val === "object" && !Array.isArray(val);
    }
    function define2(obj, key, val) {
      Object.defineProperty(obj, key, {
        configurable: true,
        writable: true,
        value: val
      });
    }
  }
});

// node_modules/snapdragon/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/snapdragon/node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/snapdragon/node_modules/debug/src/debug.js
var require_debug = __commonJS({
  "node_modules/snapdragon/node_modules/debug/src/debug.js"(exports, module2) {
    exports = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = require_ms();
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports.colors[Math.abs(hash) % exports.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports.formatters[format];
          if (typeof formatter === "function") {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports.formatArgs.call(self2, args);
        var logFn = debug.log || exports.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports.enabled(namespace);
      debug.useColors = exports.useColors();
      debug.color = selectColor(namespace);
      if (typeof exports.init === "function") {
        exports.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      exports.names = [];
      exports.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// node_modules/snapdragon/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/snapdragon/node_modules/debug/src/browser.js"(exports, module2) {
    exports = module2.exports = require_debug();
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
    exports.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if (match === "%%")
          return;
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (namespaces == null) {
          exports.storage.removeItem("debug");
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// node_modules/snapdragon/node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/snapdragon/node_modules/debug/src/node.js"(exports, module2) {
    var tty = require("tty");
    var util = require("util");
    exports = module2.exports = require_debug();
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.colors = [6, 2, 3, 4, 5, 1];
    exports.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val))
        val = true;
      else if (/^(no|off|false|disabled)$/i.test(val))
        val = false;
      else if (val === "null")
        val = null;
      else
        val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (fd !== 1 && fd !== 2) {
      util.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
    }
    exports.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var prefix = "  \x1B[3" + c + ";1m" + name + " \x1B[0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("\x1B[3" + c + "m+" + exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = new Date().toUTCString() + " " + name + " " + args[0];
      }
    }
    function log() {
      return stream.write(util.format.apply(util, arguments) + "\n");
    }
    function save(namespaces) {
      if (namespaces == null) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream2;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream2 = new tty.WriteStream(fd2);
          stream2._type = "tty";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        case "FILE":
          var fs = require("fs");
          stream2 = new fs.SyncWriteStream(fd2, { autoClose: false });
          stream2._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net = require("net");
          stream2 = new net.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream2.readable = false;
          stream2.read = null;
          stream2._type = "pipe";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream2.fd = fd2;
      stream2._isStdio = true;
      return stream2;
    }
    function init(debug) {
      debug.inspectOpts = {};
      var keys = Object.keys(exports.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    exports.enable(load());
  }
});

// node_modules/snapdragon/node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/snapdragon/node_modules/debug/src/index.js"(exports, module2) {
    if (typeof process !== "undefined" && process.type === "renderer") {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/source-map/lib/base64.js"(exports) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/source-map/lib/base64-vlq.js"(exports) {
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// node_modules/source-map/lib/util.js
var require_util2 = __commonJS({
  "node_modules/source-map/lib/util.js"(exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports.isAbsolute(path);
      var parts = path.split(/\/+/);
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    }
    exports.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports.join = join;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || !!aPath.match(urlRegexp);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = mappingA.source - mappingB.source;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return mappingA.name - mappingB.name;
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = mappingA.source - mappingB.source;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return mappingA.name - mappingB.name;
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  }
});

// node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/source-map/lib/array-set.js"(exports) {
    var util = require_util2();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports.ArraySet = ArraySet;
  }
});

// node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/source-map/lib/mapping-list.js"(exports) {
    var util = require_util2();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports.MappingList = MappingList;
  }
});

// node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/source-map/lib/source-map-generator.js"(exports) {
    var base64VLQ = require_base64_vlq();
    var util = require_util2();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports.SourceMapGenerator = SourceMapGenerator;
  }
});

// node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS({
  "node_modules/source-map/lib/binary-search.js"(exports) {
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  }
});

// node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "node_modules/source-map/lib/quick-sort.js"(exports) {
    function swap(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y];
      ary[y] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator, p, r) {
      if (p < r) {
        var pivotIndex = randomIntInRange(p, r);
        var i = p - 1;
        swap(ary, pivotIndex, r);
        var pivot = ary[r];
        for (var j = p; j < r; j++) {
          if (comparator(ary[j], pivot) <= 0) {
            i += 1;
            swap(ary, i, j);
          }
        }
        swap(ary, i + 1, j);
        var q = i + 1;
        doQuickSort(ary, comparator, p, q - 1);
        doQuickSort(ary, comparator, q + 1, r);
      }
    }
    exports.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
  }
});

// node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "node_modules/source-map/lib/source-map-consumer.js"(exports) {
    var util = require_util2();
    var binarySearch = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap) : new BasicSourceMapConsumer(sourceMap);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        if (source != null && sourceRoot != null) {
          source = util.join(sourceRoot, source);
        }
        return {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, "line");
      var needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }
      if (!this._sources.has(needle.source)) {
        return [];
      }
      needle.source = this._sources.indexOf(needle.source);
      var mappings = [];
      var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        }
      }
      return mappings;
    };
    exports.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
      }
      var version = util.getArg(sourceMap, "version");
      var sources = util.getArg(sourceMap, "sources");
      var names = util.getArg(sourceMap, "names", []);
      var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
      var mappings = util.getArg(sourceMap, "mappings");
      var file = util.getArg(sourceMap, "file", null);
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      sources = sources.map(String).map(util.normalize).map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
      smc.file = aSourceMap._file;
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._sources.toArray().map(function(s) {
          return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
        }, this);
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      while (index < length) {
        if (aStr.charAt(index) === ";") {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index) === ",") {
          index++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);
          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            originalMappings.push(mapping);
          }
        }
      }
      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            if (this.sourceRoot != null) {
              source = util.join(this.sourceRoot, source);
            }
          }
          var name = util.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      if (this.sourceRoot != null) {
        aSource = util.relative(this.sourceRoot, aSource);
      }
      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }
      var url;
      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, "source");
      if (this.sourceRoot != null) {
        source = util.relative(this.sourceRoot, source);
      }
      if (!this._sources.has(source)) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      source = this._sources.indexOf(source);
      var needle = {
        source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
      }
      var version = util.getArg(sourceMap, "version");
      var sections = util.getArg(sourceMap, "sections");
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s) {
        if (s.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset = util.getArg(s, "offset");
        var offsetLine = util.getArg(offset, "line");
        var offsetColumn = util.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;
        return {
          generatedOffset: {
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s, "map"))
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
          for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch.search(needle, this._sections, function(needle2, section2) {
        var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }
        return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
      });
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (section.consumer.sources.indexOf(util.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];
          var source = section.consumer._sources.at(mapping.source);
          if (section.consumer.sourceRoot !== null) {
            source = util.join(section.consumer.sourceRoot, source);
          }
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };
    exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS({
  "node_modules/source-map/lib/source-node.js"(exports) {
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var util = require_util2();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null)
        this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex];
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex];
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node.add(code);
        } else {
          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map };
    };
    exports.SourceNode = SourceNode;
  }
});

// node_modules/source-map/source-map.js
var require_source_map = __commonJS({
  "node_modules/source-map/source-map.js"(exports) {
    exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports.SourceNode = require_source_node().SourceNode;
  }
});

// node_modules/source-map-url/source-map-url.js
var require_source_map_url = __commonJS({
  "node_modules/source-map-url/source-map-url.js"(exports, module2) {
    void function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define(factory);
      } else if (typeof exports === "object") {
        module2.exports = factory();
      } else {
        root.sourceMappingURL = factory();
      }
    }(exports, function() {
      var innerRegex = /[#@] sourceMappingURL=([^\s'"]*)/;
      var regex = RegExp("(?:/\\*(?:\\s*\r?\n(?://)?)?(?:" + innerRegex.source + ")\\s*\\*/|//(?:" + innerRegex.source + "))\\s*");
      return {
        regex,
        _innerRegex: innerRegex,
        getFrom: function(code) {
          var match = code.match(regex);
          return match ? match[1] || match[2] || "" : null;
        },
        existsIn: function(code) {
          return regex.test(code);
        },
        removeFrom: function(code) {
          return code.replace(regex, "");
        },
        insertBefore: function(code, string) {
          var match = code.match(regex);
          if (match) {
            return code.slice(0, match.index) + string + code.slice(match.index);
          } else {
            return code + string;
          }
        }
      };
    });
  }
});

// node_modules/source-map-resolve/lib/resolve-url.js
var require_resolve_url = __commonJS({
  "node_modules/source-map-resolve/lib/resolve-url.js"(exports, module2) {
    var url = require("url");
    function resolveUrl() {
      return Array.prototype.reduce.call(arguments, function(resolved, nextUrl) {
        return url.resolve(resolved, nextUrl);
      });
    }
    module2.exports = resolveUrl;
  }
});

// node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS({
  "node_modules/decode-uri-component/index.js"(exports, module2) {
    "use strict";
    var token = "%[a-f0-9]{2}";
    var singleMatcher = new RegExp(token, "gi");
    var multiMatcher = new RegExp("(" + token + ")+", "gi");
    function decodeComponents(components, split) {
      try {
        return decodeURIComponent(components.join(""));
      } catch (err) {
      }
      if (components.length === 1) {
        return components;
      }
      split = split || 1;
      var left = components.slice(0, split);
      var right = components.slice(split);
      return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }
    function decode(input) {
      try {
        return decodeURIComponent(input);
      } catch (err) {
        var tokens = input.match(singleMatcher);
        for (var i = 1; i < tokens.length; i++) {
          input = decodeComponents(tokens, i).join("");
          tokens = input.match(singleMatcher);
        }
        return input;
      }
    }
    function customDecodeURIComponent(input) {
      var replaceMap = {
        "%FE%FF": "\uFFFD\uFFFD",
        "%FF%FE": "\uFFFD\uFFFD"
      };
      var match = multiMatcher.exec(input);
      while (match) {
        try {
          replaceMap[match[0]] = decodeURIComponent(match[0]);
        } catch (err) {
          var result = decode(match[0]);
          if (result !== match[0]) {
            replaceMap[match[0]] = result;
          }
        }
        match = multiMatcher.exec(input);
      }
      replaceMap["%C2"] = "\uFFFD";
      var entries = Object.keys(replaceMap);
      for (var i = 0; i < entries.length; i++) {
        var key = entries[i];
        input = input.replace(new RegExp(key, "g"), replaceMap[key]);
      }
      return input;
    }
    module2.exports = function(encodedURI) {
      if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
      }
      try {
        encodedURI = encodedURI.replace(/\+/g, " ");
        return decodeURIComponent(encodedURI);
      } catch (err) {
        return customDecodeURIComponent(encodedURI);
      }
    };
  }
});

// node_modules/source-map-resolve/lib/decode-uri-component.js
var require_decode_uri_component2 = __commonJS({
  "node_modules/source-map-resolve/lib/decode-uri-component.js"(exports, module2) {
    var decodeUriComponent = require_decode_uri_component();
    function customDecodeUriComponent(string) {
      return decodeUriComponent(string.replace(/\+/g, "%2B"));
    }
    module2.exports = customDecodeUriComponent;
  }
});

// node_modules/urix/index.js
var require_urix = __commonJS({
  "node_modules/urix/index.js"(exports, module2) {
    var path = require("path");
    function urix(aPath) {
      if (path.sep === "\\") {
        return aPath.replace(/\\/g, "/").replace(/^[a-z]:\/?/i, "/");
      }
      return aPath;
    }
    module2.exports = urix;
  }
});

// node_modules/atob/node-atob.js
var require_node_atob = __commonJS({
  "node_modules/atob/node-atob.js"(exports, module2) {
    "use strict";
    function atob(str) {
      return Buffer.from(str, "base64").toString("binary");
    }
    module2.exports = atob.atob = atob;
  }
});

// node_modules/source-map-resolve/lib/source-map-resolve-node.js
var require_source_map_resolve_node = __commonJS({
  "node_modules/source-map-resolve/lib/source-map-resolve-node.js"(exports, module2) {
    var sourceMappingURL = require_source_map_url();
    var resolveUrl = require_resolve_url();
    var decodeUriComponent = require_decode_uri_component2();
    var urix = require_urix();
    var atob = require_node_atob();
    function callbackAsync(callback, error, result) {
      setImmediate(function() {
        callback(error, result);
      });
    }
    function parseMapToJSON(string, data) {
      try {
        return JSON.parse(string.replace(/^\)\]\}'/, ""));
      } catch (error) {
        error.sourceMapData = data;
        throw error;
      }
    }
    function readSync(read, url, data) {
      var readUrl = decodeUriComponent(url);
      try {
        return String(read(readUrl));
      } catch (error) {
        error.sourceMapData = data;
        throw error;
      }
    }
    function resolveSourceMap(code, codeUrl, read, callback) {
      var mapData;
      try {
        mapData = resolveSourceMapHelper(code, codeUrl);
      } catch (error) {
        return callbackAsync(callback, error);
      }
      if (!mapData || mapData.map) {
        return callbackAsync(callback, null, mapData);
      }
      var readUrl = decodeUriComponent(mapData.url);
      read(readUrl, function(error, result) {
        if (error) {
          error.sourceMapData = mapData;
          return callback(error);
        }
        mapData.map = String(result);
        try {
          mapData.map = parseMapToJSON(mapData.map, mapData);
        } catch (error2) {
          return callback(error2);
        }
        callback(null, mapData);
      });
    }
    function resolveSourceMapSync(code, codeUrl, read) {
      var mapData = resolveSourceMapHelper(code, codeUrl);
      if (!mapData || mapData.map) {
        return mapData;
      }
      mapData.map = readSync(read, mapData.url, mapData);
      mapData.map = parseMapToJSON(mapData.map, mapData);
      return mapData;
    }
    var dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/;
    var jsonMimeTypeRegex = /^(?:application|text)\/json$/;
    var jsonCharacterEncoding = "utf-8";
    function base64ToBuf(b64) {
      var binStr = atob(b64);
      var len = binStr.length;
      var arr = new Uint8Array(len);
      for (var i = 0; i < len; i++) {
        arr[i] = binStr.charCodeAt(i);
      }
      return arr;
    }
    function decodeBase64String(b64) {
      if (typeof TextDecoder === "undefined" || typeof Uint8Array === "undefined") {
        return atob(b64);
      }
      var buf = base64ToBuf(b64);
      var decoder = new TextDecoder(jsonCharacterEncoding, { fatal: true });
      return decoder.decode(buf);
    }
    function resolveSourceMapHelper(code, codeUrl) {
      codeUrl = urix(codeUrl);
      var url = sourceMappingURL.getFrom(code);
      if (!url) {
        return null;
      }
      var dataUri = url.match(dataUriRegex);
      if (dataUri) {
        var mimeType = dataUri[1] || "text/plain";
        var lastParameter = dataUri[2] || "";
        var encoded = dataUri[3] || "";
        var data = {
          sourceMappingURL: url,
          url: null,
          sourcesRelativeTo: codeUrl,
          map: encoded
        };
        if (!jsonMimeTypeRegex.test(mimeType)) {
          var error = new Error("Unuseful data uri mime type: " + mimeType);
          error.sourceMapData = data;
          throw error;
        }
        try {
          data.map = parseMapToJSON(lastParameter === ";base64" ? decodeBase64String(encoded) : decodeURIComponent(encoded), data);
        } catch (error2) {
          error2.sourceMapData = data;
          throw error2;
        }
        return data;
      }
      var mapUrl = resolveUrl(codeUrl, url);
      return {
        sourceMappingURL: url,
        url: mapUrl,
        sourcesRelativeTo: mapUrl,
        map: null
      };
    }
    function resolveSources(map, mapUrl, read, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      var pending = map.sources ? map.sources.length : 0;
      var result = {
        sourcesResolved: [],
        sourcesContent: []
      };
      if (pending === 0) {
        callbackAsync(callback, null, result);
        return;
      }
      var done = function() {
        pending--;
        if (pending === 0) {
          callback(null, result);
        }
      };
      resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {
        result.sourcesResolved[index] = fullUrl;
        if (typeof sourceContent === "string") {
          result.sourcesContent[index] = sourceContent;
          callbackAsync(done, null);
        } else {
          var readUrl = decodeUriComponent(fullUrl);
          read(readUrl, function(error, source) {
            result.sourcesContent[index] = error ? error : String(source);
            done();
          });
        }
      });
    }
    function resolveSourcesSync(map, mapUrl, read, options) {
      var result = {
        sourcesResolved: [],
        sourcesContent: []
      };
      if (!map.sources || map.sources.length === 0) {
        return result;
      }
      resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {
        result.sourcesResolved[index] = fullUrl;
        if (read !== null) {
          if (typeof sourceContent === "string") {
            result.sourcesContent[index] = sourceContent;
          } else {
            var readUrl = decodeUriComponent(fullUrl);
            try {
              result.sourcesContent[index] = String(read(readUrl));
            } catch (error) {
              result.sourcesContent[index] = error;
            }
          }
        }
      });
      return result;
    }
    var endingSlash = /\/?$/;
    function resolveSourcesHelper(map, mapUrl, options, fn) {
      options = options || {};
      mapUrl = urix(mapUrl);
      var fullUrl;
      var sourceContent;
      var sourceRoot;
      for (var index = 0, len = map.sources.length; index < len; index++) {
        sourceRoot = null;
        if (typeof options.sourceRoot === "string") {
          sourceRoot = options.sourceRoot;
        } else if (typeof map.sourceRoot === "string" && options.sourceRoot !== false) {
          sourceRoot = map.sourceRoot;
        }
        if (sourceRoot === null || sourceRoot === "") {
          fullUrl = resolveUrl(mapUrl, map.sources[index]);
        } else {
          fullUrl = resolveUrl(mapUrl, sourceRoot.replace(endingSlash, "/"), map.sources[index]);
        }
        sourceContent = (map.sourcesContent || [])[index];
        fn(fullUrl, sourceContent, index);
      }
    }
    function resolve(code, codeUrl, read, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (code === null) {
        var mapUrl = codeUrl;
        var data = {
          sourceMappingURL: null,
          url: mapUrl,
          sourcesRelativeTo: mapUrl,
          map: null
        };
        var readUrl = decodeUriComponent(mapUrl);
        read(readUrl, function(error, result) {
          if (error) {
            error.sourceMapData = data;
            return callback(error);
          }
          data.map = String(result);
          try {
            data.map = parseMapToJSON(data.map, data);
          } catch (error2) {
            return callback(error2);
          }
          _resolveSources(data);
        });
      } else {
        resolveSourceMap(code, codeUrl, read, function(error, mapData) {
          if (error) {
            return callback(error);
          }
          if (!mapData) {
            return callback(null, null);
          }
          _resolveSources(mapData);
        });
      }
      function _resolveSources(mapData) {
        resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function(error, result) {
          if (error) {
            return callback(error);
          }
          mapData.sourcesResolved = result.sourcesResolved;
          mapData.sourcesContent = result.sourcesContent;
          callback(null, mapData);
        });
      }
    }
    function resolveSync(code, codeUrl, read, options) {
      var mapData;
      if (code === null) {
        var mapUrl = codeUrl;
        mapData = {
          sourceMappingURL: null,
          url: mapUrl,
          sourcesRelativeTo: mapUrl,
          map: null
        };
        mapData.map = readSync(read, mapUrl, mapData);
        mapData.map = parseMapToJSON(mapData.map, mapData);
      } else {
        mapData = resolveSourceMapSync(code, codeUrl, read);
        if (!mapData) {
          return null;
        }
      }
      var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options);
      mapData.sourcesResolved = result.sourcesResolved;
      mapData.sourcesContent = result.sourcesContent;
      return mapData;
    }
    module2.exports = {
      resolveSourceMap,
      resolveSourceMapSync,
      resolveSources,
      resolveSourcesSync,
      resolve,
      resolveSync,
      parseMapToJSON
    };
  }
});

// node_modules/snapdragon/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/snapdragon/lib/utils.js"(exports) {
    "use strict";
    exports.extend = require_extend_shallow3();
    exports.SourceMap = require_source_map();
    exports.sourceMapResolve = require_source_map_resolve_node();
    exports.unixify = function(fp) {
      return fp.split(/\\+/).join("/");
    };
    exports.isString = function(str) {
      return str && typeof str === "string";
    };
    exports.arrayify = function(val) {
      if (typeof val === "string")
        return [val];
      return val ? Array.isArray(val) ? val : [val] : [];
    };
    exports.last = function(arr, n) {
      return arr[arr.length - (n || 1)];
    };
  }
});

// node_modules/snapdragon/lib/source-maps.js
var require_source_maps = __commonJS({
  "node_modules/snapdragon/lib/source-maps.js"(exports, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var define2 = require_define_property7();
    var utils = require_utils3();
    module2.exports = mixin;
    function mixin(compiler) {
      define2(compiler, "_comment", compiler.comment);
      compiler.map = new utils.SourceMap.SourceMapGenerator();
      compiler.position = { line: 1, column: 1 };
      compiler.content = {};
      compiler.files = {};
      for (var key in exports) {
        define2(compiler, key, exports[key]);
      }
    }
    exports.updatePosition = function(str) {
      var lines = str.match(/\n/g);
      if (lines)
        this.position.line += lines.length;
      var i = str.lastIndexOf("\n");
      this.position.column = ~i ? str.length - i : this.position.column + str.length;
    };
    exports.emit = function(str, node) {
      var position = node.position || {};
      var source = position.source;
      if (source) {
        if (position.filepath) {
          source = utils.unixify(position.filepath);
        }
        this.map.addMapping({
          source,
          generated: {
            line: this.position.line,
            column: Math.max(this.position.column - 1, 0)
          },
          original: {
            line: position.start.line,
            column: position.start.column - 1
          }
        });
        if (position.content) {
          this.addContent(source, position);
        }
        if (position.filepath) {
          this.addFile(source, position);
        }
        this.updatePosition(str);
        this.output += str;
      }
      return str;
    };
    exports.addFile = function(file, position) {
      if (typeof position.content !== "string")
        return;
      if (Object.prototype.hasOwnProperty.call(this.files, file))
        return;
      this.files[file] = position.content;
    };
    exports.addContent = function(source, position) {
      if (typeof position.content !== "string")
        return;
      if (Object.prototype.hasOwnProperty.call(this.content, source))
        return;
      this.map.setSourceContent(source, position.content);
    };
    exports.applySourceMaps = function() {
      Object.keys(this.files).forEach(function(file) {
        var content = this.files[file];
        this.map.setSourceContent(file, content);
        if (this.options.inputSourcemaps === true) {
          var originalMap = utils.sourceMapResolve.resolveSync(content, file, fs.readFileSync);
          if (originalMap) {
            var map = new utils.SourceMap.SourceMapConsumer(originalMap.map);
            var relativeTo = originalMap.sourcesRelativeTo;
            this.map.applySourceMap(map, file, utils.unixify(path.dirname(relativeTo)));
          }
        }
      }, this);
    };
    exports.comment = function(node) {
      if (/^# sourceMappingURL=/.test(node.comment)) {
        return this.emit("", node.position);
      }
      return this._comment(node);
    };
  }
});

// node_modules/snapdragon/lib/compiler.js
var require_compiler = __commonJS({
  "node_modules/snapdragon/lib/compiler.js"(exports, module2) {
    "use strict";
    var use = require_use();
    var define2 = require_define_property7();
    var debug = require_src()("snapdragon:compiler");
    var utils = require_utils3();
    function Compiler(options, state) {
      debug("initializing", __filename);
      this.options = utils.extend({ source: "string" }, options);
      this.state = state || {};
      this.compilers = {};
      this.output = "";
      this.set("eos", function(node) {
        return this.emit(node.val, node);
      });
      this.set("noop", function(node) {
        return this.emit(node.val, node);
      });
      this.set("bos", function(node) {
        return this.emit(node.val, node);
      });
      use(this);
    }
    Compiler.prototype = {
      error: function(msg, node) {
        var pos = node.position || { start: { column: 0 } };
        var message = this.options.source + " column:" + pos.start.column + ": " + msg;
        var err = new Error(message);
        err.reason = msg;
        err.column = pos.start.column;
        err.source = this.pattern;
        if (this.options.silent) {
          this.errors.push(err);
        } else {
          throw err;
        }
      },
      define: function(key, val) {
        define2(this, key, val);
        return this;
      },
      emit: function(str, node) {
        this.output += str;
        return str;
      },
      set: function(name, fn) {
        this.compilers[name] = fn;
        return this;
      },
      get: function(name) {
        return this.compilers[name];
      },
      prev: function(n) {
        return this.ast.nodes[this.idx - (n || 1)] || { type: "bos", val: "" };
      },
      next: function(n) {
        return this.ast.nodes[this.idx + (n || 1)] || { type: "eos", val: "" };
      },
      visit: function(node, nodes, i) {
        var fn = this.compilers[node.type];
        this.idx = i;
        if (typeof fn !== "function") {
          throw this.error('compiler "' + node.type + '" is not registered', node);
        }
        return fn.call(this, node, nodes, i);
      },
      mapVisit: function(nodes) {
        if (!Array.isArray(nodes)) {
          throw new TypeError("expected an array");
        }
        var len = nodes.length;
        var idx = -1;
        while (++idx < len) {
          this.visit(nodes[idx], nodes, idx);
        }
        return this;
      },
      compile: function(ast, options) {
        var opts = utils.extend({}, this.options, options);
        this.ast = ast;
        this.parsingErrors = this.ast.errors;
        this.output = "";
        if (opts.sourcemap) {
          var sourcemaps = require_source_maps();
          sourcemaps(this);
          this.mapVisit(this.ast.nodes);
          this.applySourceMaps();
          this.map = opts.sourcemap === "generator" ? this.map : this.map.toJSON();
          return this;
        }
        this.mapVisit(this.ast.nodes);
        return this;
      }
    };
    module2.exports = Compiler;
  }
});

// node_modules/map-cache/index.js
var require_map_cache = __commonJS({
  "node_modules/map-cache/index.js"(exports, module2) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    module2.exports = MapCache;
    function MapCache(data) {
      this.__data__ = data || {};
    }
    MapCache.prototype.set = function mapSet(key, value) {
      if (key !== "__proto__") {
        this.__data__[key] = value;
      }
      return this;
    };
    MapCache.prototype.get = function mapGet(key) {
      return key === "__proto__" ? void 0 : this.__data__[key];
    };
    MapCache.prototype.has = function mapHas(key) {
      return key !== "__proto__" && hasOwn.call(this.__data__, key);
    };
    MapCache.prototype.del = function mapDelete(key) {
      return this.has(key) && delete this.__data__[key];
    };
  }
});

// node_modules/snapdragon/lib/position.js
var require_position = __commonJS({
  "node_modules/snapdragon/lib/position.js"(exports, module2) {
    "use strict";
    var define2 = require_define_property7();
    module2.exports = function Position(start, parser) {
      this.start = start;
      this.end = { line: parser.line, column: parser.column };
      define2(this, "content", parser.orig);
      define2(this, "source", parser.options.source);
    };
  }
});

// node_modules/snapdragon/lib/parser.js
var require_parser = __commonJS({
  "node_modules/snapdragon/lib/parser.js"(exports, module2) {
    "use strict";
    var use = require_use();
    var util = require("util");
    var Cache = require_map_cache();
    var define2 = require_define_property7();
    var debug = require_src()("snapdragon:parser");
    var Position = require_position();
    var utils = require_utils3();
    function Parser(options) {
      debug("initializing", __filename);
      this.options = utils.extend({ source: "string" }, options);
      this.init(this.options);
      use(this);
    }
    Parser.prototype = {
      constructor: Parser,
      init: function(options) {
        this.orig = "";
        this.input = "";
        this.parsed = "";
        this.column = 1;
        this.line = 1;
        this.regex = new Cache();
        this.errors = this.errors || [];
        this.parsers = this.parsers || {};
        this.types = this.types || [];
        this.sets = this.sets || {};
        this.fns = this.fns || [];
        this.currentType = "root";
        var pos = this.position();
        this.bos = pos({ type: "bos", val: "" });
        this.ast = {
          type: "root",
          errors: this.errors,
          nodes: [this.bos]
        };
        define2(this.bos, "parent", this.ast);
        this.nodes = [this.ast];
        this.count = 0;
        this.setCount = 0;
        this.stack = [];
      },
      error: function(msg, node) {
        var pos = node.position || { start: { column: 0, line: 0 } };
        var line = pos.start.line;
        var column = pos.start.column;
        var source = this.options.source;
        var message = source + " <line:" + line + " column:" + column + ">: " + msg;
        var err = new Error(message);
        err.source = source;
        err.reason = msg;
        err.pos = pos;
        if (this.options.silent) {
          this.errors.push(err);
        } else {
          throw err;
        }
      },
      define: function(key, val) {
        define2(this, key, val);
        return this;
      },
      position: function() {
        var start = { line: this.line, column: this.column };
        var self2 = this;
        return function(node) {
          define2(node, "position", new Position(start, self2));
          return node;
        };
      },
      set: function(type, fn) {
        if (this.types.indexOf(type) === -1) {
          this.types.push(type);
        }
        this.parsers[type] = fn.bind(this);
        return this;
      },
      get: function(name) {
        return this.parsers[name];
      },
      push: function(type, token) {
        this.sets[type] = this.sets[type] || [];
        this.count++;
        this.stack.push(token);
        return this.sets[type].push(token);
      },
      pop: function(type) {
        this.sets[type] = this.sets[type] || [];
        this.count--;
        this.stack.pop();
        return this.sets[type].pop();
      },
      isInside: function(type) {
        this.sets[type] = this.sets[type] || [];
        return this.sets[type].length > 0;
      },
      isType: function(node, type) {
        return node && node.type === type;
      },
      prev: function(n) {
        return this.stack.length > 0 ? utils.last(this.stack, n) : utils.last(this.nodes, n);
      },
      consume: function(len) {
        this.input = this.input.substr(len);
      },
      updatePosition: function(str, len) {
        var lines = str.match(/\n/g);
        if (lines)
          this.line += lines.length;
        var i = str.lastIndexOf("\n");
        this.column = ~i ? len - i : this.column + len;
        this.parsed += str;
        this.consume(len);
      },
      match: function(regex) {
        var m = regex.exec(this.input);
        if (m) {
          this.updatePosition(m[0], m[0].length);
          return m;
        }
      },
      capture: function(type, regex) {
        if (typeof regex === "function") {
          return this.set.apply(this, arguments);
        }
        this.regex.set(type, regex);
        this.set(type, function() {
          var parsed = this.parsed;
          var pos = this.position();
          var m = this.match(regex);
          if (!m || !m[0])
            return;
          var prev = this.prev();
          var node = pos({
            type,
            val: m[0],
            parsed,
            rest: this.input
          });
          if (m[1]) {
            node.inner = m[1];
          }
          define2(node, "inside", this.stack.length > 0);
          define2(node, "parent", prev);
          prev.nodes.push(node);
        }.bind(this));
        return this;
      },
      capturePair: function(type, openRegex, closeRegex, fn) {
        this.sets[type] = this.sets[type] || [];
        this.set(type + ".open", function() {
          var parsed = this.parsed;
          var pos = this.position();
          var m = this.match(openRegex);
          if (!m || !m[0])
            return;
          var val = m[0];
          this.setCount++;
          this.specialChars = true;
          var open = pos({
            type: type + ".open",
            val,
            rest: this.input
          });
          if (typeof m[1] !== "undefined") {
            open.inner = m[1];
          }
          var prev = this.prev();
          var node = pos({
            type,
            nodes: [open]
          });
          define2(node, "rest", this.input);
          define2(node, "parsed", parsed);
          define2(node, "prefix", m[1]);
          define2(node, "parent", prev);
          define2(open, "parent", node);
          if (typeof fn === "function") {
            fn.call(this, open, node);
          }
          this.push(type, node);
          prev.nodes.push(node);
        });
        this.set(type + ".close", function() {
          var pos = this.position();
          var m = this.match(closeRegex);
          if (!m || !m[0])
            return;
          var parent = this.pop(type);
          var node = pos({
            type: type + ".close",
            rest: this.input,
            suffix: m[1],
            val: m[0]
          });
          if (!this.isType(parent, type)) {
            if (this.options.strict) {
              throw new Error('missing opening "' + type + '"');
            }
            this.setCount--;
            node.escaped = true;
            return node;
          }
          if (node.suffix === "\\") {
            parent.escaped = true;
            node.escaped = true;
          }
          parent.nodes.push(node);
          define2(node, "parent", parent);
        });
        return this;
      },
      eos: function() {
        var pos = this.position();
        if (this.input)
          return;
        var prev = this.prev();
        while (prev.type !== "root" && !prev.visited) {
          if (this.options.strict === true) {
            throw new SyntaxError("invalid syntax:" + util.inspect(prev, null, 2));
          }
          if (!hasDelims(prev)) {
            prev.parent.escaped = true;
            prev.escaped = true;
          }
          visit(prev, function(node) {
            if (!hasDelims(node.parent)) {
              node.parent.escaped = true;
              node.escaped = true;
            }
          });
          prev = prev.parent;
        }
        var tok = pos({
          type: "eos",
          val: this.append || ""
        });
        define2(tok, "parent", this.ast);
        return tok;
      },
      next: function() {
        var parsed = this.parsed;
        var len = this.types.length;
        var idx = -1;
        var tok;
        while (++idx < len) {
          if (tok = this.parsers[this.types[idx]].call(this)) {
            define2(tok, "rest", this.input);
            define2(tok, "parsed", parsed);
            this.last = tok;
            return tok;
          }
        }
      },
      parse: function(input) {
        if (typeof input !== "string") {
          throw new TypeError("expected a string");
        }
        this.init(this.options);
        this.orig = input;
        this.input = input;
        var self2 = this;
        function parse() {
          input = self2.input;
          var node2 = self2.next();
          if (node2) {
            var prev = self2.prev();
            if (prev) {
              define2(node2, "parent", prev);
              if (prev.nodes) {
                prev.nodes.push(node2);
              }
            }
            if (self2.sets.hasOwnProperty(prev.type)) {
              self2.currentType = prev.type;
            }
          }
          if (self2.input && input === self2.input) {
            throw new Error('no parsers registered for: "' + self2.input.slice(0, 5) + '"');
          }
        }
        while (this.input)
          parse();
        if (this.stack.length && this.options.strict) {
          var node = this.stack.pop();
          throw this.error("missing opening " + node.type + ': "' + this.orig + '"');
        }
        var eos = this.eos();
        var tok = this.prev();
        if (tok.type !== "eos") {
          this.ast.nodes.push(eos);
        }
        return this.ast;
      }
    };
    function visit(node, fn) {
      if (!node.visited) {
        define2(node, "visited", true);
        return node.nodes ? mapVisit(node.nodes, fn) : fn(node);
      }
      return node;
    }
    function mapVisit(nodes, fn) {
      var len = nodes.length;
      var idx = -1;
      while (++idx < len) {
        visit(nodes[idx], fn);
      }
    }
    function hasOpen(node) {
      return node.nodes && node.nodes[0].type === node.type + ".open";
    }
    function hasClose(node) {
      return node.nodes && utils.last(node.nodes).type === node.type + ".close";
    }
    function hasDelims(node) {
      return hasOpen(node) && hasClose(node);
    }
    module2.exports = Parser;
  }
});

// node_modules/snapdragon/index.js
var require_snapdragon = __commonJS({
  "node_modules/snapdragon/index.js"(exports, module2) {
    "use strict";
    var Base = require_base();
    var define2 = require_define_property7();
    var Compiler = require_compiler();
    var Parser = require_parser();
    var utils = require_utils3();
    function Snapdragon(options) {
      Base.call(this, null, options);
      this.options = utils.extend({ source: "string" }, this.options);
      this.compiler = new Compiler(this.options);
      this.parser = new Parser(this.options);
      Object.defineProperty(this, "compilers", {
        get: function() {
          return this.compiler.compilers;
        }
      });
      Object.defineProperty(this, "parsers", {
        get: function() {
          return this.parser.parsers;
        }
      });
      Object.defineProperty(this, "regex", {
        get: function() {
          return this.parser.regex;
        }
      });
    }
    Base.extend(Snapdragon);
    Snapdragon.prototype.capture = function() {
      return this.parser.capture.apply(this.parser, arguments);
    };
    Snapdragon.prototype.use = function(fn) {
      fn.call(this, this);
      return this;
    };
    Snapdragon.prototype.parse = function(str, options) {
      this.options = utils.extend({}, this.options, options);
      var parsed = this.parser.parse(str, this.options);
      define2(parsed, "parser", this.parser);
      return parsed;
    };
    Snapdragon.prototype.compile = function(ast, options) {
      this.options = utils.extend({}, this.options, options);
      var compiled = this.compiler.compile(ast, this.options);
      define2(compiled, "compiler", this.compiler);
      return compiled;
    };
    module2.exports = Snapdragon;
    module2.exports.Compiler = Compiler;
    module2.exports.Parser = Parser;
  }
});

// node_modules/braces/lib/braces.js
var require_braces = __commonJS({
  "node_modules/braces/lib/braces.js"(exports, module2) {
    "use strict";
    var extend = require_extend_shallow3();
    var Snapdragon = require_snapdragon();
    var compilers = require_compilers();
    var parsers = require_parsers();
    var utils = require_utils2();
    function Braces(options) {
      this.options = extend({}, options);
    }
    Braces.prototype.init = function(options) {
      if (this.isInitialized)
        return;
      this.isInitialized = true;
      var opts = utils.createOptions({}, this.options, options);
      this.snapdragon = this.options.snapdragon || new Snapdragon(opts);
      this.compiler = this.snapdragon.compiler;
      this.parser = this.snapdragon.parser;
      compilers(this.snapdragon, opts);
      parsers(this.snapdragon, opts);
      utils.define(this.snapdragon, "parse", function(pattern, options2) {
        var parsed = Snapdragon.prototype.parse.apply(this, arguments);
        this.parser.ast.input = pattern;
        var stack = this.parser.stack;
        while (stack.length) {
          addParent({ type: "brace.close", val: "" }, stack.pop());
        }
        function addParent(node, parent) {
          utils.define(node, "parent", parent);
          parent.nodes.push(node);
        }
        utils.define(parsed, "parser", this.parser);
        return parsed;
      });
    };
    Braces.prototype.parse = function(ast, options) {
      if (ast && typeof ast === "object" && ast.nodes)
        return ast;
      this.init(options);
      return this.snapdragon.parse(ast, options);
    };
    Braces.prototype.compile = function(ast, options) {
      if (typeof ast === "string") {
        ast = this.parse(ast, options);
      } else {
        this.init(options);
      }
      return this.snapdragon.compile(ast, options);
    };
    Braces.prototype.expand = function(pattern) {
      var ast = this.parse(pattern, { expand: true });
      return this.compile(ast, { expand: true });
    };
    Braces.prototype.optimize = function(pattern) {
      var ast = this.parse(pattern, { optimize: true });
      return this.compile(ast, { optimize: true });
    };
    module2.exports = Braces;
  }
});

// node_modules/braces/index.js
var require_braces2 = __commonJS({
  "node_modules/braces/index.js"(exports, module2) {
    "use strict";
    var toRegex = require_to_regex();
    var unique = require_array_unique();
    var extend = require_extend_shallow3();
    var compilers = require_compilers();
    var parsers = require_parsers();
    var Braces = require_braces();
    var utils = require_utils2();
    var MAX_LENGTH = 1024 * 64;
    var cache = {};
    function braces(pattern, options) {
      var key = utils.createKey(String(pattern), options);
      var arr = [];
      var disabled = options && options.cache === false;
      if (!disabled && cache.hasOwnProperty(key)) {
        return cache[key];
      }
      if (Array.isArray(pattern)) {
        for (var i = 0; i < pattern.length; i++) {
          arr.push.apply(arr, braces.create(pattern[i], options));
        }
      } else {
        arr = braces.create(pattern, options);
      }
      if (options && options.nodupes === true) {
        arr = unique(arr);
      }
      if (!disabled) {
        cache[key] = arr;
      }
      return arr;
    }
    braces.expand = function(pattern, options) {
      return braces.create(pattern, extend({}, options, { expand: true }));
    };
    braces.optimize = function(pattern, options) {
      return braces.create(pattern, options);
    };
    braces.create = function(pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("expected a string");
      }
      var maxLength = options && options.maxLength || MAX_LENGTH;
      if (pattern.length >= maxLength) {
        throw new Error("expected pattern to be less than " + maxLength + " characters");
      }
      function create() {
        if (pattern === "" || pattern.length < 3) {
          return [pattern];
        }
        if (utils.isEmptySets(pattern)) {
          return [];
        }
        if (utils.isQuotedString(pattern)) {
          return [pattern.slice(1, -1)];
        }
        var proto = new Braces(options);
        var result = !options || options.expand !== true ? proto.optimize(pattern, options) : proto.expand(pattern, options);
        var arr = result.output;
        if (options && options.noempty === true) {
          arr = arr.filter(Boolean);
        }
        if (options && options.nodupes === true) {
          arr = unique(arr);
        }
        Object.defineProperty(arr, "result", {
          enumerable: false,
          value: result
        });
        return arr;
      }
      return memoize("create", pattern, options, create);
    };
    braces.makeRe = function(pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("expected a string");
      }
      var maxLength = options && options.maxLength || MAX_LENGTH;
      if (pattern.length >= maxLength) {
        throw new Error("expected pattern to be less than " + maxLength + " characters");
      }
      function makeRe() {
        var arr = braces(pattern, options);
        var opts = extend({ strictErrors: false }, options);
        return toRegex(arr, opts);
      }
      return memoize("makeRe", pattern, options, makeRe);
    };
    braces.parse = function(pattern, options) {
      var proto = new Braces(options);
      return proto.parse(pattern, options);
    };
    braces.compile = function(ast, options) {
      var proto = new Braces(options);
      return proto.compile(ast, options);
    };
    braces.clearCache = function() {
      cache = braces.cache = {};
    };
    function memoize(type, pattern, options, fn) {
      var key = utils.createKey(type + ":" + pattern, options);
      var disabled = options && options.cache === false;
      if (disabled) {
        braces.clearCache();
        return fn(pattern, options);
      }
      if (cache.hasOwnProperty(key)) {
        return cache[key];
      }
      var res = fn(pattern, options);
      cache[key] = res;
      return res;
    }
    braces.Braces = Braces;
    braces.compilers = compilers;
    braces.parsers = parsers;
    braces.cache = cache;
    module2.exports = braces;
  }
});

// node_modules/micromatch/node_modules/is-extendable/index.js
var require_is_extendable6 = __commonJS({
  "node_modules/micromatch/node_modules/is-extendable/index.js"(exports, module2) {
    "use strict";
    var isPlainObject = require_is_plain_object();
    module2.exports = function isExtendable(val) {
      return isPlainObject(val) || typeof val === "function" || Array.isArray(val);
    };
  }
});

// node_modules/micromatch/node_modules/extend-shallow/index.js
var require_extend_shallow5 = __commonJS({
  "node_modules/micromatch/node_modules/extend-shallow/index.js"(exports, module2) {
    "use strict";
    var isExtendable = require_is_extendable6();
    var assignSymbols = require_assign_symbols();
    module2.exports = Object.assign || function(obj) {
      if (obj === null || typeof obj === "undefined") {
        throw new TypeError("Cannot convert undefined or null to object");
      }
      if (!isObject(obj)) {
        obj = {};
      }
      for (var i = 1; i < arguments.length; i++) {
        var val = arguments[i];
        if (isString(val)) {
          val = toObject(val);
        }
        if (isObject(val)) {
          assign(obj, val);
          assignSymbols(obj, val);
        }
      }
      return obj;
    };
    function assign(a, b) {
      for (var key in b) {
        if (hasOwn(b, key)) {
          a[key] = b[key];
        }
      }
    }
    function isString(val) {
      return val && typeof val === "string";
    }
    function toObject(str) {
      var obj = {};
      for (var i in str) {
        obj[i] = str[i];
      }
      return obj;
    }
    function isObject(val) {
      return val && typeof val === "object" || isExtendable(val);
    }
    function hasOwn(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/nanomatch/node_modules/is-extendable/index.js
var require_is_extendable7 = __commonJS({
  "node_modules/nanomatch/node_modules/is-extendable/index.js"(exports, module2) {
    "use strict";
    var isPlainObject = require_is_plain_object();
    module2.exports = function isExtendable(val) {
      return isPlainObject(val) || typeof val === "function" || Array.isArray(val);
    };
  }
});

// node_modules/nanomatch/node_modules/extend-shallow/index.js
var require_extend_shallow6 = __commonJS({
  "node_modules/nanomatch/node_modules/extend-shallow/index.js"(exports, module2) {
    "use strict";
    var isExtendable = require_is_extendable7();
    var assignSymbols = require_assign_symbols();
    module2.exports = Object.assign || function(obj) {
      if (obj === null || typeof obj === "undefined") {
        throw new TypeError("Cannot convert undefined or null to object");
      }
      if (!isObject(obj)) {
        obj = {};
      }
      for (var i = 1; i < arguments.length; i++) {
        var val = arguments[i];
        if (isString(val)) {
          val = toObject(val);
        }
        if (isObject(val)) {
          assign(obj, val);
          assignSymbols(obj, val);
        }
      }
      return obj;
    };
    function assign(a, b) {
      for (var key in b) {
        if (hasOwn(b, key)) {
          a[key] = b[key];
        }
      }
    }
    function isString(val) {
      return val && typeof val === "string";
    }
    function toObject(str) {
      var obj = {};
      for (var i in str) {
        obj[i] = str[i];
      }
      return obj;
    }
    function isObject(val) {
      return val && typeof val === "object" || isExtendable(val);
    }
    function hasOwn(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/nanomatch/lib/compilers.js
var require_compilers2 = __commonJS({
  "node_modules/nanomatch/lib/compilers.js"(exports, module2) {
    "use strict";
    module2.exports = function(nanomatch, options) {
      function slash() {
        if (options && typeof options.slash === "string") {
          return options.slash;
        }
        if (options && typeof options.slash === "function") {
          return options.slash.call(nanomatch);
        }
        return "\\\\/";
      }
      function star() {
        if (options && typeof options.star === "string") {
          return options.star;
        }
        if (options && typeof options.star === "function") {
          return options.star.call(nanomatch);
        }
        return "[^" + slash() + "]*?";
      }
      var ast = nanomatch.ast = nanomatch.parser.ast;
      ast.state = nanomatch.parser.state;
      nanomatch.compiler.state = ast.state;
      nanomatch.compiler.set("not", function(node) {
        var prev = this.prev();
        if (this.options.nonegate === true || prev.type !== "bos") {
          return this.emit("\\" + node.val, node);
        }
        return this.emit(node.val, node);
      }).set("escape", function(node) {
        if (this.options.unescape && /^[-\w_.]/.test(node.val)) {
          return this.emit(node.val, node);
        }
        return this.emit("\\" + node.val, node);
      }).set("quoted", function(node) {
        return this.emit(node.val, node);
      }).set("dollar", function(node) {
        if (node.parent.type === "bracket") {
          return this.emit(node.val, node);
        }
        return this.emit("\\" + node.val, node);
      }).set("dot", function(node) {
        if (node.dotfiles === true)
          this.dotfiles = true;
        return this.emit("\\" + node.val, node);
      }).set("backslash", function(node) {
        return this.emit(node.val, node);
      }).set("slash", function(node, nodes, i) {
        var val = "[" + slash() + "]";
        var parent = node.parent;
        var prev = this.prev();
        while (parent.type === "paren" && !parent.hasSlash) {
          parent.hasSlash = true;
          parent = parent.parent;
        }
        if (prev.addQmark) {
          val += "?";
        }
        if (node.rest.slice(0, 2) === "\\b") {
          return this.emit(val, node);
        }
        if (node.parsed === "**" || node.parsed === "./**") {
          this.output = "(?:" + this.output;
          return this.emit(val + ")?", node);
        }
        if (node.parsed === "!**" && this.options.nonegate !== true) {
          return this.emit(val + "?\\b", node);
        }
        return this.emit(val, node);
      }).set("bracket", function(node) {
        var close = node.close;
        var open = !node.escaped ? "[" : "\\[";
        var negated = node.negated;
        var inner = node.inner;
        var val = node.val;
        if (node.escaped === true) {
          inner = inner.replace(/\\?(\W)/g, "\\$1");
          negated = "";
        }
        if (inner === "]-") {
          inner = "\\]\\-";
        }
        if (negated && inner.indexOf(".") === -1) {
          inner += ".";
        }
        if (negated && inner.indexOf("/") === -1) {
          inner += "/";
        }
        val = open + negated + inner + close;
        return this.emit(val, node);
      }).set("square", function(node) {
        var val = (/^\W/.test(node.val) ? "\\" : "") + node.val;
        return this.emit(val, node);
      }).set("qmark", function(node) {
        var prev = this.prev();
        var val = "[^.\\\\/]";
        if (this.options.dot || prev.type !== "bos" && prev.type !== "slash") {
          val = "[^\\\\/]";
        }
        if (node.parsed.slice(-1) === "(") {
          var ch = node.rest.charAt(0);
          if (ch === "!" || ch === "=" || ch === ":") {
            return this.emit(node.val, node);
          }
        }
        if (node.val.length > 1) {
          val += "{" + node.val.length + "}";
        }
        return this.emit(val, node);
      }).set("plus", function(node) {
        var prev = node.parsed.slice(-1);
        if (prev === "]" || prev === ")") {
          return this.emit(node.val, node);
        }
        if (!this.output || /[?*+]/.test(ch) && node.parent.type !== "bracket") {
          return this.emit("\\+", node);
        }
        var ch = this.output.slice(-1);
        if (/\w/.test(ch) && !node.inside) {
          return this.emit("+\\+?", node);
        }
        return this.emit("+", node);
      }).set("globstar", function(node, nodes, i) {
        if (!this.output) {
          this.state.leadingGlobstar = true;
        }
        var prev = this.prev();
        var before = this.prev(2);
        var next = this.next();
        var after = this.next(2);
        var type = prev.type;
        var val = node.val;
        if (prev.type === "slash" && next.type === "slash") {
          if (before.type === "text") {
            this.output += "?";
            if (after.type !== "text") {
              this.output += "\\b";
            }
          }
        }
        var parsed = node.parsed;
        if (parsed.charAt(0) === "!") {
          parsed = parsed.slice(1);
        }
        var isInside = node.isInside.paren || node.isInside.brace;
        if (parsed && type !== "slash" && type !== "bos" && !isInside) {
          val = star();
        } else {
          val = this.options.dot !== true ? "(?:(?!(?:[" + slash() + "]|^)\\.).)*?" : "(?:(?!(?:[" + slash() + "]|^)(?:\\.{1,2})($|[" + slash() + "]))(?!\\.{2}).)*?";
        }
        if ((type === "slash" || type === "bos") && this.options.dot !== true) {
          val = "(?!\\.)" + val;
        }
        if (prev.type === "slash" && next.type === "slash" && before.type !== "text") {
          if (after.type === "text" || after.type === "star") {
            node.addQmark = true;
          }
        }
        if (this.options.capture) {
          val = "(" + val + ")";
        }
        return this.emit(val, node);
      }).set("star", function(node, nodes, i) {
        var prior = nodes[i - 2] || {};
        var prev = this.prev();
        var next = this.next();
        var type = prev.type;
        function isStart(n) {
          return n.type === "bos" || n.type === "slash";
        }
        if (this.output === "" && this.options.contains !== true) {
          this.output = "(?![" + slash() + "])";
        }
        if (type === "bracket" && this.options.bash === false) {
          var str = next && next.type === "bracket" ? star() : "*?";
          if (!prev.nodes || prev.nodes[1].type !== "posix") {
            return this.emit(str, node);
          }
        }
        var prefix = !this.dotfiles && type !== "text" && type !== "escape" ? this.options.dot ? "(?!(?:^|[" + slash() + "])\\.{1,2}(?:$|[" + slash() + "]))" : "(?!\\.)" : "";
        if (isStart(prev) || isStart(prior) && type === "not") {
          if (prefix !== "(?!\\.)") {
            prefix += "(?!(\\.{2}|\\.[" + slash() + "]))(?=.)";
          } else {
            prefix += "(?=.)";
          }
        } else if (prefix === "(?!\\.)") {
          prefix = "";
        }
        if (prev.type === "not" && prior.type === "bos" && this.options.dot === true) {
          this.output = "(?!\\.)" + this.output;
        }
        var output = prefix + star();
        if (this.options.capture) {
          output = "(" + output + ")";
        }
        return this.emit(output, node);
      }).set("text", function(node) {
        return this.emit(node.val, node);
      }).set("eos", function(node) {
        var prev = this.prev();
        var val = node.val;
        this.output = "(?:\\.[" + slash() + "](?=.))?" + this.output;
        if (this.state.metachar && prev.type !== "qmark" && prev.type !== "slash") {
          val += this.options.contains ? "[" + slash() + "]?" : "(?:[" + slash() + "]|$)";
        }
        return this.emit(val, node);
      });
      if (options && typeof options.compilers === "function") {
        options.compilers(nanomatch.compiler);
      }
    };
  }
});

// node_modules/nanomatch/lib/parsers.js
var require_parsers2 = __commonJS({
  "node_modules/nanomatch/lib/parsers.js"(exports, module2) {
    "use strict";
    var regexNot = require_regex_not();
    var toRegex = require_to_regex();
    var cached;
    var NOT_REGEX = `[\\[!*+?$^"'.\\\\/]+`;
    var not = createTextRegex(NOT_REGEX);
    module2.exports = function(nanomatch, options) {
      var parser = nanomatch.parser;
      var opts = parser.options;
      parser.state = {
        slashes: 0,
        paths: []
      };
      parser.ast.state = parser.state;
      parser.capture("prefix", function() {
        if (this.parsed)
          return;
        var m = this.match(/^\.[\\/]/);
        if (!m)
          return;
        this.state.strictOpen = !!this.options.strictOpen;
        this.state.addPrefix = true;
      }).capture("escape", function() {
        if (this.isInside("bracket"))
          return;
        var pos = this.position();
        var m = this.match(/^(?:\\(.)|([$^]))/);
        if (!m)
          return;
        return pos({
          type: "escape",
          val: m[2] || m[1]
        });
      }).capture("quoted", function() {
        var pos = this.position();
        var m = this.match(/^["']/);
        if (!m)
          return;
        var quote = m[0];
        if (this.input.indexOf(quote) === -1) {
          return pos({
            type: "escape",
            val: quote
          });
        }
        var tok = advanceTo(this.input, quote);
        this.consume(tok.len);
        return pos({
          type: "quoted",
          val: tok.esc
        });
      }).capture("not", function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(this.notRegex || /^!+/);
        if (!m)
          return;
        var val = m[0];
        var isNegated = val.length % 2 === 1;
        if (parsed === "" && !isNegated) {
          val = "";
        }
        if (parsed === "" && isNegated && this.options.nonegate !== true) {
          this.bos.val = "(?!^(?:";
          this.append = ")$).*";
          val = "";
        }
        return pos({
          type: "not",
          val
        });
      }).capture("dot", function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\.+/);
        if (!m)
          return;
        var val = m[0];
        this.state.dot = val === "." && (parsed === "" || parsed.slice(-1) === "/");
        return pos({
          type: "dot",
          dotfiles: this.state.dot,
          val
        });
      }).capture("plus", /^\+(?!\()/).capture("qmark", function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\?+(?!\()/);
        if (!m)
          return;
        this.state.metachar = true;
        this.state.qmark = true;
        return pos({
          type: "qmark",
          parsed,
          val: m[0]
        });
      }).capture("globstar", function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\*{2}(?![*(])(?=[,)/]|$)/);
        if (!m)
          return;
        var type = opts.noglobstar !== true ? "globstar" : "star";
        var node = pos({ type, parsed });
        this.state.metachar = true;
        while (this.input.slice(0, 4) === "/**/") {
          this.input = this.input.slice(3);
        }
        node.isInside = {
          brace: this.isInside("brace"),
          paren: this.isInside("paren")
        };
        if (type === "globstar") {
          this.state.globstar = true;
          node.val = "**";
        } else {
          this.state.star = true;
          node.val = "*";
        }
        return node;
      }).capture("star", function() {
        var pos = this.position();
        var starRe = /^(?:\*(?![*(])|[*]{3,}(?!\()|[*]{2}(?![(/]|$)|\*(?=\*\())/;
        var m = this.match(starRe);
        if (!m)
          return;
        this.state.metachar = true;
        this.state.star = true;
        return pos({
          type: "star",
          val: m[0]
        });
      }).capture("slash", function() {
        var pos = this.position();
        var m = this.match(/^\//);
        if (!m)
          return;
        this.state.slashes++;
        return pos({
          type: "slash",
          val: m[0]
        });
      }).capture("backslash", function() {
        var pos = this.position();
        var m = this.match(/^\\(?![*+?(){}[\]'"])/);
        if (!m)
          return;
        var val = m[0];
        if (this.isInside("bracket")) {
          val = "\\";
        } else if (val.length > 1) {
          val = "\\\\";
        }
        return pos({
          type: "backslash",
          val
        });
      }).capture("square", function() {
        if (this.isInside("bracket"))
          return;
        var pos = this.position();
        var m = this.match(/^\[([^!^\\])\]/);
        if (!m)
          return;
        return pos({
          type: "square",
          val: m[1]
        });
      }).capture("bracket", function() {
        var pos = this.position();
        var m = this.match(/^(?:\[([!^]?)([^\]]+|\]-)(\]|[^*+?]+)|\[)/);
        if (!m)
          return;
        var val = m[0];
        var negated = m[1] ? "^" : "";
        var inner = (m[2] || "").replace(/\\\\+/, "\\\\");
        var close = m[3] || "";
        if (m[2] && inner.length < m[2].length) {
          val = val.replace(/\\\\+/, "\\\\");
        }
        var esc = this.input.slice(0, 2);
        if (inner === "" && esc === "\\]") {
          inner += esc;
          this.consume(2);
          var str = this.input;
          var idx = -1;
          var ch;
          while (ch = str[++idx]) {
            this.consume(1);
            if (ch === "]") {
              close = ch;
              break;
            }
            inner += ch;
          }
        }
        return pos({
          type: "bracket",
          val,
          escaped: close !== "]",
          negated,
          inner,
          close
        });
      }).capture("text", function() {
        if (this.isInside("bracket"))
          return;
        var pos = this.position();
        var m = this.match(not);
        if (!m || !m[0])
          return;
        return pos({
          type: "text",
          val: m[0]
        });
      });
      if (options && typeof options.parsers === "function") {
        options.parsers(nanomatch.parser);
      }
    };
    function advanceTo(input, endChar) {
      var ch = input.charAt(0);
      var tok = { len: 1, val: "", esc: "" };
      var idx = 0;
      function advance() {
        if (ch !== "\\") {
          tok.esc += "\\" + ch;
          tok.val += ch;
        }
        ch = input.charAt(++idx);
        tok.len++;
        if (ch === "\\") {
          advance();
          advance();
        }
      }
      while (ch && ch !== endChar) {
        advance();
      }
      return tok;
    }
    function createTextRegex(pattern) {
      if (cached)
        return cached;
      var opts = { contains: true, strictClose: false };
      var not2 = regexNot.create(pattern, opts);
      var re = toRegex("^(?:[*]\\((?=.)|" + not2 + ")", opts);
      return cached = re;
    }
    module2.exports.not = NOT_REGEX;
  }
});

// node_modules/fragment-cache/index.js
var require_fragment_cache = __commonJS({
  "node_modules/fragment-cache/index.js"(exports, module2) {
    "use strict";
    var MapCache = require_map_cache();
    function FragmentCache(caches) {
      this.caches = caches || {};
    }
    FragmentCache.prototype = {
      cache: function(cacheName) {
        return this.caches[cacheName] || (this.caches[cacheName] = new MapCache());
      },
      set: function(cacheName, key, val) {
        var cache = this.cache(cacheName);
        cache.set(key, val);
        return cache;
      },
      has: function(cacheName, key) {
        return typeof this.get(cacheName, key) !== "undefined";
      },
      get: function(name, key) {
        var cache = this.cache(name);
        if (typeof key === "string") {
          return cache.get(key);
        }
        return cache;
      }
    };
    exports = module2.exports = FragmentCache;
  }
});

// node_modules/nanomatch/lib/cache.js
var require_cache = __commonJS({
  "node_modules/nanomatch/lib/cache.js"(exports, module2) {
    module2.exports = new (require_fragment_cache())();
  }
});

// node_modules/is-windows/index.js
var require_is_windows = __commonJS({
  "node_modules/is-windows/index.js"(exports, module2) {
    (function(factory) {
      if (exports && typeof exports === "object" && typeof module2 !== "undefined") {
        module2.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof window !== "undefined") {
        window.isWindows = factory();
      } else if (typeof global !== "undefined") {
        global.isWindows = factory();
      } else if (typeof self !== "undefined") {
        self.isWindows = factory();
      } else {
        this.isWindows = factory();
      }
    })(function() {
      "use strict";
      return function isWindows() {
        return process && (process.platform === "win32" || /^(msys|cygwin)$/.test(process.env.OSTYPE));
      };
    });
  }
});

// node_modules/arr-diff/index.js
var require_arr_diff = __commonJS({
  "node_modules/arr-diff/index.js"(exports, module2) {
    "use strict";
    module2.exports = function diff(arr) {
      var len = arguments.length;
      var idx = 0;
      while (++idx < len) {
        arr = diffArray(arr, arguments[idx]);
      }
      return arr;
    };
    function diffArray(one, two) {
      if (!Array.isArray(two)) {
        return one.slice();
      }
      var tlen = two.length;
      var olen = one.length;
      var idx = -1;
      var arr = [];
      while (++idx < olen) {
        var ele = one[idx];
        var hasEle = false;
        for (var i = 0; i < tlen; i++) {
          var val = two[i];
          if (ele === val) {
            hasEle = true;
            break;
          }
        }
        if (hasEle === false) {
          arr.push(ele);
        }
      }
      return arr;
    }
  }
});

// node_modules/object.pick/index.js
var require_object = __commonJS({
  "node_modules/object.pick/index.js"(exports, module2) {
    "use strict";
    var isObject = require_isobject();
    module2.exports = function pick(obj, keys) {
      if (!isObject(obj) && typeof obj !== "function") {
        return {};
      }
      var res = {};
      if (typeof keys === "string") {
        if (keys in obj) {
          res[keys] = obj[keys];
        }
        return res;
      }
      var len = keys.length;
      var idx = -1;
      while (++idx < len) {
        var key = keys[idx];
        if (key in obj) {
          res[key] = obj[key];
        }
      }
      return res;
    };
  }
});

// node_modules/nanomatch/node_modules/kind-of/index.js
var require_kind_of10 = __commonJS({
  "node_modules/nanomatch/node_modules/kind-of/index.js"(exports, module2) {
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      if (val === void 0)
        return "undefined";
      if (val === null)
        return "null";
      var type = typeof val;
      if (type === "boolean")
        return "boolean";
      if (type === "string")
        return "string";
      if (type === "number")
        return "number";
      if (type === "symbol")
        return "symbol";
      if (type === "function") {
        return isGeneratorFn(val) ? "generatorfunction" : "function";
      }
      if (isArray(val))
        return "array";
      if (isBuffer(val))
        return "buffer";
      if (isArguments(val))
        return "arguments";
      if (isDate(val))
        return "date";
      if (isError(val))
        return "error";
      if (isRegexp(val))
        return "regexp";
      switch (ctorName(val)) {
        case "Symbol":
          return "symbol";
        case "Promise":
          return "promise";
        case "WeakMap":
          return "weakmap";
        case "WeakSet":
          return "weakset";
        case "Map":
          return "map";
        case "Set":
          return "set";
        case "Int8Array":
          return "int8array";
        case "Uint8Array":
          return "uint8array";
        case "Uint8ClampedArray":
          return "uint8clampedarray";
        case "Int16Array":
          return "int16array";
        case "Uint16Array":
          return "uint16array";
        case "Int32Array":
          return "int32array";
        case "Uint32Array":
          return "uint32array";
        case "Float32Array":
          return "float32array";
        case "Float64Array":
          return "float64array";
      }
      if (isGeneratorObj(val)) {
        return "generator";
      }
      type = toString.call(val);
      switch (type) {
        case "[object Object]":
          return "object";
        case "[object Map Iterator]":
          return "mapiterator";
        case "[object Set Iterator]":
          return "setiterator";
        case "[object String Iterator]":
          return "stringiterator";
        case "[object Array Iterator]":
          return "arrayiterator";
      }
      return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
    };
    function ctorName(val) {
      return typeof val.constructor === "function" ? val.constructor.name : null;
    }
    function isArray(val) {
      if (Array.isArray)
        return Array.isArray(val);
      return val instanceof Array;
    }
    function isError(val) {
      return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
    }
    function isDate(val) {
      if (val instanceof Date)
        return true;
      return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
    }
    function isRegexp(val) {
      if (val instanceof RegExp)
        return true;
      return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
    }
    function isGeneratorFn(name, val) {
      return ctorName(name) === "GeneratorFunction";
    }
    function isGeneratorObj(val) {
      return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
    }
    function isArguments(val) {
      try {
        if (typeof val.length === "number" && typeof val.callee === "function") {
          return true;
        }
      } catch (err) {
        if (err.message.indexOf("callee") !== -1) {
          return true;
        }
      }
      return false;
    }
    function isBuffer(val) {
      if (val.constructor && typeof val.constructor.isBuffer === "function") {
        return val.constructor.isBuffer(val);
      }
      return false;
    }
  }
});

// node_modules/nanomatch/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/nanomatch/lib/utils.js"(exports, module2) {
    "use strict";
    var utils = module2.exports;
    var path = require("path");
    var isWindows = require_is_windows()();
    var Snapdragon = require_snapdragon();
    utils.define = require_define_property();
    utils.diff = require_arr_diff();
    utils.extend = require_extend_shallow6();
    utils.pick = require_object();
    utils.typeOf = require_kind_of10();
    utils.unique = require_array_unique();
    utils.isEmptyString = function(val) {
      return String(val) === "" || String(val) === "./";
    };
    utils.isWindows = function() {
      return path.sep === "\\" || isWindows === true;
    };
    utils.last = function(arr, n) {
      return arr[arr.length - (n || 1)];
    };
    utils.instantiate = function(ast, options) {
      var snapdragon;
      if (utils.typeOf(ast) === "object" && ast.snapdragon) {
        snapdragon = ast.snapdragon;
      } else if (utils.typeOf(options) === "object" && options.snapdragon) {
        snapdragon = options.snapdragon;
      } else {
        snapdragon = new Snapdragon(options);
      }
      utils.define(snapdragon, "parse", function(str, options2) {
        var parsed = Snapdragon.prototype.parse.call(this, str, options2);
        parsed.input = str;
        var last = this.parser.stack.pop();
        if (last && this.options.strictErrors !== true) {
          var open = last.nodes[0];
          var inner = last.nodes[1];
          if (last.type === "bracket") {
            if (inner.val.charAt(0) === "[") {
              inner.val = "\\" + inner.val;
            }
          } else {
            open.val = "\\" + open.val;
            var sibling = open.parent.nodes[1];
            if (sibling.type === "star") {
              sibling.loose = true;
            }
          }
        }
        utils.define(parsed, "parser", this.parser);
        return parsed;
      });
      return snapdragon;
    };
    utils.createKey = function(pattern, options) {
      if (typeof options === "undefined") {
        return pattern;
      }
      var key = pattern;
      for (var prop in options) {
        if (options.hasOwnProperty(prop)) {
          key += ";" + prop + "=" + String(options[prop]);
        }
      }
      return key;
    };
    utils.arrayify = function(val) {
      if (typeof val === "string")
        return [val];
      return val ? Array.isArray(val) ? val : [val] : [];
    };
    utils.isString = function(val) {
      return typeof val === "string";
    };
    utils.isRegex = function(val) {
      return utils.typeOf(val) === "regexp";
    };
    utils.isObject = function(val) {
      return utils.typeOf(val) === "object";
    };
    utils.escapeRegex = function(str) {
      return str.replace(/[-[\]{}()^$|*+?.\\/\s]/g, "\\$&");
    };
    utils.combineDupes = function(input, patterns) {
      patterns = utils.arrayify(patterns).join("|").split("|");
      patterns = patterns.map(function(s) {
        return s.replace(/\\?([+*\\/])/g, "\\$1");
      });
      var substr = patterns.join("|");
      var regex = new RegExp("(" + substr + ")(?=\\1)", "g");
      return input.replace(regex, "");
    };
    utils.hasSpecialChars = function(str) {
      return /(?:(?:(^|\/)[!.])|[*?+()|[\]{}]|[+@]\()/.test(str);
    };
    utils.toPosixPath = function(str) {
      return str.replace(/\\+/g, "/");
    };
    utils.unescape = function(str) {
      return utils.toPosixPath(str.replace(/\\(?=[*+?!.])/g, ""));
    };
    utils.stripDrive = function(fp) {
      return utils.isWindows() ? fp.replace(/^[a-z]:[\\/]+?/i, "/") : fp;
    };
    utils.stripPrefix = function(str) {
      if (str.charAt(0) === "." && (str.charAt(1) === "/" || str.charAt(1) === "\\")) {
        return str.slice(2);
      }
      return str;
    };
    utils.isSimpleChar = function(str) {
      return str.trim() === "" || str === ".";
    };
    utils.isSlash = function(str) {
      return str === "/" || str === "\\/" || str === "\\" || str === "\\\\";
    };
    utils.matchPath = function(pattern, options) {
      return options && options.contains ? utils.containsPattern(pattern, options) : utils.equalsPattern(pattern, options);
    };
    utils._equals = function(filepath, unixPath, pattern) {
      return pattern === filepath || pattern === unixPath;
    };
    utils._contains = function(filepath, unixPath, pattern) {
      return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;
    };
    utils.equalsPattern = function(pattern, options) {
      var unixify = utils.unixify(options);
      options = options || {};
      return function fn(filepath) {
        var equal = utils._equals(filepath, unixify(filepath), pattern);
        if (equal === true || options.nocase !== true) {
          return equal;
        }
        var lower = filepath.toLowerCase();
        return utils._equals(lower, unixify(lower), pattern);
      };
    };
    utils.containsPattern = function(pattern, options) {
      var unixify = utils.unixify(options);
      options = options || {};
      return function(filepath) {
        var contains = utils._contains(filepath, unixify(filepath), pattern);
        if (contains === true || options.nocase !== true) {
          return contains;
        }
        var lower = filepath.toLowerCase();
        return utils._contains(lower, unixify(lower), pattern);
      };
    };
    utils.matchBasename = function(re) {
      return function(filepath) {
        return re.test(filepath) || re.test(path.basename(filepath));
      };
    };
    utils.identity = function(val) {
      return val;
    };
    utils.value = function(str, unixify, options) {
      if (options && options.unixify === false) {
        return str;
      }
      if (options && typeof options.unixify === "function") {
        return options.unixify(str);
      }
      return unixify(str);
    };
    utils.unixify = function(options) {
      var opts = options || {};
      return function(filepath) {
        if (opts.stripPrefix !== false) {
          filepath = utils.stripPrefix(filepath);
        }
        if (opts.unescape === true) {
          filepath = utils.unescape(filepath);
        }
        if (opts.unixify === true || utils.isWindows()) {
          filepath = utils.toPosixPath(filepath);
        }
        return filepath;
      };
    };
  }
});

// node_modules/nanomatch/index.js
var require_nanomatch = __commonJS({
  "node_modules/nanomatch/index.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var toRegex = require_to_regex();
    var extend = require_extend_shallow6();
    var compilers = require_compilers2();
    var parsers = require_parsers2();
    var cache = require_cache();
    var utils = require_utils4();
    var MAX_LENGTH = 1024 * 64;
    function nanomatch(list, patterns, options) {
      patterns = utils.arrayify(patterns);
      list = utils.arrayify(list);
      var len = patterns.length;
      if (list.length === 0 || len === 0) {
        return [];
      }
      if (len === 1) {
        return nanomatch.match(list, patterns[0], options);
      }
      var negated = false;
      var omit = [];
      var keep = [];
      var idx = -1;
      while (++idx < len) {
        var pattern = patterns[idx];
        if (typeof pattern === "string" && pattern.charCodeAt(0) === 33) {
          omit.push.apply(omit, nanomatch.match(list, pattern.slice(1), options));
          negated = true;
        } else {
          keep.push.apply(keep, nanomatch.match(list, pattern, options));
        }
      }
      if (negated && keep.length === 0) {
        if (options && options.unixify === false) {
          keep = list.slice();
        } else {
          var unixify = utils.unixify(options);
          for (var i = 0; i < list.length; i++) {
            keep.push(unixify(list[i]));
          }
        }
      }
      var matches = utils.diff(keep, omit);
      if (!options || options.nodupes !== false) {
        return utils.unique(matches);
      }
      return matches;
    }
    nanomatch.match = function(list, pattern, options) {
      if (Array.isArray(pattern)) {
        throw new TypeError("expected pattern to be a string");
      }
      var unixify = utils.unixify(options);
      var isMatch = memoize("match", pattern, options, nanomatch.matcher);
      var matches = [];
      list = utils.arrayify(list);
      var len = list.length;
      var idx = -1;
      while (++idx < len) {
        var ele = list[idx];
        if (ele === pattern || isMatch(ele)) {
          matches.push(utils.value(ele, unixify, options));
        }
      }
      if (typeof options === "undefined") {
        return utils.unique(matches);
      }
      if (matches.length === 0) {
        if (options.failglob === true) {
          throw new Error('no matches found for "' + pattern + '"');
        }
        if (options.nonull === true || options.nullglob === true) {
          return [options.unescape ? utils.unescape(pattern) : pattern];
        }
      }
      if (options.ignore) {
        matches = nanomatch.not(matches, options.ignore, options);
      }
      return options.nodupes !== false ? utils.unique(matches) : matches;
    };
    nanomatch.isMatch = function(str, pattern, options) {
      if (typeof str !== "string") {
        throw new TypeError('expected a string: "' + util.inspect(str) + '"');
      }
      if (utils.isEmptyString(str) || utils.isEmptyString(pattern)) {
        return false;
      }
      var equals = utils.equalsPattern(options);
      if (equals(str)) {
        return true;
      }
      var isMatch = memoize("isMatch", pattern, options, nanomatch.matcher);
      return isMatch(str);
    };
    nanomatch.some = function(list, patterns, options) {
      if (typeof list === "string") {
        list = [list];
      }
      for (var i = 0; i < list.length; i++) {
        if (nanomatch(list[i], patterns, options).length === 1) {
          return true;
        }
      }
      return false;
    };
    nanomatch.every = function(list, patterns, options) {
      if (typeof list === "string") {
        list = [list];
      }
      for (var i = 0; i < list.length; i++) {
        if (nanomatch(list[i], patterns, options).length !== 1) {
          return false;
        }
      }
      return true;
    };
    nanomatch.any = function(str, patterns, options) {
      if (typeof str !== "string") {
        throw new TypeError('expected a string: "' + util.inspect(str) + '"');
      }
      if (utils.isEmptyString(str) || utils.isEmptyString(patterns)) {
        return false;
      }
      if (typeof patterns === "string") {
        patterns = [patterns];
      }
      for (var i = 0; i < patterns.length; i++) {
        if (nanomatch.isMatch(str, patterns[i], options)) {
          return true;
        }
      }
      return false;
    };
    nanomatch.all = function(str, patterns, options) {
      if (typeof str !== "string") {
        throw new TypeError('expected a string: "' + util.inspect(str) + '"');
      }
      if (typeof patterns === "string") {
        patterns = [patterns];
      }
      for (var i = 0; i < patterns.length; i++) {
        if (!nanomatch.isMatch(str, patterns[i], options)) {
          return false;
        }
      }
      return true;
    };
    nanomatch.not = function(list, patterns, options) {
      var opts = extend({}, options);
      var ignore = opts.ignore;
      delete opts.ignore;
      list = utils.arrayify(list);
      var matches = utils.diff(list, nanomatch(list, patterns, opts));
      if (ignore) {
        matches = utils.diff(matches, nanomatch(list, ignore));
      }
      return opts.nodupes !== false ? utils.unique(matches) : matches;
    };
    nanomatch.contains = function(str, patterns, options) {
      if (typeof str !== "string") {
        throw new TypeError('expected a string: "' + util.inspect(str) + '"');
      }
      if (typeof patterns === "string") {
        if (utils.isEmptyString(str) || utils.isEmptyString(patterns)) {
          return false;
        }
        var equals = utils.equalsPattern(patterns, options);
        if (equals(str)) {
          return true;
        }
        var contains = utils.containsPattern(patterns, options);
        if (contains(str)) {
          return true;
        }
      }
      var opts = extend({}, options, { contains: true });
      return nanomatch.any(str, patterns, opts);
    };
    nanomatch.matchBase = function(pattern, options) {
      if (pattern && pattern.indexOf("/") !== -1 || !options)
        return false;
      return options.basename === true || options.matchBase === true;
    };
    nanomatch.matchKeys = function(obj, patterns, options) {
      if (!utils.isObject(obj)) {
        throw new TypeError("expected the first argument to be an object");
      }
      var keys = nanomatch(Object.keys(obj), patterns, options);
      return utils.pick(obj, keys);
    };
    nanomatch.matcher = function matcher(pattern, options) {
      if (utils.isEmptyString(pattern)) {
        return function() {
          return false;
        };
      }
      if (Array.isArray(pattern)) {
        return compose(pattern, options, matcher);
      }
      if (pattern instanceof RegExp) {
        return test(pattern);
      }
      if (!utils.isString(pattern)) {
        throw new TypeError("expected pattern to be an array, string or regex");
      }
      if (!utils.hasSpecialChars(pattern)) {
        if (options && options.nocase === true) {
          pattern = pattern.toLowerCase();
        }
        return utils.matchPath(pattern, options);
      }
      var re = nanomatch.makeRe(pattern, options);
      if (nanomatch.matchBase(pattern, options)) {
        return utils.matchBasename(re, options);
      }
      function test(regex) {
        var equals = utils.equalsPattern(options);
        var unixify = utils.unixify(options);
        return function(str) {
          if (equals(str)) {
            return true;
          }
          if (regex.test(unixify(str))) {
            return true;
          }
          return false;
        };
      }
      var matcherFn = test(re);
      utils.define(matcherFn, "result", re.result);
      return matcherFn;
    };
    nanomatch.capture = function(pattern, str, options) {
      var re = nanomatch.makeRe(pattern, extend({ capture: true }, options));
      var unixify = utils.unixify(options);
      function match() {
        return function(string) {
          var match2 = re.exec(unixify(string));
          if (!match2) {
            return null;
          }
          return match2.slice(1);
        };
      }
      var capture = memoize("capture", pattern, options, match);
      return capture(str);
    };
    nanomatch.makeRe = function(pattern, options) {
      if (pattern instanceof RegExp) {
        return pattern;
      }
      if (typeof pattern !== "string") {
        throw new TypeError("expected pattern to be a string");
      }
      if (pattern.length > MAX_LENGTH) {
        throw new Error("expected pattern to be less than " + MAX_LENGTH + " characters");
      }
      function makeRe() {
        var opts = utils.extend({ wrap: false }, options);
        var result = nanomatch.create(pattern, opts);
        var regex = toRegex(result.output, opts);
        utils.define(regex, "result", result);
        return regex;
      }
      return memoize("makeRe", pattern, options, makeRe);
    };
    nanomatch.create = function(pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("expected a string");
      }
      function create() {
        return nanomatch.compile(nanomatch.parse(pattern, options), options);
      }
      return memoize("create", pattern, options, create);
    };
    nanomatch.parse = function(pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("expected a string");
      }
      function parse() {
        var snapdragon = utils.instantiate(null, options);
        parsers(snapdragon, options);
        var ast = snapdragon.parse(pattern, options);
        utils.define(ast, "snapdragon", snapdragon);
        ast.input = pattern;
        return ast;
      }
      return memoize("parse", pattern, options, parse);
    };
    nanomatch.compile = function(ast, options) {
      if (typeof ast === "string") {
        ast = nanomatch.parse(ast, options);
      }
      function compile() {
        var snapdragon = utils.instantiate(ast, options);
        compilers(snapdragon, options);
        return snapdragon.compile(ast, options);
      }
      return memoize("compile", ast.input, options, compile);
    };
    nanomatch.clearCache = function() {
      nanomatch.cache.__data__ = {};
    };
    function compose(patterns, options, matcher) {
      var matchers;
      return memoize("compose", String(patterns), options, function() {
        return function(file) {
          if (!matchers) {
            matchers = [];
            for (var i = 0; i < patterns.length; i++) {
              matchers.push(matcher(patterns[i], options));
            }
          }
          var len = matchers.length;
          while (len--) {
            if (matchers[len](file) === true) {
              return true;
            }
          }
          return false;
        };
      });
    }
    function memoize(type, pattern, options, fn) {
      var key = utils.createKey(type + "=" + pattern, options);
      if (options && options.cache === false) {
        return fn(pattern, options);
      }
      if (cache.has(type, key)) {
        return cache.get(type, key);
      }
      var val = fn(pattern, options);
      cache.set(type, key, val);
      return val;
    }
    nanomatch.compilers = compilers;
    nanomatch.parsers = parsers;
    nanomatch.cache = cache;
    module2.exports = nanomatch;
  }
});

// node_modules/posix-character-classes/index.js
var require_posix_character_classes = __commonJS({
  "node_modules/posix-character-classes/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
  }
});

// node_modules/expand-brackets/lib/compilers.js
var require_compilers3 = __commonJS({
  "node_modules/expand-brackets/lib/compilers.js"(exports, module2) {
    "use strict";
    var posix = require_posix_character_classes();
    module2.exports = function(brackets) {
      brackets.compiler.set("escape", function(node) {
        return this.emit("\\" + node.val.replace(/^\\/, ""), node);
      }).set("text", function(node) {
        return this.emit(node.val.replace(/([{}])/g, "\\$1"), node);
      }).set("posix", function(node) {
        if (node.val === "[::]") {
          return this.emit("\\[::\\]", node);
        }
        var val = posix[node.inner];
        if (typeof val === "undefined") {
          val = "[" + node.inner + "]";
        }
        return this.emit(val, node);
      }).set("bracket", function(node) {
        return this.mapVisit(node.nodes);
      }).set("bracket.open", function(node) {
        return this.emit(node.val, node);
      }).set("bracket.inner", function(node) {
        var inner = node.val;
        if (inner === "[" || inner === "]") {
          return this.emit("\\" + node.val, node);
        }
        if (inner === "^]") {
          return this.emit("^\\]", node);
        }
        if (inner === "^") {
          return this.emit("^", node);
        }
        if (/-/.test(inner) && !/(\d-\d|\w-\w)/.test(inner)) {
          inner = inner.split("-").join("\\-");
        }
        var isNegated = inner.charAt(0) === "^";
        if (isNegated && inner.indexOf("/") === -1) {
          inner += "/";
        }
        if (isNegated && inner.indexOf(".") === -1) {
          inner += ".";
        }
        inner = inner.replace(/\\([1-9])/g, "$1");
        return this.emit(inner, node);
      }).set("bracket.close", function(node) {
        var val = node.val.replace(/^\\/, "");
        if (node.parent.escaped === true) {
          return this.emit("\\" + val, node);
        }
        return this.emit(val, node);
      });
    };
  }
});

// node_modules/expand-brackets/lib/utils.js
var require_utils5 = __commonJS({
  "node_modules/expand-brackets/lib/utils.js"(exports) {
    "use strict";
    var toRegex = require_to_regex();
    var regexNot = require_regex_not();
    var cached;
    exports.last = function(arr) {
      return arr[arr.length - 1];
    };
    exports.createRegex = function(pattern, include) {
      if (cached)
        return cached;
      var opts = { contains: true, strictClose: false };
      var not = regexNot.create(pattern, opts);
      var re;
      if (typeof include === "string") {
        re = toRegex("^(?:" + include + "|" + not + ")", opts);
      } else {
        re = toRegex(not, opts);
      }
      return cached = re;
    };
  }
});

// node_modules/expand-brackets/node_modules/is-descriptor/node_modules/kind-of/index.js
var require_kind_of11 = __commonJS({
  "node_modules/expand-brackets/node_modules/is-descriptor/node_modules/kind-of/index.js"(exports, module2) {
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      var type = typeof val;
      if (type === "undefined") {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }
      if (val === true || val === false || val instanceof Boolean) {
        return "boolean";
      }
      if (type === "string" || val instanceof String) {
        return "string";
      }
      if (type === "number" || val instanceof Number) {
        return "number";
      }
      if (type === "function" || val instanceof Function) {
        if (typeof val.constructor.name !== "undefined" && val.constructor.name.slice(0, 9) === "Generator") {
          return "generatorfunction";
        }
        return "function";
      }
      if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
        return "array";
      }
      if (val instanceof RegExp) {
        return "regexp";
      }
      if (val instanceof Date) {
        return "date";
      }
      type = toString.call(val);
      if (type === "[object RegExp]") {
        return "regexp";
      }
      if (type === "[object Date]") {
        return "date";
      }
      if (type === "[object Arguments]") {
        return "arguments";
      }
      if (type === "[object Error]") {
        return "error";
      }
      if (type === "[object Promise]") {
        return "promise";
      }
      if (isBuffer(val)) {
        return "buffer";
      }
      if (type === "[object Set]") {
        return "set";
      }
      if (type === "[object WeakSet]") {
        return "weakset";
      }
      if (type === "[object Map]") {
        return "map";
      }
      if (type === "[object WeakMap]") {
        return "weakmap";
      }
      if (type === "[object Symbol]") {
        return "symbol";
      }
      if (type === "[object Map Iterator]") {
        return "mapiterator";
      }
      if (type === "[object Set Iterator]") {
        return "setiterator";
      }
      if (type === "[object String Iterator]") {
        return "stringiterator";
      }
      if (type === "[object Array Iterator]") {
        return "arrayiterator";
      }
      if (type === "[object Int8Array]") {
        return "int8array";
      }
      if (type === "[object Uint8Array]") {
        return "uint8array";
      }
      if (type === "[object Uint8ClampedArray]") {
        return "uint8clampedarray";
      }
      if (type === "[object Int16Array]") {
        return "int16array";
      }
      if (type === "[object Uint16Array]") {
        return "uint16array";
      }
      if (type === "[object Int32Array]") {
        return "int32array";
      }
      if (type === "[object Uint32Array]") {
        return "uint32array";
      }
      if (type === "[object Float32Array]") {
        return "float32array";
      }
      if (type === "[object Float64Array]") {
        return "float64array";
      }
      return "object";
    };
    function isBuffer(val) {
      return val.constructor && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
  }
});

// node_modules/expand-brackets/node_modules/is-accessor-descriptor/index.js
var require_is_accessor_descriptor6 = __commonJS({
  "node_modules/expand-brackets/node_modules/is-accessor-descriptor/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of4();
    var accessor = {
      get: "function",
      set: "function",
      configurable: "boolean",
      enumerable: "boolean"
    };
    function isAccessorDescriptor(obj, prop) {
      if (typeof prop === "string") {
        var val = Object.getOwnPropertyDescriptor(obj, prop);
        return typeof val !== "undefined";
      }
      if (typeOf(obj) !== "object") {
        return false;
      }
      if (has(obj, "value") || has(obj, "writable")) {
        return false;
      }
      if (!has(obj, "get") || typeof obj.get !== "function") {
        return false;
      }
      if (has(obj, "set") && typeof obj[key] !== "function" && typeof obj[key] !== "undefined") {
        return false;
      }
      for (var key in obj) {
        if (!accessor.hasOwnProperty(key)) {
          continue;
        }
        if (typeOf(obj[key]) === accessor[key]) {
          continue;
        }
        if (typeof obj[key] !== "undefined") {
          return false;
        }
      }
      return true;
    }
    function has(obj, key) {
      return {}.hasOwnProperty.call(obj, key);
    }
    module2.exports = isAccessorDescriptor;
  }
});

// node_modules/expand-brackets/node_modules/is-data-descriptor/index.js
var require_is_data_descriptor6 = __commonJS({
  "node_modules/expand-brackets/node_modules/is-data-descriptor/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of4();
    var data = {
      configurable: "boolean",
      enumerable: "boolean",
      writable: "boolean"
    };
    function isDataDescriptor(obj, prop) {
      if (typeOf(obj) !== "object") {
        return false;
      }
      if (typeof prop === "string") {
        var val = Object.getOwnPropertyDescriptor(obj, prop);
        return typeof val !== "undefined";
      }
      if (!("value" in obj) && !("writable" in obj)) {
        return false;
      }
      for (var key in obj) {
        if (key === "value")
          continue;
        if (!data.hasOwnProperty(key)) {
          continue;
        }
        if (typeOf(obj[key]) === data[key]) {
          continue;
        }
        if (typeof obj[key] !== "undefined") {
          return false;
        }
      }
      return true;
    }
    module2.exports = isDataDescriptor;
  }
});

// node_modules/expand-brackets/node_modules/is-descriptor/index.js
var require_is_descriptor6 = __commonJS({
  "node_modules/expand-brackets/node_modules/is-descriptor/index.js"(exports, module2) {
    "use strict";
    var typeOf = require_kind_of11();
    var isAccessor = require_is_accessor_descriptor6();
    var isData = require_is_data_descriptor6();
    module2.exports = function isDescriptor(obj, key) {
      if (typeOf(obj) !== "object") {
        return false;
      }
      if ("get" in obj) {
        return isAccessor(obj, key);
      }
      return isData(obj, key);
    };
  }
});

// node_modules/expand-brackets/node_modules/define-property/index.js
var require_define_property8 = __commonJS({
  "node_modules/expand-brackets/node_modules/define-property/index.js"(exports, module2) {
    "use strict";
    var isDescriptor = require_is_descriptor6();
    module2.exports = function defineProperty(obj, prop, val) {
      if (typeof obj !== "object" && typeof obj !== "function") {
        throw new TypeError("expected an object or function.");
      }
      if (typeof prop !== "string") {
        throw new TypeError("expected `prop` to be a string.");
      }
      if (isDescriptor(val) && ("set" in val || "get" in val)) {
        return Object.defineProperty(obj, prop, val);
      }
      return Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val
      });
    };
  }
});

// node_modules/expand-brackets/lib/parsers.js
var require_parsers3 = __commonJS({
  "node_modules/expand-brackets/lib/parsers.js"(exports, module2) {
    "use strict";
    var utils = require_utils5();
    var define2 = require_define_property8();
    var TEXT_REGEX = "(\\[(?=.*\\])|\\])+";
    var not = utils.createRegex(TEXT_REGEX);
    function parsers(brackets) {
      brackets.state = brackets.state || {};
      brackets.parser.sets.bracket = brackets.parser.sets.bracket || [];
      brackets.parser.capture("escape", function() {
        if (this.isInside("bracket"))
          return;
        var pos = this.position();
        var m = this.match(/^\\(.)/);
        if (!m)
          return;
        return pos({
          type: "escape",
          val: m[0]
        });
      }).capture("text", function() {
        if (this.isInside("bracket"))
          return;
        var pos = this.position();
        var m = this.match(not);
        if (!m || !m[0])
          return;
        return pos({
          type: "text",
          val: m[0]
        });
      }).capture("posix", function() {
        var pos = this.position();
        var m = this.match(/^\[:(.*?):\](?=.*\])/);
        if (!m)
          return;
        var inside = this.isInside("bracket");
        if (inside) {
          brackets.posix++;
        }
        return pos({
          type: "posix",
          insideBracket: inside,
          inner: m[1],
          val: m[0]
        });
      }).capture("bracket", function() {
      }).capture("bracket.open", function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\[(?=.*\])/);
        if (!m)
          return;
        var prev = this.prev();
        var last = utils.last(prev.nodes);
        if (parsed.slice(-1) === "\\" && !this.isInside("bracket")) {
          last.val = last.val.slice(0, last.val.length - 1);
          return pos({
            type: "escape",
            val: m[0]
          });
        }
        var open = pos({
          type: "bracket.open",
          val: m[0]
        });
        if (last.type === "bracket.open" || this.isInside("bracket")) {
          open.val = "\\" + open.val;
          open.type = "bracket.inner";
          open.escaped = true;
          return open;
        }
        var node = pos({
          type: "bracket",
          nodes: [open]
        });
        define2(node, "parent", prev);
        define2(open, "parent", node);
        this.push("bracket", node);
        prev.nodes.push(node);
      }).capture("bracket.inner", function() {
        if (!this.isInside("bracket"))
          return;
        var pos = this.position();
        var m = this.match(not);
        if (!m || !m[0])
          return;
        var next = this.input.charAt(0);
        var val = m[0];
        var node = pos({
          type: "bracket.inner",
          val
        });
        if (val === "\\\\") {
          return node;
        }
        var first = val.charAt(0);
        var last = val.slice(-1);
        if (first === "!") {
          val = "^" + val.slice(1);
        }
        if (last === "\\" || val === "^" && next === "]") {
          val += this.input[0];
          this.consume(1);
        }
        node.val = val;
        return node;
      }).capture("bracket.close", function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\]/);
        if (!m)
          return;
        var prev = this.prev();
        var last = utils.last(prev.nodes);
        if (parsed.slice(-1) === "\\" && !this.isInside("bracket")) {
          last.val = last.val.slice(0, last.val.length - 1);
          return pos({
            type: "escape",
            val: m[0]
          });
        }
        var node = pos({
          type: "bracket.close",
          rest: this.input,
          val: m[0]
        });
        if (last.type === "bracket.open") {
          node.type = "bracket.inner";
          node.escaped = true;
          return node;
        }
        var bracket = this.pop("bracket");
        if (!this.isType(bracket, "bracket")) {
          if (this.options.strict) {
            throw new Error('missing opening "["');
          }
          node.type = "bracket.inner";
          node.escaped = true;
          return node;
        }
        bracket.nodes.push(node);
        define2(node, "parent", bracket);
      });
    }
    module2.exports = parsers;
    module2.exports.TEXT_REGEX = TEXT_REGEX;
  }
});

// node_modules/expand-brackets/node_modules/ms/index.js
var require_ms2 = __commonJS({
  "node_modules/expand-brackets/node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/expand-brackets/node_modules/debug/src/debug.js
var require_debug2 = __commonJS({
  "node_modules/expand-brackets/node_modules/debug/src/debug.js"(exports, module2) {
    exports = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = require_ms2();
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports.colors[Math.abs(hash) % exports.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports.formatters[format];
          if (typeof formatter === "function") {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports.formatArgs.call(self2, args);
        var logFn = debug.log || exports.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports.enabled(namespace);
      debug.useColors = exports.useColors();
      debug.color = selectColor(namespace);
      if (typeof exports.init === "function") {
        exports.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      exports.names = [];
      exports.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// node_modules/expand-brackets/node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/expand-brackets/node_modules/debug/src/browser.js"(exports, module2) {
    exports = module2.exports = require_debug2();
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
    exports.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if (match === "%%")
          return;
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (namespaces == null) {
          exports.storage.removeItem("debug");
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// node_modules/expand-brackets/node_modules/debug/src/node.js
var require_node2 = __commonJS({
  "node_modules/expand-brackets/node_modules/debug/src/node.js"(exports, module2) {
    var tty = require("tty");
    var util = require("util");
    exports = module2.exports = require_debug2();
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.colors = [6, 2, 3, 4, 5, 1];
    exports.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val))
        val = true;
      else if (/^(no|off|false|disabled)$/i.test(val))
        val = false;
      else if (val === "null")
        val = null;
      else
        val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (fd !== 1 && fd !== 2) {
      util.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
    }
    exports.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var prefix = "  \x1B[3" + c + ";1m" + name + " \x1B[0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("\x1B[3" + c + "m+" + exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = new Date().toUTCString() + " " + name + " " + args[0];
      }
    }
    function log() {
      return stream.write(util.format.apply(util, arguments) + "\n");
    }
    function save(namespaces) {
      if (namespaces == null) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream2;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream2 = new tty.WriteStream(fd2);
          stream2._type = "tty";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        case "FILE":
          var fs = require("fs");
          stream2 = new fs.SyncWriteStream(fd2, { autoClose: false });
          stream2._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net = require("net");
          stream2 = new net.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream2.readable = false;
          stream2.read = null;
          stream2._type = "pipe";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream2.fd = fd2;
      stream2._isStdio = true;
      return stream2;
    }
    function init(debug) {
      debug.inspectOpts = {};
      var keys = Object.keys(exports.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    exports.enable(load());
  }
});

// node_modules/expand-brackets/node_modules/debug/src/index.js
var require_src2 = __commonJS({
  "node_modules/expand-brackets/node_modules/debug/src/index.js"(exports, module2) {
    if (typeof process !== "undefined" && process.type === "renderer") {
      module2.exports = require_browser2();
    } else {
      module2.exports = require_node2();
    }
  }
});

// node_modules/expand-brackets/index.js
var require_expand_brackets = __commonJS({
  "node_modules/expand-brackets/index.js"(exports, module2) {
    "use strict";
    var compilers = require_compilers3();
    var parsers = require_parsers3();
    var debug = require_src2()("expand-brackets");
    var extend = require_extend_shallow3();
    var Snapdragon = require_snapdragon();
    var toRegex = require_to_regex();
    function brackets(pattern, options) {
      debug("initializing from <%s>", __filename);
      var res = brackets.create(pattern, options);
      return res.output;
    }
    brackets.match = function(arr, pattern, options) {
      arr = [].concat(arr);
      var opts = extend({}, options);
      var isMatch = brackets.matcher(pattern, opts);
      var len = arr.length;
      var idx = -1;
      var res = [];
      while (++idx < len) {
        var ele = arr[idx];
        if (isMatch(ele)) {
          res.push(ele);
        }
      }
      if (res.length === 0) {
        if (opts.failglob === true) {
          throw new Error('no matches found for "' + pattern + '"');
        }
        if (opts.nonull === true || opts.nullglob === true) {
          return [pattern.split("\\").join("")];
        }
      }
      return res;
    };
    brackets.isMatch = function(str, pattern, options) {
      return brackets.matcher(pattern, options)(str);
    };
    brackets.matcher = function(pattern, options) {
      var re = brackets.makeRe(pattern, options);
      return function(str) {
        return re.test(str);
      };
    };
    brackets.makeRe = function(pattern, options) {
      var res = brackets.create(pattern, options);
      var opts = extend({ strictErrors: false }, options);
      return toRegex(res.output, opts);
    };
    brackets.create = function(pattern, options) {
      var snapdragon = options && options.snapdragon || new Snapdragon(options);
      compilers(snapdragon);
      parsers(snapdragon);
      var ast = snapdragon.parse(pattern, options);
      ast.input = pattern;
      var res = snapdragon.compile(ast, options);
      res.input = pattern;
      return res;
    };
    brackets.compilers = compilers;
    brackets.parsers = parsers;
    module2.exports = brackets;
  }
});

// node_modules/extglob/lib/compilers.js
var require_compilers4 = __commonJS({
  "node_modules/extglob/lib/compilers.js"(exports, module2) {
    "use strict";
    var brackets = require_expand_brackets();
    module2.exports = function(extglob) {
      function star() {
        if (typeof extglob.options.star === "function") {
          return extglob.options.star.apply(this, arguments);
        }
        if (typeof extglob.options.star === "string") {
          return extglob.options.star;
        }
        return ".*?";
      }
      extglob.use(brackets.compilers);
      extglob.compiler.set("escape", function(node) {
        return this.emit(node.val, node);
      }).set("dot", function(node) {
        return this.emit("\\" + node.val, node);
      }).set("qmark", function(node) {
        var val = "[^\\\\/.]";
        var prev = this.prev();
        if (node.parsed.slice(-1) === "(") {
          var ch = node.rest.charAt(0);
          if (ch !== "!" && ch !== "=" && ch !== ":") {
            return this.emit(val, node);
          }
          return this.emit(node.val, node);
        }
        if (prev.type === "text" && prev.val) {
          return this.emit(val, node);
        }
        if (node.val.length > 1) {
          val += "{" + node.val.length + "}";
        }
        return this.emit(val, node);
      }).set("plus", function(node) {
        var prev = node.parsed.slice(-1);
        if (prev === "]" || prev === ")") {
          return this.emit(node.val, node);
        }
        var ch = this.output.slice(-1);
        if (!this.output || /[?*+]/.test(ch) && node.parent.type !== "bracket") {
          return this.emit("\\+", node);
        }
        if (/\w/.test(ch) && !node.inside) {
          return this.emit("+\\+?", node);
        }
        return this.emit("+", node);
      }).set("star", function(node) {
        var prev = this.prev();
        var prefix = prev.type !== "text" && prev.type !== "escape" ? "(?!\\.)" : "";
        return this.emit(prefix + star.call(this, node), node);
      }).set("paren", function(node) {
        return this.mapVisit(node.nodes);
      }).set("paren.open", function(node) {
        var capture = this.options.capture ? "(" : "";
        switch (node.parent.prefix) {
          case "!":
          case "^":
            return this.emit(capture + "(?:(?!(?:", node);
          case "*":
          case "+":
          case "?":
          case "@":
            return this.emit(capture + "(?:", node);
          default: {
            var val = node.val;
            if (this.options.bash === true) {
              val = "\\" + val;
            } else if (!this.options.capture && val === "(" && node.parent.rest[0] !== "?") {
              val += "?:";
            }
            return this.emit(val, node);
          }
        }
      }).set("paren.close", function(node) {
        var capture = this.options.capture ? ")" : "";
        switch (node.prefix) {
          case "!":
          case "^":
            var prefix = /^(\)|$)/.test(node.rest) ? "$" : "";
            var str = star.call(this, node);
            if (node.parent.hasSlash && !this.options.star && this.options.slash !== false) {
              str = ".*?";
            }
            return this.emit(prefix + ("))" + str + ")") + capture, node);
          case "*":
          case "+":
          case "?":
            return this.emit(")" + node.prefix + capture, node);
          case "@":
            return this.emit(")" + capture, node);
          default: {
            var val = (this.options.bash === true ? "\\" : "") + ")";
            return this.emit(val, node);
          }
        }
      }).set("text", function(node) {
        var val = node.val.replace(/[\[\]]/g, "\\$&");
        return this.emit(val, node);
      });
    };
  }
});

// node_modules/extglob/node_modules/define-property/index.js
var require_define_property9 = __commonJS({
  "node_modules/extglob/node_modules/define-property/index.js"(exports, module2) {
    "use strict";
    var isDescriptor = require_is_descriptor();
    module2.exports = function defineProperty(obj, prop, val) {
      if (typeof obj !== "object" && typeof obj !== "function") {
        throw new TypeError("expected an object or function.");
      }
      if (typeof prop !== "string") {
        throw new TypeError("expected `prop` to be a string.");
      }
      if (isDescriptor(val) && ("set" in val || "get" in val)) {
        return Object.defineProperty(obj, prop, val);
      }
      return Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val
      });
    };
  }
});

// node_modules/extglob/lib/utils.js
var require_utils6 = __commonJS({
  "node_modules/extglob/lib/utils.js"(exports, module2) {
    "use strict";
    var regex = require_regex_not();
    var Cache = require_fragment_cache();
    var utils = module2.exports;
    var cache = utils.cache = new Cache();
    utils.arrayify = function(val) {
      if (!Array.isArray(val)) {
        return [val];
      }
      return val;
    };
    utils.memoize = function(type, pattern, options, fn) {
      var key = utils.createKey(type + pattern, options);
      if (cache.has(type, key)) {
        return cache.get(type, key);
      }
      var val = fn(pattern, options);
      if (options && options.cache === false) {
        return val;
      }
      cache.set(type, key, val);
      return val;
    };
    utils.createKey = function(pattern, options) {
      var key = pattern;
      if (typeof options === "undefined") {
        return key;
      }
      for (var prop in options) {
        key += ";" + prop + "=" + String(options[prop]);
      }
      return key;
    };
    utils.createRegex = function(str) {
      var opts = { contains: true, strictClose: false };
      return regex(str, opts);
    };
  }
});

// node_modules/extglob/lib/parsers.js
var require_parsers4 = __commonJS({
  "node_modules/extglob/lib/parsers.js"(exports, module2) {
    "use strict";
    var brackets = require_expand_brackets();
    var define2 = require_define_property9();
    var utils = require_utils6();
    var TEXT_REGEX = "([!@*?+]?\\(|\\)|[*?.+\\\\]|\\[:?(?=.*\\])|:?\\])+";
    var not = utils.createRegex(TEXT_REGEX);
    function parsers(extglob) {
      extglob.state = extglob.state || {};
      extglob.use(brackets.parsers);
      extglob.parser.sets.paren = extglob.parser.sets.paren || [];
      extglob.parser.capture("paren.open", function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^([!@*?+])?\(/);
        if (!m)
          return;
        var prev = this.prev();
        var prefix = m[1];
        var val = m[0];
        var open = pos({
          type: "paren.open",
          parsed,
          val
        });
        var node = pos({
          type: "paren",
          prefix,
          nodes: [open]
        });
        if (prefix === "!" && prev.type === "paren" && prev.prefix === "!") {
          prev.prefix = "@";
          node.prefix = "@";
        }
        define2(node, "rest", this.input);
        define2(node, "parsed", parsed);
        define2(node, "parent", prev);
        define2(open, "parent", node);
        this.push("paren", node);
        prev.nodes.push(node);
      }).capture("paren.close", function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\)/);
        if (!m)
          return;
        var parent = this.pop("paren");
        var node = pos({
          type: "paren.close",
          rest: this.input,
          parsed,
          val: m[0]
        });
        if (!this.isType(parent, "paren")) {
          if (this.options.strict) {
            throw new Error('missing opening paren: "("');
          }
          node.escaped = true;
          return node;
        }
        node.prefix = parent.prefix;
        parent.nodes.push(node);
        define2(node, "parent", parent);
      }).capture("escape", function() {
        var pos = this.position();
        var m = this.match(/^\\(.)/);
        if (!m)
          return;
        return pos({
          type: "escape",
          val: m[0],
          ch: m[1]
        });
      }).capture("qmark", function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\?+(?!\()/);
        if (!m)
          return;
        extglob.state.metachar = true;
        return pos({
          type: "qmark",
          rest: this.input,
          parsed,
          val: m[0]
        });
      }).capture("star", /^\*(?!\()/).capture("plus", /^\+(?!\()/).capture("dot", /^\./).capture("text", not);
    }
    module2.exports.TEXT_REGEX = TEXT_REGEX;
    module2.exports = parsers;
  }
});

// node_modules/extglob/lib/extglob.js
var require_extglob = __commonJS({
  "node_modules/extglob/lib/extglob.js"(exports, module2) {
    "use strict";
    var Snapdragon = require_snapdragon();
    var define2 = require_define_property9();
    var extend = require_extend_shallow3();
    var compilers = require_compilers4();
    var parsers = require_parsers4();
    function Extglob(options) {
      this.options = extend({ source: "extglob" }, options);
      this.snapdragon = this.options.snapdragon || new Snapdragon(this.options);
      this.snapdragon.patterns = this.snapdragon.patterns || {};
      this.compiler = this.snapdragon.compiler;
      this.parser = this.snapdragon.parser;
      compilers(this.snapdragon);
      parsers(this.snapdragon);
      define2(this.snapdragon, "parse", function(str, options2) {
        var parsed = Snapdragon.prototype.parse.apply(this, arguments);
        parsed.input = str;
        var last = this.parser.stack.pop();
        if (last && this.options.strict !== true) {
          var node = last.nodes[0];
          node.val = "\\" + node.val;
          var sibling = node.parent.nodes[1];
          if (sibling.type === "star") {
            sibling.loose = true;
          }
        }
        define2(parsed, "parser", this.parser);
        return parsed;
      });
      define2(this, "parse", function(ast, options2) {
        return this.snapdragon.parse.apply(this.snapdragon, arguments);
      });
      define2(this, "compile", function(ast, options2) {
        return this.snapdragon.compile.apply(this.snapdragon, arguments);
      });
    }
    module2.exports = Extglob;
  }
});

// node_modules/extglob/index.js
var require_extglob2 = __commonJS({
  "node_modules/extglob/index.js"(exports, module2) {
    "use strict";
    var extend = require_extend_shallow3();
    var unique = require_array_unique();
    var toRegex = require_to_regex();
    var compilers = require_compilers4();
    var parsers = require_parsers4();
    var Extglob = require_extglob();
    var utils = require_utils6();
    var MAX_LENGTH = 1024 * 64;
    function extglob(pattern, options) {
      return extglob.create(pattern, options).output;
    }
    extglob.match = function(list, pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("expected pattern to be a string");
      }
      list = utils.arrayify(list);
      var isMatch = extglob.matcher(pattern, options);
      var len = list.length;
      var idx = -1;
      var matches = [];
      while (++idx < len) {
        var ele = list[idx];
        if (isMatch(ele)) {
          matches.push(ele);
        }
      }
      if (typeof options === "undefined") {
        return unique(matches);
      }
      if (matches.length === 0) {
        if (options.failglob === true) {
          throw new Error('no matches found for "' + pattern + '"');
        }
        if (options.nonull === true || options.nullglob === true) {
          return [pattern.split("\\").join("")];
        }
      }
      return options.nodupes !== false ? unique(matches) : matches;
    };
    extglob.isMatch = function(str, pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("expected pattern to be a string");
      }
      if (typeof str !== "string") {
        throw new TypeError("expected a string");
      }
      if (pattern === str) {
        return true;
      }
      if (pattern === "" || pattern === " " || pattern === ".") {
        return pattern === str;
      }
      var isMatch = utils.memoize("isMatch", pattern, options, extglob.matcher);
      return isMatch(str);
    };
    extglob.contains = function(str, pattern, options) {
      if (typeof str !== "string") {
        throw new TypeError("expected a string");
      }
      if (pattern === "" || pattern === " " || pattern === ".") {
        return pattern === str;
      }
      var opts = extend({}, options, { contains: true });
      opts.strictClose = false;
      opts.strictOpen = false;
      return extglob.isMatch(str, pattern, opts);
    };
    extglob.matcher = function(pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("expected pattern to be a string");
      }
      function matcher() {
        var re = extglob.makeRe(pattern, options);
        return function(str) {
          return re.test(str);
        };
      }
      return utils.memoize("matcher", pattern, options, matcher);
    };
    extglob.create = function(pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("expected pattern to be a string");
      }
      function create() {
        var ext = new Extglob(options);
        var ast = ext.parse(pattern, options);
        return ext.compile(ast, options);
      }
      return utils.memoize("create", pattern, options, create);
    };
    extglob.capture = function(pattern, str, options) {
      var re = extglob.makeRe(pattern, extend({ capture: true }, options));
      function match() {
        return function(string) {
          var match2 = re.exec(string);
          if (!match2) {
            return null;
          }
          return match2.slice(1);
        };
      }
      var capture = utils.memoize("capture", pattern, options, match);
      return capture(str);
    };
    extglob.makeRe = function(pattern, options) {
      if (pattern instanceof RegExp) {
        return pattern;
      }
      if (typeof pattern !== "string") {
        throw new TypeError("expected pattern to be a string");
      }
      if (pattern.length > MAX_LENGTH) {
        throw new Error("expected pattern to be less than " + MAX_LENGTH + " characters");
      }
      function makeRe() {
        var opts = extend({ strictErrors: false }, options);
        if (opts.strictErrors === true)
          opts.strict = true;
        var res = extglob.create(pattern, opts);
        return toRegex(res.output, opts);
      }
      var regex = utils.memoize("makeRe", pattern, options, makeRe);
      if (regex.source.length > MAX_LENGTH) {
        throw new SyntaxError("potentially malicious regex detected");
      }
      return regex;
    };
    extglob.cache = utils.cache;
    extglob.clearCache = function() {
      extglob.cache.__data__ = {};
    };
    extglob.Extglob = Extglob;
    extglob.compilers = compilers;
    extglob.parsers = parsers;
    module2.exports = extglob;
  }
});

// node_modules/micromatch/lib/compilers.js
var require_compilers5 = __commonJS({
  "node_modules/micromatch/lib/compilers.js"(exports, module2) {
    "use strict";
    var nanomatch = require_nanomatch();
    var extglob = require_extglob2();
    module2.exports = function(snapdragon) {
      var compilers = snapdragon.compiler.compilers;
      var opts = snapdragon.options;
      snapdragon.use(nanomatch.compilers);
      var escape = compilers.escape;
      var qmark = compilers.qmark;
      var slash = compilers.slash;
      var star = compilers.star;
      var text = compilers.text;
      var plus = compilers.plus;
      var dot = compilers.dot;
      if (opts.extglob === false || opts.noext === true) {
        snapdragon.compiler.use(escapeExtglobs);
      } else {
        snapdragon.use(extglob.compilers);
      }
      snapdragon.use(function() {
        this.options.star = this.options.star || function() {
          return "[^\\\\/]*?";
        };
      });
      snapdragon.compiler.set("dot", dot).set("escape", escape).set("plus", plus).set("slash", slash).set("qmark", qmark).set("star", star).set("text", text);
    };
    function escapeExtglobs(compiler) {
      compiler.set("paren", function(node) {
        var val = "";
        visit(node, function(tok) {
          if (tok.val)
            val += (/^\W/.test(tok.val) ? "\\" : "") + tok.val;
        });
        return this.emit(val, node);
      });
      function visit(node, fn) {
        return node.nodes ? mapVisit(node.nodes, fn) : fn(node);
      }
      function mapVisit(nodes, fn) {
        var len = nodes.length;
        var idx = -1;
        while (++idx < len) {
          visit(nodes[idx], fn);
        }
      }
    }
  }
});

// node_modules/micromatch/lib/parsers.js
var require_parsers5 = __commonJS({
  "node_modules/micromatch/lib/parsers.js"(exports, module2) {
    "use strict";
    var extglob = require_extglob2();
    var nanomatch = require_nanomatch();
    var regexNot = require_regex_not();
    var toRegex = require_to_regex();
    var not;
    var TEXT = "([!@*?+]?\\(|\\)|\\[:?(?=.*?:?\\])|:?\\]|[*+?!^$.\\\\/])+";
    var createNotRegex = function(opts) {
      return not || (not = textRegex(TEXT));
    };
    module2.exports = function(snapdragon) {
      var parsers = snapdragon.parser.parsers;
      snapdragon.use(nanomatch.parsers);
      var escape = parsers.escape;
      var slash = parsers.slash;
      var qmark = parsers.qmark;
      var plus = parsers.plus;
      var star = parsers.star;
      var dot = parsers.dot;
      snapdragon.use(extglob.parsers);
      snapdragon.parser.use(function() {
        this.notRegex = /^\!+(?!\()/;
      }).capture("escape", escape).capture("slash", slash).capture("qmark", qmark).capture("star", star).capture("plus", plus).capture("dot", dot).capture("text", function() {
        if (this.isInside("bracket"))
          return;
        var pos = this.position();
        var m = this.match(createNotRegex(this.options));
        if (!m || !m[0])
          return;
        var val = m[0].replace(/([[\]^$])/g, "\\$1");
        return pos({
          type: "text",
          val
        });
      });
    };
    function textRegex(pattern) {
      var notStr = regexNot.create(pattern, { contains: true, strictClose: false });
      var prefix = "(?:[\\^]|\\\\|";
      return toRegex(prefix + notStr + ")", { strictClose: false });
    }
  }
});

// node_modules/micromatch/lib/cache.js
var require_cache2 = __commonJS({
  "node_modules/micromatch/lib/cache.js"(exports, module2) {
    module2.exports = new (require_fragment_cache())();
  }
});

// node_modules/micromatch/node_modules/kind-of/index.js
var require_kind_of12 = __commonJS({
  "node_modules/micromatch/node_modules/kind-of/index.js"(exports, module2) {
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      if (val === void 0)
        return "undefined";
      if (val === null)
        return "null";
      var type = typeof val;
      if (type === "boolean")
        return "boolean";
      if (type === "string")
        return "string";
      if (type === "number")
        return "number";
      if (type === "symbol")
        return "symbol";
      if (type === "function") {
        return isGeneratorFn(val) ? "generatorfunction" : "function";
      }
      if (isArray(val))
        return "array";
      if (isBuffer(val))
        return "buffer";
      if (isArguments(val))
        return "arguments";
      if (isDate(val))
        return "date";
      if (isError(val))
        return "error";
      if (isRegexp(val))
        return "regexp";
      switch (ctorName(val)) {
        case "Symbol":
          return "symbol";
        case "Promise":
          return "promise";
        case "WeakMap":
          return "weakmap";
        case "WeakSet":
          return "weakset";
        case "Map":
          return "map";
        case "Set":
          return "set";
        case "Int8Array":
          return "int8array";
        case "Uint8Array":
          return "uint8array";
        case "Uint8ClampedArray":
          return "uint8clampedarray";
        case "Int16Array":
          return "int16array";
        case "Uint16Array":
          return "uint16array";
        case "Int32Array":
          return "int32array";
        case "Uint32Array":
          return "uint32array";
        case "Float32Array":
          return "float32array";
        case "Float64Array":
          return "float64array";
      }
      if (isGeneratorObj(val)) {
        return "generator";
      }
      type = toString.call(val);
      switch (type) {
        case "[object Object]":
          return "object";
        case "[object Map Iterator]":
          return "mapiterator";
        case "[object Set Iterator]":
          return "setiterator";
        case "[object String Iterator]":
          return "stringiterator";
        case "[object Array Iterator]":
          return "arrayiterator";
      }
      return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
    };
    function ctorName(val) {
      return typeof val.constructor === "function" ? val.constructor.name : null;
    }
    function isArray(val) {
      if (Array.isArray)
        return Array.isArray(val);
      return val instanceof Array;
    }
    function isError(val) {
      return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
    }
    function isDate(val) {
      if (val instanceof Date)
        return true;
      return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
    }
    function isRegexp(val) {
      if (val instanceof RegExp)
        return true;
      return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
    }
    function isGeneratorFn(name, val) {
      return ctorName(name) === "GeneratorFunction";
    }
    function isGeneratorObj(val) {
      return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
    }
    function isArguments(val) {
      try {
        if (typeof val.length === "number" && typeof val.callee === "function") {
          return true;
        }
      } catch (err) {
        if (err.message.indexOf("callee") !== -1) {
          return true;
        }
      }
      return false;
    }
    function isBuffer(val) {
      if (val.constructor && typeof val.constructor.isBuffer === "function") {
        return val.constructor.isBuffer(val);
      }
      return false;
    }
  }
});

// node_modules/micromatch/lib/utils.js
var require_utils7 = __commonJS({
  "node_modules/micromatch/lib/utils.js"(exports, module2) {
    "use strict";
    var utils = module2.exports;
    var path = require("path");
    var Snapdragon = require_snapdragon();
    utils.define = require_define_property();
    utils.diff = require_arr_diff();
    utils.extend = require_extend_shallow5();
    utils.pick = require_object();
    utils.typeOf = require_kind_of12();
    utils.unique = require_array_unique();
    utils.isWindows = function() {
      return path.sep === "\\" || process.platform === "win32";
    };
    utils.instantiate = function(ast, options) {
      var snapdragon;
      if (utils.typeOf(ast) === "object" && ast.snapdragon) {
        snapdragon = ast.snapdragon;
      } else if (utils.typeOf(options) === "object" && options.snapdragon) {
        snapdragon = options.snapdragon;
      } else {
        snapdragon = new Snapdragon(options);
      }
      utils.define(snapdragon, "parse", function(str, options2) {
        var parsed = Snapdragon.prototype.parse.apply(this, arguments);
        parsed.input = str;
        var last = this.parser.stack.pop();
        if (last && this.options.strictErrors !== true) {
          var open = last.nodes[0];
          var inner = last.nodes[1];
          if (last.type === "bracket") {
            if (inner.val.charAt(0) === "[") {
              inner.val = "\\" + inner.val;
            }
          } else {
            open.val = "\\" + open.val;
            var sibling = open.parent.nodes[1];
            if (sibling.type === "star") {
              sibling.loose = true;
            }
          }
        }
        utils.define(parsed, "parser", this.parser);
        return parsed;
      });
      return snapdragon;
    };
    utils.createKey = function(pattern, options) {
      if (utils.typeOf(options) !== "object") {
        return pattern;
      }
      var val = pattern;
      var keys = Object.keys(options);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        val += ";" + key + "=" + String(options[key]);
      }
      return val;
    };
    utils.arrayify = function(val) {
      if (typeof val === "string")
        return [val];
      return val ? Array.isArray(val) ? val : [val] : [];
    };
    utils.isString = function(val) {
      return typeof val === "string";
    };
    utils.isObject = function(val) {
      return utils.typeOf(val) === "object";
    };
    utils.hasSpecialChars = function(str) {
      return /(?:(?:(^|\/)[!.])|[*?+()|\[\]{}]|[+@]\()/.test(str);
    };
    utils.escapeRegex = function(str) {
      return str.replace(/[-[\]{}()^$|*+?.\\\/\s]/g, "\\$&");
    };
    utils.toPosixPath = function(str) {
      return str.replace(/\\+/g, "/");
    };
    utils.unescape = function(str) {
      return utils.toPosixPath(str.replace(/\\(?=[*+?!.])/g, ""));
    };
    utils.stripPrefix = function(str) {
      if (str.charAt(0) !== ".") {
        return str;
      }
      var ch = str.charAt(1);
      if (utils.isSlash(ch)) {
        return str.slice(2);
      }
      return str;
    };
    utils.isSlash = function(str) {
      return str === "/" || str === "\\/" || str === "\\" || str === "\\\\";
    };
    utils.matchPath = function(pattern, options) {
      return options && options.contains ? utils.containsPattern(pattern, options) : utils.equalsPattern(pattern, options);
    };
    utils._equals = function(filepath, unixPath, pattern) {
      return pattern === filepath || pattern === unixPath;
    };
    utils._contains = function(filepath, unixPath, pattern) {
      return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;
    };
    utils.equalsPattern = function(pattern, options) {
      var unixify = utils.unixify(options);
      options = options || {};
      return function fn(filepath) {
        var equal = utils._equals(filepath, unixify(filepath), pattern);
        if (equal === true || options.nocase !== true) {
          return equal;
        }
        var lower = filepath.toLowerCase();
        return utils._equals(lower, unixify(lower), pattern);
      };
    };
    utils.containsPattern = function(pattern, options) {
      var unixify = utils.unixify(options);
      options = options || {};
      return function(filepath) {
        var contains = utils._contains(filepath, unixify(filepath), pattern);
        if (contains === true || options.nocase !== true) {
          return contains;
        }
        var lower = filepath.toLowerCase();
        return utils._contains(lower, unixify(lower), pattern);
      };
    };
    utils.matchBasename = function(re) {
      return function(filepath) {
        return re.test(path.basename(filepath));
      };
    };
    utils.value = function(str, unixify, options) {
      if (options && options.unixify === false) {
        return str;
      }
      return unixify(str);
    };
    utils.unixify = function(options) {
      options = options || {};
      return function(filepath) {
        if (utils.isWindows() || options.unixify === true) {
          filepath = utils.toPosixPath(filepath);
        }
        if (options.stripPrefix !== false) {
          filepath = utils.stripPrefix(filepath);
        }
        if (options.unescape === true) {
          filepath = utils.unescape(filepath);
        }
        return filepath;
      };
    };
  }
});

// node_modules/micromatch/index.js
var require_micromatch = __commonJS({
  "node_modules/micromatch/index.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var braces = require_braces2();
    var toRegex = require_to_regex();
    var extend = require_extend_shallow5();
    var compilers = require_compilers5();
    var parsers = require_parsers5();
    var cache = require_cache2();
    var utils = require_utils7();
    var MAX_LENGTH = 1024 * 64;
    function micromatch(list, patterns, options) {
      patterns = utils.arrayify(patterns);
      list = utils.arrayify(list);
      var len = patterns.length;
      if (list.length === 0 || len === 0) {
        return [];
      }
      if (len === 1) {
        return micromatch.match(list, patterns[0], options);
      }
      var omit = [];
      var keep = [];
      var idx = -1;
      while (++idx < len) {
        var pattern = patterns[idx];
        if (typeof pattern === "string" && pattern.charCodeAt(0) === 33) {
          omit.push.apply(omit, micromatch.match(list, pattern.slice(1), options));
        } else {
          keep.push.apply(keep, micromatch.match(list, pattern, options));
        }
      }
      var matches = utils.diff(keep, omit);
      if (!options || options.nodupes !== false) {
        return utils.unique(matches);
      }
      return matches;
    }
    micromatch.match = function(list, pattern, options) {
      if (Array.isArray(pattern)) {
        throw new TypeError("expected pattern to be a string");
      }
      var unixify = utils.unixify(options);
      var isMatch = memoize("match", pattern, options, micromatch.matcher);
      var matches = [];
      list = utils.arrayify(list);
      var len = list.length;
      var idx = -1;
      while (++idx < len) {
        var ele = list[idx];
        if (ele === pattern || isMatch(ele)) {
          matches.push(utils.value(ele, unixify, options));
        }
      }
      if (typeof options === "undefined") {
        return utils.unique(matches);
      }
      if (matches.length === 0) {
        if (options.failglob === true) {
          throw new Error('no matches found for "' + pattern + '"');
        }
        if (options.nonull === true || options.nullglob === true) {
          return [options.unescape ? utils.unescape(pattern) : pattern];
        }
      }
      if (options.ignore) {
        matches = micromatch.not(matches, options.ignore, options);
      }
      return options.nodupes !== false ? utils.unique(matches) : matches;
    };
    micromatch.isMatch = function(str, pattern, options) {
      if (typeof str !== "string") {
        throw new TypeError('expected a string: "' + util.inspect(str) + '"');
      }
      if (isEmptyString(str) || isEmptyString(pattern)) {
        return false;
      }
      var equals = utils.equalsPattern(options);
      if (equals(str)) {
        return true;
      }
      var isMatch = memoize("isMatch", pattern, options, micromatch.matcher);
      return isMatch(str);
    };
    micromatch.some = function(list, patterns, options) {
      if (typeof list === "string") {
        list = [list];
      }
      for (var i = 0; i < list.length; i++) {
        if (micromatch(list[i], patterns, options).length === 1) {
          return true;
        }
      }
      return false;
    };
    micromatch.every = function(list, patterns, options) {
      if (typeof list === "string") {
        list = [list];
      }
      for (var i = 0; i < list.length; i++) {
        if (micromatch(list[i], patterns, options).length !== 1) {
          return false;
        }
      }
      return true;
    };
    micromatch.any = function(str, patterns, options) {
      if (typeof str !== "string") {
        throw new TypeError('expected a string: "' + util.inspect(str) + '"');
      }
      if (isEmptyString(str) || isEmptyString(patterns)) {
        return false;
      }
      if (typeof patterns === "string") {
        patterns = [patterns];
      }
      for (var i = 0; i < patterns.length; i++) {
        if (micromatch.isMatch(str, patterns[i], options)) {
          return true;
        }
      }
      return false;
    };
    micromatch.all = function(str, patterns, options) {
      if (typeof str !== "string") {
        throw new TypeError('expected a string: "' + util.inspect(str) + '"');
      }
      if (typeof patterns === "string") {
        patterns = [patterns];
      }
      for (var i = 0; i < patterns.length; i++) {
        if (!micromatch.isMatch(str, patterns[i], options)) {
          return false;
        }
      }
      return true;
    };
    micromatch.not = function(list, patterns, options) {
      var opts = extend({}, options);
      var ignore = opts.ignore;
      delete opts.ignore;
      var unixify = utils.unixify(opts);
      list = utils.arrayify(list).map(unixify);
      var matches = utils.diff(list, micromatch(list, patterns, opts));
      if (ignore) {
        matches = utils.diff(matches, micromatch(list, ignore));
      }
      return opts.nodupes !== false ? utils.unique(matches) : matches;
    };
    micromatch.contains = function(str, patterns, options) {
      if (typeof str !== "string") {
        throw new TypeError('expected a string: "' + util.inspect(str) + '"');
      }
      if (typeof patterns === "string") {
        if (isEmptyString(str) || isEmptyString(patterns)) {
          return false;
        }
        var equals = utils.equalsPattern(patterns, options);
        if (equals(str)) {
          return true;
        }
        var contains = utils.containsPattern(patterns, options);
        if (contains(str)) {
          return true;
        }
      }
      var opts = extend({}, options, { contains: true });
      return micromatch.any(str, patterns, opts);
    };
    micromatch.matchBase = function(pattern, options) {
      if (pattern && pattern.indexOf("/") !== -1 || !options)
        return false;
      return options.basename === true || options.matchBase === true;
    };
    micromatch.matchKeys = function(obj, patterns, options) {
      if (!utils.isObject(obj)) {
        throw new TypeError("expected the first argument to be an object");
      }
      var keys = micromatch(Object.keys(obj), patterns, options);
      return utils.pick(obj, keys);
    };
    micromatch.matcher = function matcher(pattern, options) {
      if (Array.isArray(pattern)) {
        return compose(pattern, options, matcher);
      }
      if (pattern instanceof RegExp) {
        return test(pattern);
      }
      if (!utils.isString(pattern)) {
        throw new TypeError("expected pattern to be an array, string or regex");
      }
      if (!utils.hasSpecialChars(pattern)) {
        if (options && options.nocase === true) {
          pattern = pattern.toLowerCase();
        }
        return utils.matchPath(pattern, options);
      }
      var re = micromatch.makeRe(pattern, options);
      if (micromatch.matchBase(pattern, options)) {
        return utils.matchBasename(re, options);
      }
      function test(regex) {
        var equals = utils.equalsPattern(options);
        var unixify = utils.unixify(options);
        return function(str) {
          if (equals(str)) {
            return true;
          }
          if (regex.test(unixify(str))) {
            return true;
          }
          return false;
        };
      }
      var fn = test(re);
      Object.defineProperty(fn, "result", {
        configurable: true,
        enumerable: false,
        value: re.result
      });
      return fn;
    };
    micromatch.capture = function(pattern, str, options) {
      var re = micromatch.makeRe(pattern, extend({ capture: true }, options));
      var unixify = utils.unixify(options);
      function match() {
        return function(string) {
          var match2 = re.exec(unixify(string));
          if (!match2) {
            return null;
          }
          return match2.slice(1);
        };
      }
      var capture = memoize("capture", pattern, options, match);
      return capture(str);
    };
    micromatch.makeRe = function(pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("expected pattern to be a string");
      }
      if (pattern.length > MAX_LENGTH) {
        throw new Error("expected pattern to be less than " + MAX_LENGTH + " characters");
      }
      function makeRe() {
        var result = micromatch.create(pattern, options);
        var ast_array = [];
        var output = result.map(function(obj) {
          obj.ast.state = obj.state;
          ast_array.push(obj.ast);
          return obj.output;
        });
        var regex = toRegex(output.join("|"), options);
        Object.defineProperty(regex, "result", {
          configurable: true,
          enumerable: false,
          value: ast_array
        });
        return regex;
      }
      return memoize("makeRe", pattern, options, makeRe);
    };
    micromatch.braces = function(pattern, options) {
      if (typeof pattern !== "string" && !Array.isArray(pattern)) {
        throw new TypeError("expected pattern to be an array or string");
      }
      function expand() {
        if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
          return utils.arrayify(pattern);
        }
        return braces(pattern, options);
      }
      return memoize("braces", pattern, options, expand);
    };
    micromatch.braceExpand = function(pattern, options) {
      var opts = extend({}, options, { expand: true });
      return micromatch.braces(pattern, opts);
    };
    micromatch.create = function(pattern, options) {
      return memoize("create", pattern, options, function() {
        function create(str, opts) {
          return micromatch.compile(micromatch.parse(str, opts), opts);
        }
        pattern = micromatch.braces(pattern, options);
        var len = pattern.length;
        var idx = -1;
        var res = [];
        while (++idx < len) {
          res.push(create(pattern[idx], options));
        }
        return res;
      });
    };
    micromatch.parse = function(pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("expected a string");
      }
      function parse() {
        var snapdragon = utils.instantiate(null, options);
        parsers(snapdragon, options);
        var ast = snapdragon.parse(pattern, options);
        utils.define(ast, "snapdragon", snapdragon);
        ast.input = pattern;
        return ast;
      }
      return memoize("parse", pattern, options, parse);
    };
    micromatch.compile = function(ast, options) {
      if (typeof ast === "string") {
        ast = micromatch.parse(ast, options);
      }
      return memoize("compile", ast.input, options, function() {
        var snapdragon = utils.instantiate(ast, options);
        compilers(snapdragon, options);
        return snapdragon.compile(ast, options);
      });
    };
    micromatch.clearCache = function() {
      micromatch.cache.caches = {};
    };
    function isEmptyString(val) {
      return String(val) === "" || String(val) === "./";
    }
    function compose(patterns, options, matcher) {
      var matchers;
      return memoize("compose", String(patterns), options, function() {
        return function(file) {
          if (!matchers) {
            matchers = [];
            for (var i = 0; i < patterns.length; i++) {
              matchers.push(matcher(patterns[i], options));
            }
          }
          var len = matchers.length;
          while (len--) {
            if (matchers[len](file) === true) {
              return true;
            }
          }
          return false;
        };
      });
    }
    function memoize(type, pattern, options, fn) {
      var key = utils.createKey(type + "=" + pattern, options);
      if (options && options.cache === false) {
        return fn(pattern, options);
      }
      if (cache.has(type, key)) {
        return cache.get(type, key);
      }
      var val = fn(pattern, options);
      cache.set(type, key, val);
      return val;
    }
    micromatch.compilers = compilers;
    micromatch.parsers = parsers;
    micromatch.caches = cache.caches;
    module2.exports = micromatch;
  }
});

// node_modules/remove-trailing-separator/index.js
var require_remove_trailing_separator = __commonJS({
  "node_modules/remove-trailing-separator/index.js"(exports, module2) {
    var isWin = process.platform === "win32";
    module2.exports = function(str) {
      var i = str.length - 1;
      if (i < 2) {
        return str;
      }
      while (isSeparator(str, i)) {
        i--;
      }
      return str.substr(0, i + 1);
    };
    function isSeparator(str, i) {
      var char = str[i];
      return i > 0 && (char === "/" || isWin && char === "\\");
    }
  }
});

// node_modules/anymatch/node_modules/normalize-path/index.js
var require_normalize_path = __commonJS({
  "node_modules/anymatch/node_modules/normalize-path/index.js"(exports, module2) {
    var removeTrailingSeparator = require_remove_trailing_separator();
    module2.exports = function normalizePath(str, stripTrailing) {
      if (typeof str !== "string") {
        throw new TypeError("expected a string");
      }
      str = str.replace(/[\\\/]+/g, "/");
      if (stripTrailing !== false) {
        str = removeTrailingSeparator(str);
      }
      return str;
    };
  }
});

// node_modules/anymatch/index.js
var require_anymatch = __commonJS({
  "node_modules/anymatch/index.js"(exports, module2) {
    "use strict";
    var micromatch = require_micromatch();
    var normalize = require_normalize_path();
    var path = require("path");
    var arrify = function(a) {
      return a == null ? [] : Array.isArray(a) ? a : [a];
    };
    var anymatch = function(criteria, value, returnIndex, startIndex, endIndex) {
      criteria = arrify(criteria);
      value = arrify(value);
      if (arguments.length === 1) {
        return anymatch.bind(null, criteria.map(function(criterion) {
          return typeof criterion === "string" && criterion[0] !== "!" ? micromatch.matcher(criterion) : criterion;
        }));
      }
      startIndex = startIndex || 0;
      var string = value[0];
      var altString, altValue;
      var matched = false;
      var matchIndex = -1;
      function testCriteria(criterion, index) {
        var result;
        switch (Object.prototype.toString.call(criterion)) {
          case "[object String]":
            result = string === criterion || altString && altString === criterion;
            result = result || micromatch.isMatch(string, criterion);
            break;
          case "[object RegExp]":
            result = criterion.test(string) || altString && criterion.test(altString);
            break;
          case "[object Function]":
            result = criterion.apply(null, value);
            result = result || altValue && criterion.apply(null, altValue);
            break;
          default:
            result = false;
        }
        if (result) {
          matchIndex = index + startIndex;
        }
        return result;
      }
      var crit = criteria;
      var negGlobs = crit.reduce(function(arr, criterion, index) {
        if (typeof criterion === "string" && criterion[0] === "!") {
          if (crit === criteria) {
            crit = crit.slice();
          }
          crit[index] = null;
          arr.push(criterion.substr(1));
        }
        return arr;
      }, []);
      if (!negGlobs.length || !micromatch.any(string, negGlobs)) {
        if (path.sep === "\\" && typeof string === "string") {
          altString = normalize(string);
          altString = altString === string ? null : altString;
          if (altString)
            altValue = [altString].concat(value.slice(1));
        }
        matched = crit.slice(startIndex, endIndex).some(testCriteria);
      }
      return returnIndex === true ? matchIndex : matched;
    };
    module2.exports = anymatch;
  }
});

// node_modules/is-extglob/index.js
var require_is_extglob = __commonJS({
  "node_modules/is-extglob/index.js"(exports, module2) {
    module2.exports = function isExtglob(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      var match;
      while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
        if (match[2])
          return true;
        str = str.slice(match.index + match[0].length);
      }
      return false;
    };
  }
});

// node_modules/chokidar/node_modules/glob-parent/node_modules/is-glob/index.js
var require_is_glob = __commonJS({
  "node_modules/chokidar/node_modules/glob-parent/node_modules/is-glob/index.js"(exports, module2) {
    var isExtglob = require_is_extglob();
    module2.exports = function isGlob(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob(str))
        return true;
      var regex = /(\\).|([*?]|\[.*\]|\{.*\}|\(.*\|.*\)|^!)/;
      var match;
      while (match = regex.exec(str)) {
        if (match[2])
          return true;
        str = str.slice(match.index + match[0].length);
      }
      return false;
    };
  }
});

// node_modules/path-dirname/index.js
var require_path_dirname = __commonJS({
  "node_modules/path-dirname/index.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var inspect = require("util").inspect;
    function assertPath(path2) {
      if (typeof path2 !== "string") {
        throw new TypeError("Path must be a string. Received " + inspect(path2));
      }
    }
    function posix(path2) {
      assertPath(path2);
      if (path2.length === 0)
        return ".";
      var code = path2.charCodeAt(0);
      var hasRoot = code === 47;
      var end = -1;
      var matchedSlash = true;
      for (var i = path2.length - 1; i >= 1; --i) {
        code = path2.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1)
        return hasRoot ? "/" : ".";
      if (hasRoot && end === 1)
        return "//";
      return path2.slice(0, end);
    }
    function win32(path2) {
      assertPath(path2);
      var len = path2.length;
      if (len === 0)
        return ".";
      var rootEnd = -1;
      var end = -1;
      var matchedSlash = true;
      var offset = 0;
      var code = path2.charCodeAt(0);
      if (len > 1) {
        if (code === 47 || code === 92) {
          rootEnd = offset = 1;
          code = path2.charCodeAt(1);
          if (code === 47 || code === 92) {
            var j = 2;
            var last = j;
            for (; j < len; ++j) {
              code = path2.charCodeAt(j);
              if (code === 47 || code === 92)
                break;
            }
            if (j < len && j !== last) {
              last = j;
              for (; j < len; ++j) {
                code = path2.charCodeAt(j);
                if (code !== 47 && code !== 92)
                  break;
              }
              if (j < len && j !== last) {
                last = j;
                for (; j < len; ++j) {
                  code = path2.charCodeAt(j);
                  if (code === 47 || code === 92)
                    break;
                }
                if (j === len) {
                  return path2;
                }
                if (j !== last) {
                  rootEnd = offset = j + 1;
                }
              }
            }
          }
        } else if (code >= 65 && code <= 90 || code >= 97 && code <= 122) {
          code = path2.charCodeAt(1);
          if (path2.charCodeAt(1) === 58) {
            rootEnd = offset = 2;
            if (len > 2) {
              code = path2.charCodeAt(2);
              if (code === 47 || code === 92)
                rootEnd = offset = 3;
            }
          }
        }
      } else if (code === 47 || code === 92) {
        return path2[0];
      }
      for (var i = len - 1; i >= offset; --i) {
        code = path2.charCodeAt(i);
        if (code === 47 || code === 92) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1) {
        if (rootEnd === -1)
          return ".";
        else
          end = rootEnd;
      }
      return path2.slice(0, end);
    }
    module2.exports = process.platform === "win32" ? win32 : posix;
    module2.exports.posix = posix;
    module2.exports.win32 = win32;
  }
});

// node_modules/chokidar/node_modules/glob-parent/index.js
var require_glob_parent = __commonJS({
  "node_modules/chokidar/node_modules/glob-parent/index.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var isglob = require_is_glob();
    var pathDirname = require_path_dirname();
    var isWin32 = require("os").platform() === "win32";
    module2.exports = function globParent(str) {
      if (isWin32 && str.indexOf("/") < 0)
        str = str.split("\\").join("/");
      if (/[\{\[].*[\/]*.*[\}\]]$/.test(str))
        str += "/";
      str += "a";
      do {
        str = pathDirname.posix(str);
      } while (isglob(str) || /(^|[^\\])([\{\[]|\([^\)]+$)/.test(str));
      return str.replace(/\\([\*\?\|\[\]\(\)\{\}])/g, "$1");
    };
  }
});

// node_modules/is-glob/index.js
var require_is_glob2 = __commonJS({
  "node_modules/is-glob/index.js"(exports, module2) {
    var isExtglob = require_is_extglob();
    var chars = { "{": "}", "(": ")", "[": "]" };
    var strictCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      var pipeIndex = -2;
      var closeSquareIndex = -2;
      var closeCurlyIndex = -2;
      var closeParenIndex = -2;
      var backSlashIndex = -2;
      while (index < str.length) {
        if (str[index] === "*") {
          return true;
        }
        if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
          return true;
        }
        if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
          if (closeSquareIndex < index) {
            closeSquareIndex = str.indexOf("]", index);
          }
          if (closeSquareIndex > index) {
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
          }
        }
        if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
          closeCurlyIndex = str.indexOf("}", index);
          if (closeCurlyIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
              return true;
            }
          }
        }
        if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
          closeParenIndex = str.indexOf(")", index);
          if (closeParenIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
        if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
          if (pipeIndex < index) {
            pipeIndex = str.indexOf("|", index);
          }
          if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
            closeParenIndex = str.indexOf(")", pipeIndex);
            if (closeParenIndex > pipeIndex) {
              backSlashIndex = str.indexOf("\\", pipeIndex);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    var relaxedCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      while (index < str.length) {
        if (/[*?{}()[\]]/.test(str[index])) {
          return true;
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    module2.exports = function isGlob(str, options) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob(str)) {
        return true;
      }
      var check = strictCheck;
      if (options && options.strict === false) {
        check = relaxedCheck;
      }
      return check(str);
    };
  }
});

// node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS({
  "node_modules/path-is-absolute/index.js"(exports, module2) {
    "use strict";
    function posix(path) {
      return path.charAt(0) === "/";
    }
    function win32(path) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result = splitDeviceRe.exec(path);
      var device = result[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result[2] || isUnc);
    }
    module2.exports = process.platform === "win32" ? win32 : posix;
    module2.exports.posix = posix;
    module2.exports.win32 = win32;
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/normalize-path/index.js
var require_normalize_path2 = __commonJS({
  "node_modules/normalize-path/index.js"(exports, module2) {
    module2.exports = function(path, stripTrailing) {
      if (typeof path !== "string") {
        throw new TypeError("expected path to be a string");
      }
      if (path === "\\" || path === "/")
        return "/";
      var len = path.length;
      if (len <= 1)
        return path;
      var prefix = "";
      if (len > 4 && path[3] === "\\") {
        var ch = path[2];
        if ((ch === "?" || ch === ".") && path.slice(0, 2) === "\\\\") {
          path = path.slice(2);
          prefix = "//";
        }
      }
      var segs = path.split(/[/\\]+/);
      if (stripTrailing !== false && segs[segs.length - 1] === "") {
        segs.pop();
      }
      return prefix + segs.join("/");
    };
  }
});

// node_modules/upath/build/code/upath.js
var require_upath = __commonJS({
  "node_modules/upath/build/code/upath.js"(exports) {
    var VERSION = "1.2.0";
    var extraFn;
    var extraFunctions;
    var isFunction;
    var isString;
    var isValidExt;
    var name;
    var path;
    var propName;
    var propValue;
    var toUnix;
    var upath;
    var slice = [].slice;
    var indexOf = [].indexOf || function(item) {
      for (var i = 0, l = this.length; i < l; i++) {
        if (i in this && this[i] === item)
          return i;
      }
      return -1;
    };
    var hasProp = {}.hasOwnProperty;
    path = require("path");
    isFunction = function(val) {
      return val instanceof Function;
    };
    isString = function(val) {
      return typeof val === "string" || !!val && typeof val === "object" && Object.prototype.toString.call(val) === "[object String]";
    };
    upath = exports;
    upath.VERSION = typeof VERSION !== "undefined" && VERSION !== null ? VERSION : "NO-VERSION";
    toUnix = function(p) {
      var double;
      p = p.replace(/\\/g, "/");
      double = /\/\//;
      while (p.match(double)) {
        p = p.replace(double, "/");
      }
      return p;
    };
    for (propName in path) {
      propValue = path[propName];
      if (isFunction(propValue)) {
        upath[propName] = function(propName2) {
          return function() {
            var args, result;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            args = args.map(function(p) {
              if (isString(p)) {
                return toUnix(p);
              } else {
                return p;
              }
            });
            result = path[propName2].apply(path, args);
            if (isString(result)) {
              return toUnix(result);
            } else {
              return result;
            }
          };
        }(propName);
      } else {
        upath[propName] = propValue;
      }
    }
    upath.sep = "/";
    extraFunctions = {
      toUnix,
      normalizeSafe: function(p) {
        p = toUnix(p);
        if (p.startsWith("./")) {
          if (p.startsWith("./..") || p === "./") {
            return upath.normalize(p);
          } else {
            return "./" + upath.normalize(p);
          }
        } else {
          return upath.normalize(p);
        }
      },
      normalizeTrim: function(p) {
        p = upath.normalizeSafe(p);
        if (p.endsWith("/")) {
          return p.slice(0, +(p.length - 2) + 1 || 9e9);
        } else {
          return p;
        }
      },
      joinSafe: function() {
        var p, result;
        p = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        result = upath.join.apply(null, p);
        if (p[0].startsWith("./") && !result.startsWith("./")) {
          result = "./" + result;
        }
        return result;
      },
      addExt: function(file, ext) {
        if (!ext) {
          return file;
        } else {
          if (ext[0] !== ".") {
            ext = "." + ext;
          }
          return file + (file.endsWith(ext) ? "" : ext);
        }
      },
      trimExt: function(filename, ignoreExts, maxSize) {
        var oldExt;
        if (maxSize == null) {
          maxSize = 7;
        }
        oldExt = upath.extname(filename);
        if (isValidExt(oldExt, ignoreExts, maxSize)) {
          return filename.slice(0, +(filename.length - oldExt.length - 1) + 1 || 9e9);
        } else {
          return filename;
        }
      },
      removeExt: function(filename, ext) {
        if (!ext) {
          return filename;
        } else {
          ext = ext[0] === "." ? ext : "." + ext;
          if (upath.extname(filename) === ext) {
            return upath.trimExt(filename);
          } else {
            return filename;
          }
        }
      },
      changeExt: function(filename, ext, ignoreExts, maxSize) {
        if (maxSize == null) {
          maxSize = 7;
        }
        return upath.trimExt(filename, ignoreExts, maxSize) + (!ext ? "" : ext[0] === "." ? ext : "." + ext);
      },
      defaultExt: function(filename, ext, ignoreExts, maxSize) {
        var oldExt;
        if (maxSize == null) {
          maxSize = 7;
        }
        oldExt = upath.extname(filename);
        if (isValidExt(oldExt, ignoreExts, maxSize)) {
          return filename;
        } else {
          return upath.addExt(filename, ext);
        }
      }
    };
    isValidExt = function(ext, ignoreExts, maxSize) {
      if (ignoreExts == null) {
        ignoreExts = [];
      }
      return ext && ext.length <= maxSize && indexOf.call(ignoreExts.map(function(e) {
        return (e && e[0] !== "." ? "." : "") + e;
      }), ext) < 0;
    };
    for (name in extraFunctions) {
      if (!hasProp.call(extraFunctions, name))
        continue;
      extraFn = extraFunctions[name];
      if (upath[name] !== void 0) {
        throw new Error("path." + name + " already exists.");
      } else {
        upath[name] = extraFn;
      }
    }
  }
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/graceful-fs/polyfills.js"(exports, module2) {
    var constants = require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs);
      }
      if (!fs.lutimes) {
        patchLutimes(fs);
      }
      fs.chown = chownFix(fs.chown);
      fs.fchown = chownFix(fs.fchown);
      fs.lchown = chownFix(fs.lchown);
      fs.chmod = chmodFix(fs.chmod);
      fs.fchmod = chmodFix(fs.fchmod);
      fs.lchmod = chmodFix(fs.lchmod);
      fs.chownSync = chownFixSync(fs.chownSync);
      fs.fchownSync = chownFixSync(fs.fchownSync);
      fs.lchownSync = chownFixSync(fs.lchownSync);
      fs.chmodSync = chmodFixSync(fs.chmodSync);
      fs.fchmodSync = chmodFixSync(fs.fchmodSync);
      fs.lchmodSync = chmodFixSync(fs.lchmodSync);
      fs.stat = statFix(fs.stat);
      fs.fstat = statFix(fs.fstat);
      fs.lstat = statFix(fs.lstat);
      fs.statSync = statFixSync(fs.statSync);
      fs.fstatSync = statFixSync(fs.fstatSync);
      fs.lstatSync = statFixSync(fs.lstatSync);
      if (fs.chmod && !fs.lchmod) {
        fs.lchmod = function(path, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs.lchmodSync = function() {
        };
      }
      if (fs.chown && !fs.lchown) {
        fs.lchown = function(path, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs.rename = typeof fs.rename !== "function" ? fs.rename : function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          }
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(rename, fs$rename);
          return rename;
        }(fs.rename);
      }
      fs.read = typeof fs.read !== "function" ? fs.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs.read);
      fs.readSync = typeof fs.readSync !== "function" ? fs.readSync : function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs.readSync);
      function patchLchmod(fs2) {
        fs2.lchmod = function(path, mode, callback) {
          fs2.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
            if (err) {
              if (callback)
                callback(err);
              return;
            }
            fs2.fchmod(fd, mode, function(err2) {
              fs2.close(fd, function(err22) {
                if (callback)
                  callback(err2 || err22);
              });
            });
          });
        };
        fs2.lchmodSync = function(path, mode) {
          var fd = fs2.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs2.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs2.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs2.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs2) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs2.futimes) {
          fs2.lutimes = function(path, at, mt, cb) {
            fs2.open(path, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs2.futimes(fd, at, mt, function(er2) {
                fs2.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs2.lutimesSync = function(path, at, mt) {
            var fd = fs2.openSync(path, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs2.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs2.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs2.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs2.futimes) {
          fs2.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs2.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "node_modules/graceful-fs/legacy-streams.js"(exports, module2) {
    var Stream = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path, options);
        Stream.call(this);
        var self2 = this;
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if (typeof this.end !== "number") {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream(path, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path, options);
        Stream.call(this);
        this.path = path;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "node_modules/graceful-fs/clone.js"(exports, module2) {
    "use strict";
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "node_modules/graceful-fs/graceful-fs.js"(exports, module2) {
    var fs = require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop;
    if (util.debuglog)
      debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs, queue);
      fs.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs.close);
      fs.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs[gracefulQueue]);
          require("assert").equal(fs[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs[gracefulQueue]);
    }
    module2.exports = patch(clone(fs));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
      module2.exports = patch(fs);
      fs.__patched = true;
    }
    function patch(fs2) {
      polyfills(fs2);
      fs2.gracefulify = patch;
      fs2.createReadStream = createReadStream;
      fs2.createWriteStream = createWriteStream;
      var fs$readFile = fs2.readFile;
      fs2.readFile = readFile;
      function readFile(path, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path, options, cb);
        function go$readFile(path2, options2, cb2, startTime) {
          return fs$readFile(path2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs2.writeFile;
      fs2.writeFile = writeFile;
      function writeFile(path, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path, data, options, cb);
        function go$writeFile(path2, data2, options2, cb2, startTime) {
          return fs$writeFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs2.appendFile;
      if (fs$appendFile)
        fs2.appendFile = appendFile;
      function appendFile(path, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path, data, options, cb);
        function go$appendFile(path2, data2, options2, cb2, startTime) {
          return fs$appendFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs2.copyFile;
      if (fs$copyFile)
        fs2.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs2.readdir;
      fs2.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path2, options2, cb2, startTime) {
          return fs$readdir(path2, fs$readdirCallback(path2, options2, cb2, startTime));
        } : function go$readdir2(path2, options2, cb2, startTime) {
          return fs$readdir(path2, options2, fs$readdirCallback(path2, options2, cb2, startTime));
        };
        return go$readdir(path, options, cb);
        function fs$readdirCallback(path2, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path2, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs2);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs2.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs2.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs2, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs2, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs2, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs2, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path, options) {
        return new fs2.ReadStream(path, options);
      }
      function createWriteStream(path, options) {
        return new fs2.WriteStream(path, options);
      }
      var fs$open = fs2.open;
      fs2.open = open;
      function open(path, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path, flags, mode, cb);
        function go$open(path2, flags2, mode2, cb2, startTime) {
          return fs$open(path2, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path2, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs2;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs[gracefulQueue].length; ++i) {
        if (fs[gracefulQueue][i].length > 2) {
          fs[gracefulQueue][i][3] = now;
          fs[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs[gracefulQueue].length === 0)
        return;
      var elem = fs[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "node_modules/process-nextick-args/index.js"(exports, module2) {
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module2.exports = { nextTick };
    } else {
      module2.exports = process;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream.js"(exports, module2) {
    module2.exports = require("stream");
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/core-util-is/lib/util.js
var require_util3 = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = require("buffer").Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports, module2) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var util = require("util");
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        if (this.length === 1)
          return this.head.data;
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
          pna.nextTick(emitErrorNT, this, err);
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          pna.nextTick(emitErrorNT, _this, err2);
          if (_this._writableState) {
            _this._writableState.errorEmitted = true;
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// node_modules/util-deprecate/node.js
var require_node3 = __commonJS({
  "node_modules/util-deprecate/node.js"(exports, module2) {
    module2.exports = require("util").deprecate;
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util3());
    util.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node3()
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = corkReq;
      } else {
        state.corkedRequestsFree = corkReq;
      }
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util3());
    util.inherits = require_inherits();
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    util.inherits(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable;
    var isArray = require_isarray();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util = Object.create(require_util3());
    util.inherits = require_inherits();
    var debugUtil = require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList();
    var destroyImpl = require_destroy();
    var StringDecoder;
    util.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (ret === false && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, unpipeInfo);
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.head.data;
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret += str;
        else
          ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function copyFromBuffer(n, list) {
      var ret = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports, module2) {
    "use strict";
    module2.exports = Transform;
    var Duplex = require_stream_duplex();
    var util = Object.create(require_util3());
    util.inherits = require_inherits();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    var util = Object.create(require_util3());
    util.inherits = require_inherits();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/readable.js"(exports, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream;
      exports = module2.exports = Stream.Readable;
      exports.Readable = Stream.Readable;
      exports.Writable = Stream.Writable;
      exports.Duplex = Stream.Duplex;
      exports.Transform = Stream.Transform;
      exports.PassThrough = Stream.PassThrough;
      exports.Stream = Stream;
    } else {
      exports = module2.exports = require_stream_readable();
      exports.Stream = Stream || exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable();
      exports.Duplex = require_stream_duplex();
      exports.Transform = require_stream_transform();
      exports.PassThrough = require_stream_passthrough();
    }
  }
});

// node_modules/readdirp/stream-api.js
var require_stream_api = __commonJS({
  "node_modules/readdirp/stream-api.js"(exports, module2) {
    "use strict";
    var stream = require_readable();
    var util = require("util");
    var Readable = stream.Readable;
    module2.exports = ReaddirpReadable;
    util.inherits(ReaddirpReadable, Readable);
    function ReaddirpReadable(opts) {
      if (!(this instanceof ReaddirpReadable))
        return new ReaddirpReadable(opts);
      opts = opts || {};
      opts.objectMode = true;
      Readable.call(this, opts);
      this.highWaterMark = Infinity;
      this._destroyed = false;
      this._paused = false;
      this._warnings = [];
      this._errors = [];
      this._pauseResumeErrors();
    }
    var proto = ReaddirpReadable.prototype;
    proto._pauseResumeErrors = function() {
      var self2 = this;
      self2.on("pause", function() {
        self2._paused = true;
      });
      self2.on("resume", function() {
        if (self2._destroyed)
          return;
        self2._paused = false;
        self2._warnings.forEach(function(err) {
          self2.emit("warn", err);
        });
        self2._warnings.length = 0;
        self2._errors.forEach(function(err) {
          self2.emit("error", err);
        });
        self2._errors.length = 0;
      });
    };
    proto._processEntry = function(entry) {
      if (this._destroyed)
        return;
      this.push(entry);
    };
    proto._read = function() {
    };
    proto.destroy = function() {
      this.push(null);
      this.readable = false;
      this._destroyed = true;
      this.emit("close");
    };
    proto._done = function() {
      this.push(null);
    };
    proto._handleError = function(err) {
      var self2 = this;
      setImmediate(function() {
        if (self2._paused)
          return self2._warnings.push(err);
        if (!self2._destroyed)
          self2.emit("warn", err);
      });
    };
    proto._handleFatalError = function(err) {
      var self2 = this;
      setImmediate(function() {
        if (self2._paused)
          return self2._errors.push(err);
        if (!self2._destroyed)
          self2.emit("error", err);
      });
    };
    function createStreamAPI() {
      var stream2 = new ReaddirpReadable();
      return {
        stream: stream2,
        processEntry: stream2._processEntry.bind(stream2),
        done: stream2._done.bind(stream2),
        handleError: stream2._handleError.bind(stream2),
        handleFatalError: stream2._handleFatalError.bind(stream2)
      };
    }
    module2.exports = createStreamAPI;
  }
});

// node_modules/readdirp/readdirp.js
var require_readdirp = __commonJS({
  "node_modules/readdirp/readdirp.js"(exports, module2) {
    "use strict";
    var fs = require_graceful_fs();
    var path = require("path");
    var micromatch = require_micromatch().isMatch;
    var toString = Object.prototype.toString;
    function isFunction(obj) {
      return toString.call(obj) === "[object Function]";
    }
    function isString(obj) {
      return toString.call(obj) === "[object String]";
    }
    function isUndefined(obj) {
      return obj === void 0;
    }
    function readdir(opts, callback1, callback2) {
      var stream, handleError, handleFatalError, errors = [], readdirResult = {
        directories: [],
        files: []
      }, fileProcessed, allProcessed, realRoot, aborted = false, paused = false;
      if (isUndefined(callback1)) {
        var api = require_stream_api()();
        stream = api.stream;
        callback1 = api.processEntry;
        callback2 = api.done;
        handleError = api.handleError;
        handleFatalError = api.handleFatalError;
        stream.on("close", function() {
          aborted = true;
        });
        stream.on("pause", function() {
          paused = true;
        });
        stream.on("resume", function() {
          paused = false;
        });
      } else {
        handleError = function(err) {
          errors.push(err);
        };
        handleFatalError = function(err) {
          handleError(err);
          allProcessed(errors, null);
        };
      }
      if (isUndefined(opts)) {
        handleFatalError(new Error("Need to pass at least one argument: opts! \nhttps://github.com/paulmillr/readdirp#options"));
        return stream;
      }
      opts.root = opts.root || ".";
      opts.fileFilter = opts.fileFilter || function() {
        return true;
      };
      opts.directoryFilter = opts.directoryFilter || function() {
        return true;
      };
      opts.depth = typeof opts.depth === "undefined" ? 999999999 : opts.depth;
      opts.entryType = opts.entryType || "files";
      var statfn = opts.lstat === true ? fs.lstat.bind(fs) : fs.stat.bind(fs);
      if (isUndefined(callback2)) {
        fileProcessed = function() {
        };
        allProcessed = callback1;
      } else {
        fileProcessed = callback1;
        allProcessed = callback2;
      }
      function normalizeFilter(filter) {
        if (isUndefined(filter))
          return void 0;
        function isNegated(filters) {
          function negated(f) {
            return f.indexOf("!") === 0;
          }
          var some = filters.some(negated);
          if (!some) {
            return false;
          } else {
            if (filters.every(negated)) {
              return true;
            } else {
              throw new Error("Cannot mix negated with non negated glob filters: " + filters + "\nhttps://github.com/paulmillr/readdirp#filters");
            }
          }
        }
        if (isFunction(filter)) {
          return filter;
        } else if (isString(filter)) {
          return function(entryInfo) {
            return micromatch(entryInfo.name, filter.trim());
          };
        } else if (filter && Array.isArray(filter)) {
          if (filter)
            filter = filter.map(function(f) {
              return f.trim();
            });
          return isNegated(filter) ? function(entryInfo) {
            return filter.every(function(f) {
              return micromatch(entryInfo.name, f);
            });
          } : function(entryInfo) {
            return filter.some(function(f) {
              return micromatch(entryInfo.name, f);
            });
          };
        }
      }
      function processDir(currentDir, entries, callProcessed) {
        if (aborted)
          return;
        var total = entries.length, processed = 0, entryInfos = [];
        fs.realpath(currentDir, function(err, realCurrentDir) {
          if (aborted)
            return;
          if (err) {
            handleError(err);
            callProcessed(entryInfos);
            return;
          }
          var relDir = path.relative(realRoot, realCurrentDir);
          if (entries.length === 0) {
            callProcessed([]);
          } else {
            entries.forEach(function(entry) {
              var fullPath = path.join(realCurrentDir, entry), relPath = path.join(relDir, entry);
              statfn(fullPath, function(err2, stat) {
                if (err2) {
                  handleError(err2);
                } else {
                  entryInfos.push({
                    name: entry,
                    path: relPath,
                    fullPath,
                    parentDir: relDir,
                    fullParentDir: realCurrentDir,
                    stat
                  });
                }
                processed++;
                if (processed === total)
                  callProcessed(entryInfos);
              });
            });
          }
        });
      }
      function readdirRec(currentDir, depth, callCurrentDirProcessed) {
        var args = arguments;
        if (aborted)
          return;
        if (paused) {
          setImmediate(function() {
            readdirRec.apply(null, args);
          });
          return;
        }
        fs.readdir(currentDir, function(err, entries) {
          if (err) {
            handleError(err);
            callCurrentDirProcessed();
            return;
          }
          processDir(currentDir, entries, function(entryInfos) {
            var subdirs = entryInfos.filter(function(ei) {
              return ei.stat.isDirectory() && opts.directoryFilter(ei);
            });
            subdirs.forEach(function(di) {
              if (opts.entryType === "directories" || opts.entryType === "both" || opts.entryType === "all") {
                fileProcessed(di);
              }
              readdirResult.directories.push(di);
            });
            entryInfos.filter(function(ei) {
              var isCorrectType = opts.entryType === "all" ? !ei.stat.isDirectory() : ei.stat.isFile() || ei.stat.isSymbolicLink();
              return isCorrectType && opts.fileFilter(ei);
            }).forEach(function(fi) {
              if (opts.entryType === "files" || opts.entryType === "both" || opts.entryType === "all") {
                fileProcessed(fi);
              }
              readdirResult.files.push(fi);
            });
            var pendingSubdirs = subdirs.length;
            if (pendingSubdirs === 0 || depth === opts.depth) {
              callCurrentDirProcessed();
            } else {
              subdirs.forEach(function(subdir) {
                readdirRec(subdir.fullPath, depth + 1, function() {
                  pendingSubdirs = pendingSubdirs - 1;
                  if (pendingSubdirs === 0) {
                    callCurrentDirProcessed();
                  }
                });
              });
            }
          });
        });
      }
      try {
        opts.fileFilter = normalizeFilter(opts.fileFilter);
        opts.directoryFilter = normalizeFilter(opts.directoryFilter);
      } catch (err) {
        handleFatalError(err);
        return stream;
      }
      fs.realpath(opts.root, function(err, res) {
        if (err) {
          handleFatalError(err);
          return stream;
        }
        realRoot = res;
        readdirRec(opts.root, 0, function() {
          if (errors.length > 0) {
            allProcessed(errors, readdirResult);
          } else {
            allProcessed(null, readdirResult);
          }
        });
      });
      return stream;
    }
    module2.exports = readdir;
  }
});

// node_modules/binary-extensions/binary-extensions.json
var require_binary_extensions = __commonJS({
  "node_modules/binary-extensions/binary-extensions.json"(exports, module2) {
    module2.exports = [
      "3dm",
      "3ds",
      "3g2",
      "3gp",
      "7z",
      "a",
      "aac",
      "adp",
      "ai",
      "aif",
      "aiff",
      "alz",
      "ape",
      "apk",
      "ar",
      "arj",
      "asf",
      "au",
      "avi",
      "bak",
      "baml",
      "bh",
      "bin",
      "bk",
      "bmp",
      "btif",
      "bz2",
      "bzip2",
      "cab",
      "caf",
      "cgm",
      "class",
      "cmx",
      "cpio",
      "cr2",
      "cur",
      "dat",
      "dcm",
      "deb",
      "dex",
      "djvu",
      "dll",
      "dmg",
      "dng",
      "doc",
      "docm",
      "docx",
      "dot",
      "dotm",
      "dra",
      "DS_Store",
      "dsk",
      "dts",
      "dtshd",
      "dvb",
      "dwg",
      "dxf",
      "ecelp4800",
      "ecelp7470",
      "ecelp9600",
      "egg",
      "eol",
      "eot",
      "epub",
      "exe",
      "f4v",
      "fbs",
      "fh",
      "fla",
      "flac",
      "fli",
      "flv",
      "fpx",
      "fst",
      "fvt",
      "g3",
      "gh",
      "gif",
      "graffle",
      "gz",
      "gzip",
      "h261",
      "h263",
      "h264",
      "icns",
      "ico",
      "ief",
      "img",
      "ipa",
      "iso",
      "jar",
      "jpeg",
      "jpg",
      "jpgv",
      "jpm",
      "jxr",
      "key",
      "ktx",
      "lha",
      "lib",
      "lvp",
      "lz",
      "lzh",
      "lzma",
      "lzo",
      "m3u",
      "m4a",
      "m4v",
      "mar",
      "mdi",
      "mht",
      "mid",
      "midi",
      "mj2",
      "mka",
      "mkv",
      "mmr",
      "mng",
      "mobi",
      "mov",
      "movie",
      "mp3",
      "mp4",
      "mp4a",
      "mpeg",
      "mpg",
      "mpga",
      "mxu",
      "nef",
      "npx",
      "numbers",
      "nupkg",
      "o",
      "oga",
      "ogg",
      "ogv",
      "otf",
      "pages",
      "pbm",
      "pcx",
      "pdb",
      "pdf",
      "pea",
      "pgm",
      "pic",
      "png",
      "pnm",
      "pot",
      "potm",
      "potx",
      "ppa",
      "ppam",
      "ppm",
      "pps",
      "ppsm",
      "ppsx",
      "ppt",
      "pptm",
      "pptx",
      "psd",
      "pya",
      "pyc",
      "pyo",
      "pyv",
      "qt",
      "rar",
      "ras",
      "raw",
      "resources",
      "rgb",
      "rip",
      "rlc",
      "rmf",
      "rmvb",
      "rtf",
      "rz",
      "s3m",
      "s7z",
      "scpt",
      "sgi",
      "shar",
      "sil",
      "sketch",
      "slk",
      "smv",
      "snk",
      "so",
      "stl",
      "suo",
      "sub",
      "swf",
      "tar",
      "tbz",
      "tbz2",
      "tga",
      "tgz",
      "thmx",
      "tif",
      "tiff",
      "tlz",
      "ttc",
      "ttf",
      "txz",
      "udf",
      "uvh",
      "uvi",
      "uvm",
      "uvp",
      "uvs",
      "uvu",
      "viv",
      "vob",
      "war",
      "wav",
      "wax",
      "wbmp",
      "wdp",
      "weba",
      "webm",
      "webp",
      "whl",
      "wim",
      "wm",
      "wma",
      "wmv",
      "wmx",
      "woff",
      "woff2",
      "wrm",
      "wvx",
      "xbm",
      "xif",
      "xla",
      "xlam",
      "xls",
      "xlsb",
      "xlsm",
      "xlsx",
      "xlt",
      "xltm",
      "xltx",
      "xm",
      "xmind",
      "xpi",
      "xpm",
      "xwd",
      "xz",
      "z",
      "zip",
      "zipx"
    ];
  }
});

// node_modules/is-binary-path/index.js
var require_is_binary_path = __commonJS({
  "node_modules/is-binary-path/index.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var binaryExtensions = require_binary_extensions();
    var exts = /* @__PURE__ */ Object.create(null);
    binaryExtensions.forEach(function(el) {
      exts[el] = true;
    });
    module2.exports = function(filepath) {
      return path.extname(filepath).slice(1).toLowerCase() in exts;
    };
  }
});

// node_modules/chokidar/lib/nodefs-handler.js
var require_nodefs_handler = __commonJS({
  "node_modules/chokidar/lib/nodefs-handler.js"(exports, module2) {
    "use strict";
    var fs = require("fs");
    var sysPath = require("path");
    var readdirp = require_readdirp();
    var isBinaryPath = require_is_binary_path();
    var FsWatchInstances = /* @__PURE__ */ Object.create(null);
    function createFsWatchInstance(path, options, listener, errHandler, emitRaw) {
      var handleEvent = function(rawEvent, evPath) {
        listener(path);
        emitRaw(rawEvent, evPath, { watchedPath: path });
        if (evPath && path !== evPath) {
          fsWatchBroadcast(sysPath.resolve(path, evPath), "listeners", sysPath.join(path, evPath));
        }
      };
      try {
        return fs.watch(path, options, handleEvent);
      } catch (error) {
        errHandler(error);
      }
    }
    function fsWatchBroadcast(fullPath, type, val1, val2, val3) {
      if (!FsWatchInstances[fullPath])
        return;
      FsWatchInstances[fullPath][type].forEach(function(listener) {
        listener(val1, val2, val3);
      });
    }
    function setFsWatchListener(path, fullPath, options, handlers) {
      var listener = handlers.listener;
      var errHandler = handlers.errHandler;
      var rawEmitter = handlers.rawEmitter;
      var container = FsWatchInstances[fullPath];
      var watcher;
      if (!options.persistent) {
        watcher = createFsWatchInstance(path, options, listener, errHandler, rawEmitter);
        return watcher.close.bind(watcher);
      }
      if (!container) {
        watcher = createFsWatchInstance(path, options, fsWatchBroadcast.bind(null, fullPath, "listeners"), errHandler, fsWatchBroadcast.bind(null, fullPath, "rawEmitters"));
        if (!watcher)
          return;
        var broadcastErr = fsWatchBroadcast.bind(null, fullPath, "errHandlers");
        watcher.on("error", function(error) {
          container.watcherUnusable = true;
          if (process.platform === "win32" && error.code === "EPERM") {
            fs.open(path, "r", function(err, fd) {
              if (!err)
                fs.close(fd, function(err2) {
                  if (!err2)
                    broadcastErr(error);
                });
            });
          } else {
            broadcastErr(error);
          }
        });
        container = FsWatchInstances[fullPath] = {
          listeners: [listener],
          errHandlers: [errHandler],
          rawEmitters: [rawEmitter],
          watcher
        };
      } else {
        container.listeners.push(listener);
        container.errHandlers.push(errHandler);
        container.rawEmitters.push(rawEmitter);
      }
      var listenerIndex = container.listeners.length - 1;
      return function close() {
        delete container.listeners[listenerIndex];
        delete container.errHandlers[listenerIndex];
        delete container.rawEmitters[listenerIndex];
        if (!Object.keys(container.listeners).length) {
          if (!container.watcherUnusable) {
            container.watcher.close();
          }
          delete FsWatchInstances[fullPath];
        }
      };
    }
    var FsWatchFileInstances = /* @__PURE__ */ Object.create(null);
    function setFsWatchFileListener(path, fullPath, options, handlers) {
      var listener = handlers.listener;
      var rawEmitter = handlers.rawEmitter;
      var container = FsWatchFileInstances[fullPath];
      var listeners = [];
      var rawEmitters = [];
      if (container && (container.options.persistent < options.persistent || container.options.interval > options.interval)) {
        listeners = container.listeners;
        rawEmitters = container.rawEmitters;
        fs.unwatchFile(fullPath);
        container = false;
      }
      if (!container) {
        listeners.push(listener);
        rawEmitters.push(rawEmitter);
        container = FsWatchFileInstances[fullPath] = {
          listeners,
          rawEmitters,
          options,
          watcher: fs.watchFile(fullPath, options, function(curr, prev) {
            container.rawEmitters.forEach(function(rawEmitter2) {
              rawEmitter2("change", fullPath, { curr, prev });
            });
            var currmtime = curr.mtime.getTime();
            if (curr.size !== prev.size || currmtime > prev.mtime.getTime() || currmtime === 0) {
              container.listeners.forEach(function(listener2) {
                listener2(path, curr);
              });
            }
          })
        };
      } else {
        container.listeners.push(listener);
        container.rawEmitters.push(rawEmitter);
      }
      var listenerIndex = container.listeners.length - 1;
      return function close() {
        delete container.listeners[listenerIndex];
        delete container.rawEmitters[listenerIndex];
        if (!Object.keys(container.listeners).length) {
          fs.unwatchFile(fullPath);
          delete FsWatchFileInstances[fullPath];
        }
      };
    }
    function NodeFsHandler() {
    }
    NodeFsHandler.prototype._watchWithNodeFs = function(path, listener) {
      var directory = sysPath.dirname(path);
      var basename = sysPath.basename(path);
      var parent = this._getWatchedDir(directory);
      parent.add(basename);
      var absolutePath = sysPath.resolve(path);
      var options = { persistent: this.options.persistent };
      if (!listener)
        listener = Function.prototype;
      var closer;
      if (this.options.usePolling) {
        options.interval = this.enableBinaryInterval && isBinaryPath(basename) ? this.options.binaryInterval : this.options.interval;
        closer = setFsWatchFileListener(path, absolutePath, options, {
          listener,
          rawEmitter: this.emit.bind(this, "raw")
        });
      } else {
        closer = setFsWatchListener(path, absolutePath, options, {
          listener,
          errHandler: this._handleError.bind(this),
          rawEmitter: this.emit.bind(this, "raw")
        });
      }
      return closer;
    };
    NodeFsHandler.prototype._handleFile = function(file, stats, initialAdd, callback) {
      var dirname = sysPath.dirname(file);
      var basename = sysPath.basename(file);
      var parent = this._getWatchedDir(dirname);
      var prevStats = stats;
      if (parent.has(basename))
        return callback();
      var closer = this._watchWithNodeFs(file, function(path, newStats) {
        if (!this._throttle("watch", file, 5))
          return;
        if (!newStats || newStats && newStats.mtime.getTime() === 0) {
          fs.stat(file, function(error, newStats2) {
            if (error) {
              this._remove(dirname, basename);
            } else {
              var at2 = newStats2.atime.getTime();
              var mt2 = newStats2.mtime.getTime();
              if (!at2 || at2 <= mt2 || mt2 !== prevStats.mtime.getTime()) {
                this._emit("change", file, newStats2);
              }
              prevStats = newStats2;
            }
          }.bind(this));
        } else if (parent.has(basename)) {
          var at = newStats.atime.getTime();
          var mt = newStats.mtime.getTime();
          if (!at || at <= mt || mt !== prevStats.mtime.getTime()) {
            this._emit("change", file, newStats);
          }
          prevStats = newStats;
        }
      }.bind(this));
      if (!(initialAdd && this.options.ignoreInitial)) {
        if (!this._throttle("add", file, 0))
          return;
        this._emit("add", file, stats);
      }
      if (callback)
        callback();
      return closer;
    };
    NodeFsHandler.prototype._handleSymlink = function(entry, directory, path, item) {
      var full = entry.fullPath;
      var dir = this._getWatchedDir(directory);
      if (!this.options.followSymlinks) {
        this._readyCount++;
        fs.realpath(path, function(error, linkPath) {
          if (dir.has(item)) {
            if (this._symlinkPaths[full] !== linkPath) {
              this._symlinkPaths[full] = linkPath;
              this._emit("change", path, entry.stat);
            }
          } else {
            dir.add(item);
            this._symlinkPaths[full] = linkPath;
            this._emit("add", path, entry.stat);
          }
          this._emitReady();
        }.bind(this));
        return true;
      }
      if (this._symlinkPaths[full])
        return true;
      else
        this._symlinkPaths[full] = true;
    };
    NodeFsHandler.prototype._handleDir = function(dir, stats, initialAdd, depth, target, wh, callback) {
      var parentDir = this._getWatchedDir(sysPath.dirname(dir));
      var tracked = parentDir.has(sysPath.basename(dir));
      if (!(initialAdd && this.options.ignoreInitial) && !target && !tracked) {
        if (!wh.hasGlob || wh.globFilter(dir))
          this._emit("addDir", dir, stats);
      }
      parentDir.add(sysPath.basename(dir));
      this._getWatchedDir(dir);
      var read = function(directory, initialAdd2, done) {
        directory = sysPath.join(directory, "");
        if (!wh.hasGlob) {
          var throttler = this._throttle("readdir", directory, 1e3);
          if (!throttler)
            return;
        }
        var previous = this._getWatchedDir(wh.path);
        var current = [];
        readdirp({
          root: directory,
          entryType: "all",
          fileFilter: wh.filterPath,
          directoryFilter: wh.filterDir,
          depth: 0,
          lstat: true
        }).on("data", function(entry) {
          var item = entry.path;
          var path = sysPath.join(directory, item);
          current.push(item);
          if (entry.stat.isSymbolicLink() && this._handleSymlink(entry, directory, path, item))
            return;
          if (item === target || !target && !previous.has(item)) {
            this._readyCount++;
            path = sysPath.join(dir, sysPath.relative(dir, path));
            this._addToNodeFs(path, initialAdd2, wh, depth + 1);
          }
        }.bind(this)).on("end", function() {
          var wasThrottled = throttler ? throttler.clear() : false;
          if (done)
            done();
          previous.children().filter(function(item) {
            return item !== directory && current.indexOf(item) === -1 && (!wh.hasGlob || wh.filterPath({
              fullPath: sysPath.resolve(directory, item)
            }));
          }).forEach(function(item) {
            this._remove(directory, item);
          }, this);
          if (wasThrottled)
            read(directory, false);
        }.bind(this)).on("error", this._handleError.bind(this));
      }.bind(this);
      var closer;
      if (this.options.depth == null || depth <= this.options.depth) {
        if (!target)
          read(dir, initialAdd, callback);
        closer = this._watchWithNodeFs(dir, function(dirPath, stats2) {
          if (stats2 && stats2.mtime.getTime() === 0)
            return;
          read(dirPath, false);
        });
      } else {
        callback();
      }
      return closer;
    };
    NodeFsHandler.prototype._addToNodeFs = function(path, initialAdd, priorWh, depth, target, callback) {
      if (!callback)
        callback = Function.prototype;
      var ready = this._emitReady;
      if (this._isIgnored(path) || this.closed) {
        ready();
        return callback(null, false);
      }
      var wh = this._getWatchHelpers(path, depth);
      if (!wh.hasGlob && priorWh) {
        wh.hasGlob = priorWh.hasGlob;
        wh.globFilter = priorWh.globFilter;
        wh.filterPath = priorWh.filterPath;
        wh.filterDir = priorWh.filterDir;
      }
      fs[wh.statMethod](wh.watchPath, function(error, stats) {
        if (this._handleError(error))
          return callback(null, path);
        if (this._isIgnored(wh.watchPath, stats)) {
          ready();
          return callback(null, false);
        }
        var initDir = function(dir, target2) {
          return this._handleDir(dir, stats, initialAdd, depth, target2, wh, ready);
        }.bind(this);
        var closer;
        if (stats.isDirectory()) {
          closer = initDir(wh.watchPath, target);
        } else if (stats.isSymbolicLink()) {
          var parent = sysPath.dirname(wh.watchPath);
          this._getWatchedDir(parent).add(wh.watchPath);
          this._emit("add", wh.watchPath, stats);
          closer = initDir(parent, path);
          fs.realpath(path, function(error2, targetPath) {
            this._symlinkPaths[sysPath.resolve(path)] = targetPath;
            ready();
          }.bind(this));
        } else {
          closer = this._handleFile(wh.watchPath, stats, initialAdd, ready);
        }
        if (closer) {
          this._closers[path] = this._closers[path] || [];
          this._closers[path].push(closer);
        }
        callback(null, false);
      }.bind(this));
    };
    module2.exports = NodeFsHandler;
  }
});

// node_modules/file-uri-to-path/index.js
var require_file_uri_to_path = __commonJS({
  "node_modules/file-uri-to-path/index.js"(exports, module2) {
    var sep = require("path").sep || "/";
    module2.exports = fileUriToPath;
    function fileUriToPath(uri) {
      if (typeof uri != "string" || uri.length <= 7 || uri.substring(0, 7) != "file://") {
        throw new TypeError("must pass in a file:// URI to convert to a file path");
      }
      var rest = decodeURI(uri.substring(7));
      var firstSlash = rest.indexOf("/");
      var host = rest.substring(0, firstSlash);
      var path = rest.substring(firstSlash + 1);
      if (host == "localhost")
        host = "";
      if (host) {
        host = sep + sep + host;
      }
      path = path.replace(/^(.+)\|/, "$1:");
      if (sep == "\\") {
        path = path.replace(/\//g, "\\");
      }
      if (/^.+\:/.test(path)) {
      } else {
        path = sep + path;
      }
      return host + path;
    }
  }
});

// node_modules/bindings/bindings.js
var require_bindings = __commonJS({
  "node_modules/bindings/bindings.js"(exports, module2) {
    var fs = require("fs");
    var path = require("path");
    var fileURLToPath = require_file_uri_to_path();
    var join = path.join;
    var dirname = path.dirname;
    var exists = fs.accessSync && function(path2) {
      try {
        fs.accessSync(path2);
      } catch (e) {
        return false;
      }
      return true;
    } || fs.existsSync || path.existsSync;
    var defaults = {
      arrow: process.env.NODE_BINDINGS_ARROW || " \u2192 ",
      compiled: process.env.NODE_BINDINGS_COMPILED_DIR || "compiled",
      platform: process.platform,
      arch: process.arch,
      nodePreGyp: "node-v" + process.versions.modules + "-" + process.platform + "-" + process.arch,
      version: process.versions.node,
      bindings: "bindings.node",
      try: [
        ["module_root", "build", "bindings"],
        ["module_root", "build", "Debug", "bindings"],
        ["module_root", "build", "Release", "bindings"],
        ["module_root", "out", "Debug", "bindings"],
        ["module_root", "Debug", "bindings"],
        ["module_root", "out", "Release", "bindings"],
        ["module_root", "Release", "bindings"],
        ["module_root", "build", "default", "bindings"],
        ["module_root", "compiled", "version", "platform", "arch", "bindings"],
        ["module_root", "addon-build", "release", "install-root", "bindings"],
        ["module_root", "addon-build", "debug", "install-root", "bindings"],
        ["module_root", "addon-build", "default", "install-root", "bindings"],
        ["module_root", "lib", "binding", "nodePreGyp", "bindings"]
      ]
    };
    function bindings(opts) {
      if (typeof opts == "string") {
        opts = { bindings: opts };
      } else if (!opts) {
        opts = {};
      }
      Object.keys(defaults).map(function(i2) {
        if (!(i2 in opts))
          opts[i2] = defaults[i2];
      });
      if (!opts.module_root) {
        opts.module_root = exports.getRoot(exports.getFileName());
      }
      if (path.extname(opts.bindings) != ".node") {
        opts.bindings += ".node";
      }
      var requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
      var tries = [], i = 0, l = opts.try.length, n, b, err;
      for (; i < l; i++) {
        n = join.apply(null, opts.try[i].map(function(p) {
          return opts[p] || p;
        }));
        tries.push(n);
        try {
          b = opts.path ? requireFunc.resolve(n) : requireFunc(n);
          if (!opts.path) {
            b.path = n;
          }
          return b;
        } catch (e) {
          if (e.code !== "MODULE_NOT_FOUND" && e.code !== "QUALIFIED_PATH_RESOLUTION_FAILED" && !/not find/i.test(e.message)) {
            throw e;
          }
        }
      }
      err = new Error("Could not locate the bindings file. Tried:\n" + tries.map(function(a) {
        return opts.arrow + a;
      }).join("\n"));
      err.tries = tries;
      throw err;
    }
    module2.exports = exports = bindings;
    exports.getFileName = function getFileName(calling_file) {
      var origPST = Error.prepareStackTrace, origSTL = Error.stackTraceLimit, dummy = {}, fileName;
      Error.stackTraceLimit = 10;
      Error.prepareStackTrace = function(e, st) {
        for (var i = 0, l = st.length; i < l; i++) {
          fileName = st[i].getFileName();
          if (fileName !== __filename) {
            if (calling_file) {
              if (fileName !== calling_file) {
                return;
              }
            } else {
              return;
            }
          }
        }
      };
      Error.captureStackTrace(dummy);
      dummy.stack;
      Error.prepareStackTrace = origPST;
      Error.stackTraceLimit = origSTL;
      var fileSchema = "file://";
      if (fileName.indexOf(fileSchema) === 0) {
        fileName = fileURLToPath(fileName);
      }
      return fileName;
    };
    exports.getRoot = function getRoot(file) {
      var dir = dirname(file), prev;
      while (true) {
        if (dir === ".") {
          dir = process.cwd();
        }
        if (exists(join(dir, "package.json")) || exists(join(dir, "node_modules"))) {
          return dir;
        }
        if (prev === dir) {
          throw new Error('Could not find module root given file: "' + file + '". Do you have a `package.json` file? ');
        }
        prev = dir;
        dir = join(dir, "..");
      }
    };
  }
});

// node_modules/fsevents/fsevents.js
var require_fsevents = __commonJS({
  "node_modules/fsevents/fsevents.js"(exports, module2) {
    "use strict";
    if (process.platform !== "darwin")
      throw new Error("Module 'fsevents' is not compatible with platform '" + process.platform + "'");
    var Native = require_bindings()("fse");
    var EventEmitter = require("events").EventEmitter;
    var fs = require("fs");
    var inherits = require("util").inherits;
    function FSEvents(path, handler) {
      EventEmitter.call(this);
      Object.defineProperty(this, "_impl", {
        value: new Native.FSEvents(String(path || ""), handler),
        enumerable: false,
        writable: false
      });
    }
    inherits(FSEvents, EventEmitter);
    proxies(FSEvents, Native.FSEvents);
    module2.exports = watch;
    module2.exports.getInfo = getInfo;
    module2.exports.FSEvents = Native.FSEvents;
    module2.exports.Constants = Native.Constants;
    var defer = global.setImmediate || process.nextTick;
    function watch(path) {
      var fse = new FSEvents(String(path || ""), handler);
      EventEmitter.call(fse);
      return fse;
      function handler(path2, flags, id) {
        defer(function() {
          fse.emit("fsevent", path2, flags, id);
          var info = getInfo(path2, flags);
          info.id = id;
          if (info.event === "moved") {
            fs.stat(info.path, function(err, stat) {
              info.event = err || !stat ? "moved-out" : "moved-in";
              fse.emit("change", path2, info);
              fse.emit(info.event, path2, info);
            });
          } else {
            fse.emit("change", path2, info);
            fse.emit(info.event, path2, info);
          }
        });
      }
    }
    function proxies(ctor, target) {
      Object.keys(target.prototype).filter(function(key) {
        return typeof target.prototype[key] === "function";
      }).forEach(function(key) {
        ctor.prototype[key] = function() {
          this._impl[key].apply(this._impl, arguments);
          return this;
        };
      });
    }
    function getFileType(flags) {
      if (Native.Constants.kFSEventStreamEventFlagItemIsFile & flags)
        return "file";
      if (Native.Constants.kFSEventStreamEventFlagItemIsDir & flags)
        return "directory";
      if (Native.Constants.kFSEventStreamEventFlagItemIsSymlink & flags)
        return "symlink";
    }
    function getEventType(flags) {
      if (Native.Constants.kFSEventStreamEventFlagItemRemoved & flags)
        return "deleted";
      if (Native.Constants.kFSEventStreamEventFlagItemRenamed & flags)
        return "moved";
      if (Native.Constants.kFSEventStreamEventFlagItemCreated & flags)
        return "created";
      if (Native.Constants.kFSEventStreamEventFlagItemModified & flags)
        return "modified";
      if (Native.Constants.kFSEventStreamEventFlagRootChanged & flags)
        return "root-changed";
      return "unknown";
    }
    function getFileChanges(flags) {
      return {
        inode: !!(Native.Constants.kFSEventStreamEventFlagItemInodeMetaMod & flags),
        finder: !!(Native.Constants.kFSEventStreamEventFlagItemFinderInfoMod & flags),
        access: !!(Native.Constants.kFSEventStreamEventFlagItemChangeOwner & flags),
        xattrs: !!(Native.Constants.kFSEventStreamEventFlagItemXattrMod & flags)
      };
    }
    function getInfo(path, flags) {
      return {
        path,
        event: getEventType(flags),
        type: getFileType(flags),
        changes: getFileChanges(flags),
        flags
      };
    }
  }
});

// node_modules/chokidar/lib/fsevents-handler.js
var require_fsevents_handler = __commonJS({
  "node_modules/chokidar/lib/fsevents-handler.js"(exports, module2) {
    "use strict";
    var fs = require("fs");
    var sysPath = require("path");
    var readdirp = require_readdirp();
    var fsevents;
    try {
      fsevents = require_fsevents();
    } catch (error) {
      if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR)
        console.error(error);
    }
    var FSEventsWatchers = /* @__PURE__ */ Object.create(null);
    var consolidateThreshhold = 10;
    function createFSEventsInstance(path, callback) {
      return new fsevents(path).on("fsevent", callback).start();
    }
    function setFSEventsListener(path, realPath, listener, rawEmitter) {
      var watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path;
      var watchContainer;
      var parentPath = sysPath.dirname(watchPath);
      if (couldConsolidate(parentPath)) {
        watchPath = parentPath;
      }
      var resolvedPath = sysPath.resolve(path);
      var hasSymlink = resolvedPath !== realPath;
      function filteredListener(fullPath, flags, info) {
        if (hasSymlink)
          fullPath = fullPath.replace(realPath, resolvedPath);
        if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath.sep))
          listener(fullPath, flags, info);
      }
      function watchedParent() {
        return Object.keys(FSEventsWatchers).some(function(watchedPath) {
          if (!realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep)) {
            watchPath = watchedPath;
            return true;
          }
        });
      }
      if (watchPath in FSEventsWatchers || watchedParent()) {
        watchContainer = FSEventsWatchers[watchPath];
        watchContainer.listeners.push(filteredListener);
      } else {
        watchContainer = FSEventsWatchers[watchPath] = {
          listeners: [filteredListener],
          rawEmitters: [rawEmitter],
          watcher: createFSEventsInstance(watchPath, function(fullPath, flags) {
            var info = fsevents.getInfo(fullPath, flags);
            watchContainer.listeners.forEach(function(listener2) {
              listener2(fullPath, flags, info);
            });
            watchContainer.rawEmitters.forEach(function(emitter) {
              emitter(info.event, fullPath, info);
            });
          })
        };
      }
      var listenerIndex = watchContainer.listeners.length - 1;
      return function close() {
        delete watchContainer.listeners[listenerIndex];
        delete watchContainer.rawEmitters[listenerIndex];
        if (!Object.keys(watchContainer.listeners).length) {
          watchContainer.watcher.stop();
          delete FSEventsWatchers[watchPath];
        }
      };
    }
    function couldConsolidate(path) {
      var keys = Object.keys(FSEventsWatchers);
      var count = 0;
      for (var i = 0, len = keys.length; i < len; ++i) {
        var watchPath = keys[i];
        if (watchPath.indexOf(path) === 0) {
          count++;
          if (count >= consolidateThreshhold) {
            return true;
          }
        }
      }
      return false;
    }
    function isConstructor(obj) {
      return obj.prototype !== void 0 && obj.prototype.constructor !== void 0;
    }
    function canUse() {
      return fsevents && Object.keys(FSEventsWatchers).length < 128 && isConstructor(fsevents);
    }
    function depth(path, root) {
      var i = 0;
      while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root)
        i++;
      return i;
    }
    function FsEventsHandler() {
    }
    FsEventsHandler.prototype._watchWithFsEvents = function(watchPath, realPath, transform, globFilter) {
      if (this._isIgnored(watchPath))
        return;
      var watchCallback = function(fullPath, flags, info) {
        if (this.options.depth !== void 0 && depth(fullPath, realPath) > this.options.depth)
          return;
        var path = transform(sysPath.join(watchPath, sysPath.relative(watchPath, fullPath)));
        if (globFilter && !globFilter(path))
          return;
        var parent = sysPath.dirname(path);
        var item = sysPath.basename(path);
        var watchedDir = this._getWatchedDir(info.type === "directory" ? path : parent);
        var checkIgnored = function(stats) {
          if (this._isIgnored(path, stats)) {
            this._ignoredPaths[path] = true;
            if (stats && stats.isDirectory()) {
              this._ignoredPaths[path + "/**/*"] = true;
            }
            return true;
          } else {
            delete this._ignoredPaths[path];
            delete this._ignoredPaths[path + "/**/*"];
          }
        }.bind(this);
        var handleEvent = function(event) {
          if (checkIgnored())
            return;
          if (event === "unlink") {
            if (info.type === "directory" || watchedDir.has(item)) {
              this._remove(parent, item);
            }
          } else {
            if (event === "add") {
              if (info.type === "directory")
                this._getWatchedDir(path);
              if (info.type === "symlink" && this.options.followSymlinks) {
                var curDepth = this.options.depth === void 0 ? void 0 : depth(fullPath, realPath) + 1;
                return this._addToFsEvents(path, false, true, curDepth);
              } else {
                this._getWatchedDir(parent).add(item);
              }
            }
            var eventName = info.type === "directory" ? event + "Dir" : event;
            this._emit(eventName, path);
            if (eventName === "addDir")
              this._addToFsEvents(path, false, true);
          }
        }.bind(this);
        function addOrChange() {
          handleEvent(watchedDir.has(item) ? "change" : "add");
        }
        function checkFd() {
          fs.open(path, "r", function(error, fd) {
            if (error) {
              error.code !== "EACCES" ? handleEvent("unlink") : addOrChange();
            } else {
              fs.close(fd, function(err) {
                err && err.code !== "EACCES" ? handleEvent("unlink") : addOrChange();
              });
            }
          });
        }
        var wrongEventFlags = [
          69888,
          70400,
          71424,
          72704,
          73472,
          131328,
          131840,
          262912
        ];
        if (wrongEventFlags.indexOf(flags) !== -1 || info.event === "unknown") {
          if (typeof this.options.ignored === "function") {
            fs.stat(path, function(error, stats) {
              if (checkIgnored(stats))
                return;
              stats ? addOrChange() : handleEvent("unlink");
            });
          } else {
            checkFd();
          }
        } else {
          switch (info.event) {
            case "created":
            case "modified":
              return addOrChange();
            case "deleted":
            case "moved":
              return checkFd();
          }
        }
      }.bind(this);
      var closer = setFSEventsListener(watchPath, realPath, watchCallback, this.emit.bind(this, "raw"));
      this._emitReady();
      return closer;
    };
    FsEventsHandler.prototype._handleFsEventsSymlink = function(linkPath, fullPath, transform, curDepth) {
      if (this._symlinkPaths[fullPath])
        return;
      else
        this._symlinkPaths[fullPath] = true;
      this._readyCount++;
      fs.realpath(linkPath, function(error, linkTarget) {
        if (this._handleError(error) || this._isIgnored(linkTarget)) {
          return this._emitReady();
        }
        this._readyCount++;
        this._addToFsEvents(linkTarget || linkPath, function(path) {
          var dotSlash = "." + sysPath.sep;
          var aliasedPath = linkPath;
          if (linkTarget && linkTarget !== dotSlash) {
            aliasedPath = path.replace(linkTarget, linkPath);
          } else if (path !== dotSlash) {
            aliasedPath = sysPath.join(linkPath, path);
          }
          return transform(aliasedPath);
        }, false, curDepth);
      }.bind(this));
    };
    FsEventsHandler.prototype._addToFsEvents = function(path, transform, forceAdd, priorDepth) {
      var processPath = typeof transform === "function" ? transform : function(val) {
        return val;
      };
      var emitAdd = function(newPath, stats) {
        var pp = processPath(newPath);
        var isDir = stats.isDirectory();
        var dirObj = this._getWatchedDir(sysPath.dirname(pp));
        var base = sysPath.basename(pp);
        if (isDir)
          this._getWatchedDir(pp);
        if (dirObj.has(base))
          return;
        dirObj.add(base);
        if (!this.options.ignoreInitial || forceAdd === true) {
          this._emit(isDir ? "addDir" : "add", pp, stats);
        }
      }.bind(this);
      var wh = this._getWatchHelpers(path);
      fs[wh.statMethod](wh.watchPath, function(error, stats) {
        if (this._handleError(error) || this._isIgnored(wh.watchPath, stats)) {
          this._emitReady();
          return this._emitReady();
        }
        if (stats.isDirectory()) {
          if (!wh.globFilter)
            emitAdd(processPath(path), stats);
          if (priorDepth && priorDepth > this.options.depth)
            return;
          readdirp({
            root: wh.watchPath,
            entryType: "all",
            fileFilter: wh.filterPath,
            directoryFilter: wh.filterDir,
            lstat: true,
            depth: this.options.depth - (priorDepth || 0)
          }).on("data", function(entry) {
            if (entry.stat.isDirectory() && !wh.filterPath(entry))
              return;
            var joinedPath = sysPath.join(wh.watchPath, entry.path);
            var fullPath = entry.fullPath;
            if (wh.followSymlinks && entry.stat.isSymbolicLink()) {
              var curDepth = this.options.depth === void 0 ? void 0 : depth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;
              this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
            } else {
              emitAdd(joinedPath, entry.stat);
            }
          }.bind(this)).on("error", function() {
          }).on("end", this._emitReady);
        } else {
          emitAdd(wh.watchPath, stats);
          this._emitReady();
        }
      }.bind(this));
      if (this.options.persistent && forceAdd !== true) {
        var initWatch = function(error, realPath) {
          if (this.closed)
            return;
          var closer = this._watchWithFsEvents(wh.watchPath, sysPath.resolve(realPath || wh.watchPath), processPath, wh.globFilter);
          if (closer) {
            this._closers[path] = this._closers[path] || [];
            this._closers[path].push(closer);
          }
        }.bind(this);
        if (typeof transform === "function") {
          initWatch();
        } else {
          fs.realpath(wh.watchPath, initWatch);
        }
      }
    };
    module2.exports = FsEventsHandler;
    module2.exports.canUse = canUse;
  }
});

// node_modules/chokidar/index.js
var require_chokidar = __commonJS({
  "node_modules/chokidar/index.js"(exports) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var fs = require("fs");
    var sysPath = require("path");
    var asyncEach = require_async_each();
    var anymatch = require_anymatch();
    var globParent = require_glob_parent();
    var isGlob = require_is_glob2();
    var isAbsolute = require_path_is_absolute();
    var inherits = require_inherits();
    var braces = require_braces2();
    var normalizePath = require_normalize_path2();
    var upath = require_upath();
    var NodeFsHandler = require_nodefs_handler();
    var FsEventsHandler = require_fsevents_handler();
    var arrify = function(value) {
      if (value == null)
        return [];
      return Array.isArray(value) ? value : [value];
    };
    var flatten = function(list, result) {
      if (result == null)
        result = [];
      list.forEach(function(item) {
        if (Array.isArray(item)) {
          flatten(item, result);
        } else {
          result.push(item);
        }
      });
      return result;
    };
    var isString = function(thing) {
      return typeof thing === "string";
    };
    function FSWatcher(_opts) {
      EventEmitter.call(this);
      var opts = {};
      if (_opts)
        for (var opt in _opts)
          opts[opt] = _opts[opt];
      this._watched = /* @__PURE__ */ Object.create(null);
      this._closers = /* @__PURE__ */ Object.create(null);
      this._ignoredPaths = /* @__PURE__ */ Object.create(null);
      Object.defineProperty(this, "_globIgnored", {
        get: function() {
          return Object.keys(this._ignoredPaths);
        }
      });
      this.closed = false;
      this._throttled = /* @__PURE__ */ Object.create(null);
      this._symlinkPaths = /* @__PURE__ */ Object.create(null);
      function undef(key) {
        return opts[key] === void 0;
      }
      if (undef("persistent"))
        opts.persistent = true;
      if (undef("ignoreInitial"))
        opts.ignoreInitial = false;
      if (undef("ignorePermissionErrors"))
        opts.ignorePermissionErrors = false;
      if (undef("interval"))
        opts.interval = 100;
      if (undef("binaryInterval"))
        opts.binaryInterval = 300;
      if (undef("disableGlobbing"))
        opts.disableGlobbing = false;
      this.enableBinaryInterval = opts.binaryInterval !== opts.interval;
      if (undef("useFsEvents"))
        opts.useFsEvents = !opts.usePolling;
      if (!FsEventsHandler.canUse())
        opts.useFsEvents = false;
      if (undef("usePolling") && !opts.useFsEvents) {
        opts.usePolling = process.platform === "darwin";
      }
      var envPoll = process.env.CHOKIDAR_USEPOLLING;
      if (envPoll !== void 0) {
        var envLower = envPoll.toLowerCase();
        if (envLower === "false" || envLower === "0") {
          opts.usePolling = false;
        } else if (envLower === "true" || envLower === "1") {
          opts.usePolling = true;
        } else {
          opts.usePolling = !!envLower;
        }
      }
      var envInterval = process.env.CHOKIDAR_INTERVAL;
      if (envInterval) {
        opts.interval = parseInt(envInterval);
      }
      if (undef("atomic"))
        opts.atomic = !opts.usePolling && !opts.useFsEvents;
      if (opts.atomic)
        this._pendingUnlinks = /* @__PURE__ */ Object.create(null);
      if (undef("followSymlinks"))
        opts.followSymlinks = true;
      if (undef("awaitWriteFinish"))
        opts.awaitWriteFinish = false;
      if (opts.awaitWriteFinish === true)
        opts.awaitWriteFinish = {};
      var awf = opts.awaitWriteFinish;
      if (awf) {
        if (!awf.stabilityThreshold)
          awf.stabilityThreshold = 2e3;
        if (!awf.pollInterval)
          awf.pollInterval = 100;
        this._pendingWrites = /* @__PURE__ */ Object.create(null);
      }
      if (opts.ignored)
        opts.ignored = arrify(opts.ignored);
      this._isntIgnored = function(path, stat) {
        return !this._isIgnored(path, stat);
      }.bind(this);
      var readyCalls = 0;
      this._emitReady = function() {
        if (++readyCalls >= this._readyCount) {
          this._emitReady = Function.prototype;
          this._readyEmitted = true;
          process.nextTick(this.emit.bind(this, "ready"));
        }
      }.bind(this);
      this.options = opts;
      Object.freeze(opts);
    }
    inherits(FSWatcher, EventEmitter);
    FSWatcher.prototype._emit = function(event, path, val1, val2, val3) {
      if (this.options.cwd)
        path = sysPath.relative(this.options.cwd, path);
      var args = [event, path];
      if (val3 !== void 0)
        args.push(val1, val2, val3);
      else if (val2 !== void 0)
        args.push(val1, val2);
      else if (val1 !== void 0)
        args.push(val1);
      var awf = this.options.awaitWriteFinish;
      if (awf && this._pendingWrites[path]) {
        this._pendingWrites[path].lastChange = new Date();
        return this;
      }
      if (this.options.atomic) {
        if (event === "unlink") {
          this._pendingUnlinks[path] = args;
          setTimeout(function() {
            Object.keys(this._pendingUnlinks).forEach(function(path2) {
              this.emit.apply(this, this._pendingUnlinks[path2]);
              this.emit.apply(this, ["all"].concat(this._pendingUnlinks[path2]));
              delete this._pendingUnlinks[path2];
            }.bind(this));
          }.bind(this), typeof this.options.atomic === "number" ? this.options.atomic : 100);
          return this;
        } else if (event === "add" && this._pendingUnlinks[path]) {
          event = args[0] = "change";
          delete this._pendingUnlinks[path];
        }
      }
      var emitEvent = function() {
        this.emit.apply(this, args);
        if (event !== "error")
          this.emit.apply(this, ["all"].concat(args));
      }.bind(this);
      if (awf && (event === "add" || event === "change") && this._readyEmitted) {
        var awfEmit = function(err, stats) {
          if (err) {
            event = args[0] = "error";
            args[1] = err;
            emitEvent();
          } else if (stats) {
            if (args.length > 2) {
              args[2] = stats;
            } else {
              args.push(stats);
            }
            emitEvent();
          }
        };
        this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);
        return this;
      }
      if (event === "change") {
        if (!this._throttle("change", path, 50))
          return this;
      }
      if (this.options.alwaysStat && val1 === void 0 && (event === "add" || event === "addDir" || event === "change")) {
        var fullPath = this.options.cwd ? sysPath.join(this.options.cwd, path) : path;
        fs.stat(fullPath, function(error, stats) {
          if (error || !stats)
            return;
          args.push(stats);
          emitEvent();
        });
      } else {
        emitEvent();
      }
      return this;
    };
    FSWatcher.prototype._handleError = function(error) {
      var code = error && error.code;
      var ipe = this.options.ignorePermissionErrors;
      if (error && code !== "ENOENT" && code !== "ENOTDIR" && (!ipe || code !== "EPERM" && code !== "EACCES"))
        this.emit("error", error);
      return error || this.closed;
    };
    FSWatcher.prototype._throttle = function(action, path, timeout) {
      if (!(action in this._throttled)) {
        this._throttled[action] = /* @__PURE__ */ Object.create(null);
      }
      var throttled = this._throttled[action];
      if (path in throttled) {
        throttled[path].count++;
        return false;
      }
      function clear() {
        var count = throttled[path] ? throttled[path].count : 0;
        delete throttled[path];
        clearTimeout(timeoutObject);
        return count;
      }
      var timeoutObject = setTimeout(clear, timeout);
      throttled[path] = { timeoutObject, clear, count: 0 };
      return throttled[path];
    };
    FSWatcher.prototype._awaitWriteFinish = function(path, threshold, event, awfEmit) {
      var timeoutHandler;
      var fullPath = path;
      if (this.options.cwd && !isAbsolute(path)) {
        fullPath = sysPath.join(this.options.cwd, path);
      }
      var now = new Date();
      var awaitWriteFinish = function(prevStat) {
        fs.stat(fullPath, function(err, curStat) {
          if (err || !(path in this._pendingWrites)) {
            if (err && err.code !== "ENOENT")
              awfEmit(err);
            return;
          }
          var now2 = new Date();
          if (prevStat && curStat.size != prevStat.size) {
            this._pendingWrites[path].lastChange = now2;
          }
          if (now2 - this._pendingWrites[path].lastChange >= threshold) {
            delete this._pendingWrites[path];
            awfEmit(null, curStat);
          } else {
            timeoutHandler = setTimeout(awaitWriteFinish.bind(this, curStat), this.options.awaitWriteFinish.pollInterval);
          }
        }.bind(this));
      }.bind(this);
      if (!(path in this._pendingWrites)) {
        this._pendingWrites[path] = {
          lastChange: now,
          cancelWait: function() {
            delete this._pendingWrites[path];
            clearTimeout(timeoutHandler);
            return event;
          }.bind(this)
        };
        timeoutHandler = setTimeout(awaitWriteFinish.bind(this), this.options.awaitWriteFinish.pollInterval);
      }
    };
    var dotRe = /\..*\.(sw[px])$|\~$|\.subl.*\.tmp/;
    FSWatcher.prototype._isIgnored = function(path, stats) {
      if (this.options.atomic && dotRe.test(path))
        return true;
      if (!this._userIgnored) {
        var cwd = this.options.cwd;
        var ignored = this.options.ignored;
        if (cwd && ignored) {
          ignored = ignored.map(function(path2) {
            if (typeof path2 !== "string")
              return path2;
            return upath.normalize(isAbsolute(path2) ? path2 : sysPath.join(cwd, path2));
          });
        }
        var paths = arrify(ignored).filter(function(path2) {
          return typeof path2 === "string" && !isGlob(path2);
        }).map(function(path2) {
          return path2 + "/**";
        });
        this._userIgnored = anymatch(this._globIgnored.concat(ignored).concat(paths));
      }
      return this._userIgnored([path, stats]);
    };
    var replacerRe = /^\.[\/\\]/;
    FSWatcher.prototype._getWatchHelpers = function(path, depth) {
      path = path.replace(replacerRe, "");
      var watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);
      var fullWatchPath = sysPath.resolve(watchPath);
      var hasGlob = watchPath !== path;
      var globFilter = hasGlob ? anymatch(path) : false;
      var follow = this.options.followSymlinks;
      var globSymlink = hasGlob && follow ? null : false;
      var checkGlobSymlink = function(entry) {
        if (globSymlink == null) {
          globSymlink = entry.fullParentDir === fullWatchPath ? false : {
            realPath: entry.fullParentDir,
            linkPath: fullWatchPath
          };
        }
        if (globSymlink) {
          return entry.fullPath.replace(globSymlink.realPath, globSymlink.linkPath);
        }
        return entry.fullPath;
      };
      var entryPath = function(entry) {
        return sysPath.join(watchPath, sysPath.relative(watchPath, checkGlobSymlink(entry)));
      };
      var filterPath = function(entry) {
        if (entry.stat && entry.stat.isSymbolicLink())
          return filterDir(entry);
        var resolvedPath = entryPath(entry);
        return (!hasGlob || globFilter(resolvedPath)) && this._isntIgnored(resolvedPath, entry.stat) && (this.options.ignorePermissionErrors || this._hasReadPermissions(entry.stat));
      }.bind(this);
      var getDirParts = function(path2) {
        if (!hasGlob)
          return false;
        var parts = [];
        var expandedPath = braces.expand(path2);
        expandedPath.forEach(function(path3) {
          parts.push(sysPath.relative(watchPath, path3).split(/[\/\\]/));
        });
        return parts;
      };
      var dirParts = getDirParts(path);
      if (dirParts) {
        dirParts.forEach(function(parts) {
          if (parts.length > 1)
            parts.pop();
        });
      }
      var unmatchedGlob;
      var filterDir = function(entry) {
        if (hasGlob) {
          var entryParts = getDirParts(checkGlobSymlink(entry));
          var globstar = false;
          unmatchedGlob = !dirParts.some(function(parts) {
            return parts.every(function(part, i) {
              if (part === "**")
                globstar = true;
              return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i]);
            });
          });
        }
        return !unmatchedGlob && this._isntIgnored(entryPath(entry), entry.stat);
      }.bind(this);
      return {
        followSymlinks: follow,
        statMethod: follow ? "stat" : "lstat",
        path,
        watchPath,
        entryPath,
        hasGlob,
        globFilter,
        filterPath,
        filterDir
      };
    };
    FSWatcher.prototype._getWatchedDir = function(directory) {
      var dir = sysPath.resolve(directory);
      var watcherRemove = this._remove.bind(this);
      if (!(dir in this._watched))
        this._watched[dir] = {
          _items: /* @__PURE__ */ Object.create(null),
          add: function(item) {
            if (item !== "." && item !== "..")
              this._items[item] = true;
          },
          remove: function(item) {
            delete this._items[item];
            if (!this.children().length) {
              fs.readdir(dir, function(err) {
                if (err)
                  watcherRemove(sysPath.dirname(dir), sysPath.basename(dir));
              });
            }
          },
          has: function(item) {
            return item in this._items;
          },
          children: function() {
            return Object.keys(this._items);
          }
        };
      return this._watched[dir];
    };
    FSWatcher.prototype._hasReadPermissions = function(stats) {
      return Boolean(4 & parseInt(((stats && stats.mode) & 511).toString(8)[0], 10));
    };
    FSWatcher.prototype._remove = function(directory, item) {
      var path = sysPath.join(directory, item);
      var fullPath = sysPath.resolve(path);
      var isDirectory = this._watched[path] || this._watched[fullPath];
      if (!this._throttle("remove", path, 100))
        return;
      var watchedDirs = Object.keys(this._watched);
      if (!isDirectory && !this.options.useFsEvents && watchedDirs.length === 1) {
        this.add(directory, item, true);
      }
      var nestedDirectoryChildren = this._getWatchedDir(path).children();
      nestedDirectoryChildren.forEach(function(nestedItem) {
        this._remove(path, nestedItem);
      }, this);
      var parent = this._getWatchedDir(directory);
      var wasTracked = parent.has(item);
      parent.remove(item);
      var relPath = path;
      if (this.options.cwd)
        relPath = sysPath.relative(this.options.cwd, path);
      if (this.options.awaitWriteFinish && this._pendingWrites[relPath]) {
        var event = this._pendingWrites[relPath].cancelWait();
        if (event === "add")
          return;
      }
      delete this._watched[path];
      delete this._watched[fullPath];
      var eventName = isDirectory ? "unlinkDir" : "unlink";
      if (wasTracked && !this._isIgnored(path))
        this._emit(eventName, path);
      if (!this.options.useFsEvents) {
        this._closePath(path);
      }
    };
    FSWatcher.prototype._closePath = function(path) {
      if (!this._closers[path])
        return;
      this._closers[path].forEach(function(closer) {
        closer();
      });
      delete this._closers[path];
      this._getWatchedDir(sysPath.dirname(path)).remove(sysPath.basename(path));
    };
    FSWatcher.prototype.add = function(paths, _origAdd, _internal) {
      var disableGlobbing = this.options.disableGlobbing;
      var cwd = this.options.cwd;
      this.closed = false;
      paths = flatten(arrify(paths));
      if (!paths.every(isString)) {
        throw new TypeError("Non-string provided as watch path: " + paths);
      }
      if (cwd)
        paths = paths.map(function(path) {
          var absPath;
          if (isAbsolute(path)) {
            absPath = path;
          } else if (path[0] === "!") {
            absPath = "!" + sysPath.join(cwd, path.substring(1));
          } else {
            absPath = sysPath.join(cwd, path);
          }
          if (disableGlobbing || !isGlob(path)) {
            return absPath;
          } else {
            return normalizePath(absPath);
          }
        });
      paths = paths.filter(function(path) {
        if (path[0] === "!") {
          this._ignoredPaths[path.substring(1)] = true;
        } else {
          delete this._ignoredPaths[path];
          delete this._ignoredPaths[path + "/**"];
          this._userIgnored = null;
          return true;
        }
      }, this);
      if (this.options.useFsEvents && FsEventsHandler.canUse()) {
        if (!this._readyCount)
          this._readyCount = paths.length;
        if (this.options.persistent)
          this._readyCount *= 2;
        paths.forEach(this._addToFsEvents, this);
      } else {
        if (!this._readyCount)
          this._readyCount = 0;
        this._readyCount += paths.length;
        asyncEach(paths, function(path, next) {
          this._addToNodeFs(path, !_internal, 0, 0, _origAdd, function(err, res) {
            if (res)
              this._emitReady();
            next(err, res);
          }.bind(this));
        }.bind(this), function(error, results) {
          results.forEach(function(item) {
            if (!item || this.closed)
              return;
            this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
          }, this);
        }.bind(this));
      }
      return this;
    };
    FSWatcher.prototype.unwatch = function(paths) {
      if (this.closed)
        return this;
      paths = flatten(arrify(paths));
      paths.forEach(function(path) {
        if (!isAbsolute(path) && !this._closers[path]) {
          if (this.options.cwd)
            path = sysPath.join(this.options.cwd, path);
          path = sysPath.resolve(path);
        }
        this._closePath(path);
        this._ignoredPaths[path] = true;
        if (path in this._watched) {
          this._ignoredPaths[path + "/**"] = true;
        }
        this._userIgnored = null;
      }, this);
      return this;
    };
    FSWatcher.prototype.close = function() {
      if (this.closed)
        return this;
      this.closed = true;
      Object.keys(this._closers).forEach(function(watchPath) {
        this._closers[watchPath].forEach(function(closer) {
          closer();
        });
        delete this._closers[watchPath];
      }, this);
      this._watched = /* @__PURE__ */ Object.create(null);
      this.removeAllListeners();
      return this;
    };
    FSWatcher.prototype.getWatched = function() {
      var watchList = {};
      Object.keys(this._watched).forEach(function(dir) {
        var key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
        watchList[key || "."] = Object.keys(this._watched[dir]._items).sort();
      }.bind(this));
      return watchList;
    };
    function importHandler(handler) {
      Object.keys(handler.prototype).forEach(function(method) {
        FSWatcher.prototype[method] = handler.prototype[method];
      });
    }
    importHandler(NodeFsHandler);
    if (FsEventsHandler.canUse())
      importHandler(FsEventsHandler);
    exports.FSWatcher = FSWatcher;
    exports.watch = function(paths, options) {
      return new FSWatcher(options).add(paths);
    };
  }
});

// node_modules/forever-monitor/lib/forever-monitor/plugins/watch.js
var require_watch = __commonJS({
  "node_modules/forever-monitor/lib/forever-monitor/plugins/watch.js"(exports) {
    var fs = require("fs");
    var path = require("path");
    var minimatch = require_minimatch();
    var chokidar = require_chokidar();
    exports.name = "watch";
    function watchFilter(fileName) {
      let watchDirectory = this.watchDirectory, result = true;
      if (!Array.isArray(watchDirectory)) {
        watchDirectory = [watchDirectory];
      }
      watchDirectory.forEach(function(directory) {
        const relFileName = path.relative(directory, fileName), length = this.watchIgnorePatterns.length;
        let testName, i;
        if (this.watchIgnoreDotFiles && path.basename(fileName)[0] === ".") {
          result = false;
        }
        for (i = 0; i < length; i++) {
          if (this.watchIgnorePatterns[i].length > 0) {
            testName = this.watchIgnorePatterns[i].charAt(0) !== "/" ? relFileName : fileName;
            if (minimatch(testName, this.watchIgnorePatterns[i], {
              matchBase: directory
            })) {
              result = false;
            }
          }
        }
      }.bind(this));
      return result;
    }
    exports.attach = function() {
      let watchDirectory = this.watchDirectory;
      const monitor = this;
      if (!Array.isArray(watchDirectory)) {
        watchDirectory = [watchDirectory];
      }
      watchDirectory.forEach(function(directory) {
        fs.readFile(path.join(directory, ".foreverignore"), "utf8", function(err, data) {
          if (err) {
            return monitor.emit("watch:error", {
              message: "Could not read .foreverignore file.",
              error: err.message
            });
          }
          Array.prototype.push.apply(monitor.watchIgnorePatterns, data.split("\n").filter(Boolean));
        });
      });
      const opts = {
        usePolling: this.usePolling,
        interval: this.pollingInterval,
        ignoreInitial: true,
        ignored: function(fileName) {
          return !watchFilter.call(monitor, fileName);
        }
      };
      chokidar.watch(this.watchDirectory, opts).on("all", function(event, f, stat) {
        monitor.emit("watch:restart", { file: f, stat });
        monitor.restart();
      });
    };
  }
});

// node_modules/forever-monitor/lib/forever-monitor/plugins/index.js
var require_plugins = __commonJS({
  "node_modules/forever-monitor/lib/forever-monitor/plugins/index.js"(exports) {
    exports.logger = require_logger();
    exports.watch = require_watch();
  }
});

// node_modules/forever-monitor/lib/forever-monitor/monitor.js
var require_monitor = __commonJS({
  "node_modules/forever-monitor/lib/forever-monitor/monitor.js"(exports) {
    var fs = require("fs");
    var path = require("path");
    var child_process = require("child_process");
    var events = require_eventemitter2();
    var spawn = child_process.spawn;
    var common = require_common();
    var cluster = require("cluster");
    var plugins = require_plugins();
    var utils = require_utils();
    var util = require("util");
    var Monitor = exports.Monitor = function(script, options) {
      function bootstrap(monitor) {
        plugins.logger.attach.call(monitor, options);
        if (options.watch) {
          plugins.watch.attach.call(monitor, options);
        }
      }
      let execPath = process.execPath;
      const self2 = this;
      options = options || {};
      this.silent = options.silent || false;
      this.killTree = options.killTree !== false;
      this.uid = options.uid || utils.randomString(4);
      this.id = options.id || false;
      this.pidFile = options.pidFile;
      this.max = options.max;
      this.killTTL = options.killTTL;
      this.killSignal = options.killSignal || "SIGKILL";
      this.childExists = false;
      this.checkFile = options.checkFile !== false;
      this.times = 0;
      this.warn = console.error;
      this.logFile = options.logFile;
      this.outFile = options.outFile;
      this.errFile = options.errFile;
      this.append = options.append;
      this.usePolling = options.usePolling;
      this.pollingInterval = options.pollingInterval;
      this.parser = options.parser || Monitor.parseCommand;
      this.minUptime = typeof options.minUptime !== "number" ? 0 : options.minUptime;
      this.spinSleepTime = options.spinSleepTime || null;
      if (process.platform === "win32") {
        execPath = '"' + execPath + '"';
      }
      if (options.options) {
        console.warn("options.options is deprecated. Use options.args instead.");
      }
      this.command = options.command || execPath;
      this.args = options.args || options.options || [];
      this.spawnWith = options.spawnWith || {};
      this.sourceDir = options.sourceDir;
      this.fork = options.fork || false;
      this.cwd = options.cwd || process.cwd();
      this.hideEnv = options.hideEnv || [];
      this._env = options.env || {};
      this._hideEnv = {};
      this.stdio = options.stdio || null;
      this.watchIgnoreDotFiles = options.watchIgnoreDotFiles !== false;
      this.watchIgnorePatterns = options.watchIgnorePatterns || [];
      this.watchDirectory = options.watchDirectory || this.sourceDir;
      this.hideEnv.forEach(function(key) {
        self2._hideEnv[key] = true;
      });
      if (Array.isArray(script)) {
        this.command = script[0];
        this.args = script.slice(1);
      } else {
        this.args.unshift(script);
      }
      if (this.sourceDir) {
        this.args[0] = path.join(this.sourceDir, this.args[0]);
      }
      bootstrap(this);
    };
    util.inherits(Monitor, events.EventEmitter2);
    Monitor.prototype.start = function(restart) {
      const self2 = this;
      if (this.running && !restart) {
        process.nextTick(function() {
          self2.emit("error", new Error("Cannot start process that is already running."));
        });
        return this;
      }
      const child2 = this.trySpawn();
      if (!child2) {
        process.nextTick(function() {
          self2.emit("error", new Error("Target script does not exist: " + self2.args[0]));
        });
        return this;
      }
      this.ctime = Date.now();
      this.child = child2;
      this.running = true;
      this.isMaster = cluster.isMaster;
      process.nextTick(function() {
        self2.emit(restart ? "restart" : "start", self2, self2.data);
      });
      function onMessage(msg) {
        self2.emit("message", msg);
      }
      this.child.on("message", onMessage);
      child2.on("exit", function(code, signal) {
        const spinning = Date.now() - self2.ctime < self2.minUptime;
        child2.removeListener("message", onMessage);
        self2.emit("exit:code", code, signal);
        function letChildDie() {
          self2.running = false;
          self2.forceStop = false;
          self2.forceRestart = false;
          self2.emit("exit", self2, spinning);
        }
        function restartChild() {
          self2.forceStop = false;
          self2.forceRestart = false;
          process.nextTick(function() {
            self2.start(true);
          });
        }
        self2.times++;
        if (self2.forceStop || self2.times >= self2.max && !self2.forceRestart || spinning && typeof self2.spinSleepTime !== "number" && !self2.forceRestart) {
          letChildDie();
        } else if (spinning) {
          setTimeout(restartChild, self2.spinSleepTime);
        } else {
          restartChild();
        }
      });
      return this;
    };
    Monitor.prototype.trySpawn = function() {
      const run = this.parser(this.command, this.args.slice());
      let stats;
      if (/[^\w]node$/.test(this.command) && this.checkFile && !this.childExists) {
        try {
          stats = fs.statSync(this.args[0]);
          this.childExists = true;
        } catch (ex) {
          return false;
        }
      }
      this.spawnWith.cwd = this.spawnWith.cwd || this.cwd;
      this.spawnWith.env = this._getEnv();
      if (process.platform === "win32") {
        this.spawnWith.detached = true;
      }
      if (this.stdio) {
        this.spawnWith.stdio = this.stdio;
      }
      if (this.fork) {
        if (!this.stdio) {
          this.spawnWith.stdio = ["pipe", "pipe", "pipe", "ipc"];
        }
        return spawn(run.command, run.args, this.spawnWith);
      }
      return spawn(run.command, run.args, this.spawnWith);
    };
    Monitor.prototype.__defineGetter__("data", function() {
      const self2 = this;
      const childData = {
        ctime: this.ctime,
        command: this.command,
        file: this.args[0],
        foreverPid: process.pid,
        logFile: this.logFile,
        args: this.args.slice(1),
        pid: this.child ? this.child.pid : void 0,
        silent: this.silent,
        uid: this.uid,
        id: this.id,
        spawnWith: this.spawnWith,
        running: this.running,
        restarts: this.times,
        isMaster: this.isMaster
      };
      ["pidFile", "outFile", "errFile", "env", "cwd"].forEach(function(key) {
        if (self2[key]) {
          childData[key] = self2[key];
        }
      });
      if (this.sourceDir) {
        childData.sourceDir = this.sourceDir;
        childData.file = childData.file.replace(this.sourceDir + "/", "");
      }
      this.childData = childData;
      return this.childData;
    });
    Monitor.prototype.restart = function() {
      this.times = this.times || 0;
      this.forceRestart = true;
      return !this.running ? this.start(true) : this.kill(false);
    };
    Monitor.prototype.stop = function() {
      return this.kill(true);
    };
    Monitor.prototype.kill = function(forceStop) {
      const child2 = this.child, self2 = this;
      let timer;
      if (!child2 || !this.running && !this.forceRestart) {
        process.nextTick(function() {
          self2.emit("error", new Error("Cannot stop process that is not running."));
        });
      } else {
        if (forceStop) {
          this.forceStop = true;
          if (this.killTTL) {
            timer = setTimeout(function() {
              common.kill(self2.child.pid, self2.killTree, self2.killSignal || "SIGKILL");
            }, this.killTTL);
            child2.once("exit", function() {
              clearTimeout(timer);
            });
          }
        }
        child2.once("exit", function() {
          self2.emit("stop", self2.childData);
          if (self2.forceRestart && !self2.running) {
            self2.start(true);
          }
        });
        common.kill(this.child.pid, this.killTree, this.killSignal);
      }
      return this;
    };
    Monitor.prototype.send = function(msg) {
      const child2 = this.child, self2 = this;
      if (!child2 || !this.running) {
        process.nextTick(function() {
          self2.emit("error", new Error("Cannot send to process that is not running."));
        });
      }
      if (child2.send) {
        child2.send(msg);
      }
    };
    Monitor.prototype.toString = function() {
      return JSON.stringify(this);
    };
    Monitor.prototype.inspect = null;
    Monitor.prototype._getEnv = function() {
      const self2 = this, merged = {};
      function addKey(key, source) {
        merged[key] = source[key];
      }
      Object.keys(process.env).forEach(function(key) {
        if (!self2._hideEnv[key]) {
          addKey(key, process.env);
        }
      });
      Object.keys(this._env).forEach(function(key) {
        addKey(key, self2._env);
      });
      return merged;
    };
    Monitor.parseCommand = function(command, args) {
      const match = command.match(process.platform === "win32" ? safetyChecks.windows : safetyChecks.linux);
      if (!match) {
        return false;
      }
      if (process.platform == "win32") {
        command = match[1] || match[2];
        if (match[3]) {
          args = match[3].split(" ").concat(args);
        }
      } else {
        command = match[1];
        if (match[2]) {
          args = match[2].split(" ").concat(this.args);
        }
      }
      return {
        command,
        args
      };
    };
    var safetyChecks = {
      windows: /(?:"(.*[^\/])"|(\w+))(?:\s(.*))?/,
      linux: /(.*?[^\\])(?: (.*)|$)/
    };
  }
});

// node_modules/forever-monitor/package.json
var require_package = __commonJS({
  "node_modules/forever-monitor/package.json"(exports, module2) {
    module2.exports = {
      name: "forever-monitor",
      description: "Core forever process monitor",
      version: "3.0.3",
      author: "Charlie Robbins <charlie.robbins@gmail.com>",
      contributors: [
        {
          name: "Charlie Robbins",
          email: "charlie@nodejitsu.com"
        },
        {
          name: "Fedor Indutny",
          email: "fedor.indutny@gmail.com"
        },
        {
          name: "James Halliday",
          email: "mail@substack.net"
        },
        {
          name: "Bradley Meck",
          email: "bradley@nodejitsu.com"
        },
        {
          name: "Dominic Tarr",
          email: "dominic@nodejitsu.com"
        },
        {
          name: "Maciej Ma\u0142ecki",
          email: "maciej@nodejitsu.com"
        },
        {
          name: "Igor Savin",
          email: "kibertoad@gmail.com"
        }
      ],
      main: "./lib/index.js",
      scripts: {
        lint: 'eslint "lib/**/*.js" "test/**/*.js" "examples/**/*.js"',
        test: "vows test/**/*-test.js --dot-matrix -i",
        "test:ci": "npm run lint && npm run test",
        prettier: 'prettier --write "{lib,examples,test}/**/*.js"'
      },
      repository: {
        type: "git",
        url: "http://github.com/foreversd/forever-monitor.git"
      },
      keywords: [
        "fault tolerant",
        "sysadmin",
        "tools"
      ],
      dependencies: {
        async: "^1.5.2",
        chokidar: "^2.1.8",
        eventemitter2: "^6.4.3",
        minimatch: "^3.0.4",
        "ps-tree": "^1.2.0"
      },
      devDependencies: {
        eslint: "^5.16.0",
        "eslint-plugin-prettier": "^3.1.3",
        "eslint-config-prettier": "^6.11.0",
        prettier: "^1.19.1",
        semver: "5.7.1",
        vows: "0.7.0",
        yargs: "^3.32.0"
      },
      engines: {
        node: ">=6"
      },
      files: [
        "LICENSE",
        "README.md",
        "lib/*"
      ],
      license: "MIT"
    };
  }
});

// node_modules/forever-monitor/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/forever-monitor/lib/index.js"(exports) {
    var utils = require_utils();
    var common = require_common();
    exports.kill = common.kill;
    exports.checkProcess = common.checkProcess;
    exports.Monitor = require_monitor().Monitor;
    exports.version = require_package().version;
    exports.start = function(script, options) {
      if (!options.uid) {
        options.uid = options.uid || utils.randomString(4).replace(/^\-/, "_");
      }
      return new exports.Monitor(script, options).start();
    };
  }
});

// scripts/forever.js
var import_forever_monitor = __toESM(require_lib2(), 1);
console.log("Forever initializing");
console.log();
var child = new import_forever_monitor.default.Monitor("./node-agent-main.min.js", {
  silent: false,
  killTree: true,
  watch: false,
  args: [],
  logFile: "./logFile.log",
  outFile: "./out.log",
  errFile: "./err.log"
});
child.on("restart", function() {
  console.error("Forever restarting Xyte`s agent for " + child.times + " time");
});
child.on("exit:code", function(code) {
  console.error("Forever detected Xyte`s agent exited with code " + code);
});
child.on("exit", function() {
  console.log("Xyte`s agent has exited");
});
console.log("Forever attempting to start Xyte's agent");
console.log();
child.start();
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
 * EventEmitter2
 * https://github.com/hij1nx/EventEmitter2
 *
 * Copyright (c) 2013 hij1nx
 * Licensed under the MIT license.
 */
/*!
 * arr-diff <https://github.com/jonschlinkert/arr-diff>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * arr-flatten <https://github.com/jonschlinkert/arr-flatten>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * array-unique <https://github.com/jonschlinkert/array-unique>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * assign-symbols <https://github.com/jonschlinkert/assign-symbols>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * collection-visit <https://github.com/jonschlinkert/collection-visit>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * copy-descriptor <https://github.com/jonschlinkert/copy-descriptor>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * define-property <https://github.com/jonschlinkert/define-property>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * define-property <https://github.com/jonschlinkert/define-property>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * define-property <https://github.com/jonschlinkert/define-property>
 *
 * Copyright (c) 2015-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * for-in <https://github.com/jonschlinkert/for-in>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * fragment-cache <https://github.com/jonschlinkert/fragment-cache>
 *
 * Copyright (c) 2016-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * get-value <https://github.com/jonschlinkert/get-value>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * has-value <https://github.com/jonschlinkert/has-value>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * has-value <https://github.com/jonschlinkert/has-value>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * has-values <https://github.com/jonschlinkert/has-values>
 *
 * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * has-values <https://github.com/jonschlinkert/has-values>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-accessor-descriptor <https://github.com/jonschlinkert/is-accessor-descriptor>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-accessor-descriptor <https://github.com/jonschlinkert/is-accessor-descriptor>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * is-data-descriptor <https://github.com/jonschlinkert/is-data-descriptor>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-data-descriptor <https://github.com/jonschlinkert/is-data-descriptor>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * is-descriptor <https://github.com/jonschlinkert/is-descriptor>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * is-windows <https://github.com/jonschlinkert/is-windows>
 *
 * Copyright  2015-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * map-cache <https://github.com/jonschlinkert/map-cache>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * object-visit <https://github.com/jonschlinkert/object-visit>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * object.pick <https://github.com/jonschlinkert/object.pick>
 *
 * Copyright (c) 2014-2015 Jon Schlinkert, contributors.
 * Licensed under the MIT License
 */
/*!
 * pascalcase <https://github.com/jonschlinkert/pascalcase>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * repeat-element <https://github.com/jonschlinkert/repeat-element>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Licensed under the MIT license.
 */
/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * set-value <https://github.com/jonschlinkert/set-value>
 *
 * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * split-string <https://github.com/jonschlinkert/split-string>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * static-extend <https://github.com/jonschlinkert/static-extend>
 *
 * Copyright (c) 2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * to-object-path <https://github.com/jonschlinkert/to-object-path>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * to-regex-range <https://github.com/jonschlinkert/to-regex-range>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * unset-value <https://github.com/jonschlinkert/unset-value>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * use <https://github.com/jonschlinkert/use>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
